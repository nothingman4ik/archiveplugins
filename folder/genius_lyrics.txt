import requests
import json
import re
import threading
from base_plugin import BasePlugin, HookResult, HookStrategy
from android_utils import log
from ui.settings import Header, Input
from java.util import Locale
from client_utils import send_message, get_last_fragment, run_on_queue
from markdown_utils import parse_markdown
from bs4 import BeautifulSoup
from org.telegram.ui.ActionBar import AlertDialog
from org.telegram.messenger import ApplicationLoader
from ui.bulletin import BulletinHelper

__id__ = "genius_lyrics"
__name__ = "Genius Lyrics"
__description__ = "–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç –ø–µ—Å–Ω–∏ –∏–∑ Genius , —é–∑–∞–π .lyrics [–∏–º—è –ø–µ—Å–Ω–∏]."
__author__ = "@ArThirtyFour | @KangelPlugins"
__min_version__ = "11.12.1"
__version__ = "1.1.0"
__icon__ = "amechan_wakuwaku_by_fStikBot/1"

API_TOKEN = '9JiBRxKAEgfssIWg3Yw8uxKyDO0HZr1IQS5qVYQiKMLwJ4d_9tEMxxYlm3w_mIML'
API_BASE_URL = "https://api.genius.com"

progress_dialog = None

def show_with_copy(message, submsg):
    def copy():
        if AndroidUtilities.addToClipboard(submsg):
            BulletinHelper.show_copied_to_clipboard()

    BulletinHelper.show_with_button(message, R.raw.error, "Copy", lambda: copy())

class GeniusLyricsPlugin(BasePlugin):

    def __init__(self):
        super().__init__()
        self._dismiss_dialog()

    def _dismiss_dialog(self):
        global progress_dialog
        try:
            if progress_dialog is not None and progress_dialog.isShowing():
                progress_dialog.dismiss()
        except Exception:
            pass
        finally:
            progress_dialog = None

    def on_plugin_load(self):
        self.add_on_send_message_hook()

    def scrape_lyrics(self, song_url):
        log(f"[GeniusLyrics] Starting to scrape lyrics from: {song_url}")
        try:
            response = requests.get(song_url, timeout=10)
            log(f"[GeniusLyrics] HTTP response status: {response.status_code}")
            if response.status_code != 200:
                log(f"[GeniusLyrics] Bad HTTP status: {response.status_code}")
                return None
                
            html = BeautifulSoup(response.text.replace("<br/>", "\n"), "html.parser")
            log(f"[GeniusLyrics] HTML parsed successfully")
            
            divs = html.find_all(
                "div", class_=re.compile(r"^Lyrics-\w{2}.\w+.[1]|Lyrics__Container")
            )
            log(f"[GeniusLyrics] Found {len(divs)} lyrics divs")
            
            if not divs:
                log(f"[GeniusLyrics] No lyrics divs found")
                return None
                
            lyrics = "\n".join([div.get_text() for div in divs])
            log(f"[GeniusLyrics] Raw lyrics length: {len(lyrics)} characters")
            
            lyrics = re.sub(r"(\[.*?\])*", "", lyrics)
            lyrics = re.sub("\n{2}", "\n", lyrics) 
            log(f"[GeniusLyrics] Cleaned lyrics length: {len(lyrics)} characters")
            
            lines = lyrics.strip("\n").split('\n')
            log(f"[GeniusLyrics] Total lines before processing: {len(lines)}")
            if lines and len(lines) > 1:
                lyrics = '\n'.join(lines[1:]).strip()
                log(f"[GeniusLyrics] Removed first line, final lyrics length: {len(lyrics)} characters")
            else:
                log(f"[GeniusLyrics] Not enough lines to remove first line")
            
            return lyrics
            
        except Exception as e:
            log(f"[GeniusLyrics] Error scraping lyrics: {str(e)}")
            return None

    def format_lyrics_message(self, song_title, artist_name, lyrics, song_url):
        log(f"[GeniusLyrics] Formatting message for: {song_title} by {artist_name}")
        if lyrics:
            log(f"[GeniusLyrics] Lyrics available, length: {len(lyrics)}")
            if len(lyrics) > 3500:
                lyrics = lyrics[:3500] + "\n\n... (—Ç–µ–∫—Å—Ç –æ–±—Ä–µ–∑–∞–Ω)"
                log(f"[GeniusLyrics] Lyrics truncated to 3500 characters")
            formatted_lyrics = ""
            lines = lyrics.split('\n')
            log(f"[GeniusLyrics] Processing {len(lines)} lines")
            for line in lines:
                line = line.strip()
                if line:
                    formatted_lyrics += f"{line}\n"
                else:
                    formatted_lyrics += "\n"
            
            markdown_message = f"üéµ **{song_title}**\nüë§ _–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: {artist_name}_\n\nüîó [–û—Ç–∫—Ä—ã—Ç—å –Ω–∞ Genius]({song_url})\n\n||{formatted_lyrics}||"
            log(f"[GeniusLyrics] Final message length: {len(markdown_message)}")
        else:
            log(f"[GeniusLyrics] No lyrics available, showing fallback message")
            markdown_message = f"üéµ **{song_title}**\nüë§ _–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: {artist_name}_\n\nüîó [–û—Ç–∫—Ä—ã—Ç—å –Ω–∞ Genius]({song_url})\n\n‚ùå –¢–µ–∫—Å—Ç –ø–µ—Å–Ω–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω"
        
        return markdown_message

    def on_send_message_hook(self, account, params) -> HookStrategy:
        if not isinstance(params.message, str):
            log(f"[GeniusLyrics] Message is not a string, skipping")
            return HookResult()

        message_text = params.message.strip()
        command_prefix = ".lyrics"
        
        if not message_text.startswith(command_prefix + " ") and message_text != command_prefix:
            return HookResult()

        if message_text == command_prefix:
            song_name = ""
        else:
            song_name = message_text[len(command_prefix):].strip()

        log(f"[GeniusLyrics] Command detected: '{command_prefix}' with song: '{song_name}'")

        if not song_name:
            log(f"[GeniusLyrics] No song name provided, showing usage")
            params.message = f"Usage: {command_prefix} [song name]"
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

        genius_username = self.get_setting("genius_username", "")
        if genius_username:
            log(f"[GeniusLyrics] Using Genius username from settings: {genius_username}")

        log(f"[GeniusLyrics] Searching Genius for lyrics: {song_name}")

        # Show bulletin notification instead of progress dialog
        BulletinHelper.show_info("üîç –ò—â–µ–º —Ç–µ–∫—Å—Ç –ø–µ—Å–Ω–∏...")

        # Run search in background queue
        run_on_queue(lambda: self.search_and_reply(params.peer, song_name))

        params.message = "üîç –ò—â–µ–º —Ç–µ–∫—Å—Ç –ø–µ—Å–Ω–∏..."
        return HookResult(strategy=HookStrategy.CANCEL)

    def search_and_reply(self, peer, song_name):
        log(f"[GeniusLyrics] Starting search in background queue for peer: {peer}")
        try:
            search_url = f"{API_BASE_URL}/search?q={requests.utils.quote(song_name)}"
            log(f"[GeniusLyrics] Search URL: {search_url}")
            headers = {"Authorization": f"Bearer {API_TOKEN}"}
            response = requests.get(search_url, headers=headers, timeout=10)
            log(f"[GeniusLyrics] Genius API response status: {response.status_code}")

            if response.status_code != 200:
                error_msg = f"–û—à–∏–±–∫–∞ API Genius: {response.status_code}"
                log(f"[GeniusLyrics] API error: {error_msg}")
                BulletinHelper.show_error(error_msg)
                send_message({
                    "peer": peer,
                    "message": f"‚ùå {error_msg}"
                })
                return

            data = response.json()
            log(f"[GeniusLyrics] Parsed JSON response")

            if data and data['response'] and data['response']['hits']:
                log(f"[GeniusLyrics] Found {len(data['response']['hits'])} search results")
                song_url = data['response']['hits'][0]['result']['url']
                song_title = data['response']['hits'][0]['result']['title']
                artist_name = data['response']['hits'][0]['result']['primary_artist']['name']
                
                log(f"[GeniusLyrics] Selected song: {song_title} by {artist_name}")
                log(f"[GeniusLyrics] Song URL: {song_url}")
                
                lyrics = self.scrape_lyrics(song_url)
                
                markdown_message = self.format_lyrics_message(song_title, artist_name, lyrics, song_url)
                
                log(f"[GeniusLyrics] Sending formatted message")
                parsed_message = parse_markdown(markdown_message)
                send_message({
                    "peer": peer,
                    "message": parsed_message.text,
                    "entities": [i.to_tlrpc_object() for i in parsed_message.entities]
                })
                
                log(f"[GeniusLyrics] Message sent successfully")
                BulletinHelper.show_success("–¢–µ–∫—Å—Ç –ø–µ—Å–Ω–∏ –Ω–∞–π–¥–µ–Ω!")
                return HookResult(strategy=HookStrategy.CANCEL)
            else:
                error_msg = f"–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç–µ–∫—Å—Ç –¥–ª—è –ø–µ—Å–Ω–∏ \"{song_name}\""
                log(f"[GeniusLyrics] No search results found: {error_msg}")
                BulletinHelper.show_error(error_msg)
                send_message({
                    "peer": peer,
                    "message": f"‚ùå {error_msg}"
                })
                return HookResult(strategy=HookStrategy.CANCEL)

        except Exception as e:
            error_msg = f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {str(e)}"
            log(f"[GeniusLyrics] Exception in search_and_reply: {str(e)}")
            BulletinHelper.show_error(error_msg)
            send_message({
                "peer": peer,
                "message": f"‚ùå {error_msg}"
            })
            return HookResult(strategy=HookStrategy.CANCEL) 