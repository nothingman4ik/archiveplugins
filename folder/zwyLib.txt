"""
Если вы при разработке своего плагина использовали готовые фрагменты кода из моего, пожалуйста,
укажите в описании своего плагина @zwylair в качестве благодарности за вклад в разработку. Спасибо ♥

If you used code snippets from my plugin in the development of your own, please credit @zwylair
in your plugin’s description as a thank you for the contribution. Thanks ♥


⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣤⣀⠀⠀⠀⠀⣀⣠⣤⣤⣤⣄⡀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⠿⠛⠛⠛⠛⠛⢿⣷⣤⣾⠿⠛⠛⠙⠛⠛⠿⠗
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⡿⠁⠀⠀⠀⠀⠀⠀⠀⠙⡿⠁⠀⠀⠀⢀⣤⣀⠀⠀⢀⣤⣶⡆
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⡇
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣧⣄
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⠀⣿⣷⣄⣀⣤⡄⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⠷
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣁⣤⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠘⠛⠛⠛⠻⣿⣿⣿⠋⠉⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠻⢿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠹⣿⡟⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⠟⢙⠛⠛⠀⠀⠀⠀⠀⠀⣀⣴⡿⠓⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠁⠀⠈⠻⢿⣦⣄⠀⣠⣾⡿⠋⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⠿⠋⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀
"""

import copy
import shlex
import time
import json
import zlib
import inspect
import logging
import os.path
import threading
import traceback

from packaging.version import Version
from dataclasses import dataclass, field
from typing import List, Callable, Optional, Any, Union, Dict, Tuple, Type
from typing_extensions import get_origin, get_args, deprecated, overload

import markdown_utils
from ui.bulletin import BulletinHelper as _BulletinHelper
from ui.settings import Divider, Header, Switch, Input, Text
from base_plugin import BasePlugin, HookResult, HookStrategy
from android_utils import log as _log, run_on_ui_thread
from client_utils import get_messages_controller, get_file_loader, get_last_fragment, get_messages_storage, run_on_queue

from java import dynamic_proxy, jint, jclass
from java.util import Locale, ArrayList
from java.lang import Long, Integer, Boolean, String
from org.telegram.tgnet import TLRPC
from org.telegram.ui import ChatActivity
from org.telegram.messenger import Utilities, FileLoader, R, Utilities
from com.exteragram.messenger.plugins import PluginsController, Plugin

__name__ = "ZwyLib"
__description__ = "Zwylair's library with highly used things"
__icon__ = "zwyPluginsIcons/0"
__id__ = "zwylib"
__version__ = "1.2.2"
__author__ = "@zwylair"
__min_version__ = "11.12.1"
__all__ = (
    # storage
    "CacheFile", "JsonCacheFile",

    # zwylib-based
    "is_zwylib_version_sufficient",
    "add_autoupdater_task", "remove_autoupdater_task",
    "build_log", "build_bulletin_helper",
    "get_message",

    # commands
    "command_manager",
    "CannotCastError", "WrongArgumentAmountError", "MissingRequiredArguments", "InvalidTypeError",

    # utils
    "Callback1",
    "SingletonMeta"
)


class SingletonMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            instance = super().__call__(*args, **kwargs)
            cls._instances[cls] = instance
        return cls._instances[cls]


class Callback1(dynamic_proxy(Utilities.Callback)):
    def __init__(self, fn: Callable[[Any], None]):
        super().__init__()
        self._fn = fn

    def run(self, arg):
        try:
            self._fn(arg)
        except:
            logger.info(f"Error in Callback1: {format_exc()}")


class CacheFile:
    def __init__(self, filename: str, read_on_init=True, compress=False):
        self.filename = filename
        self.path = os.path.join(CACHE_DIRECTORY, filename)
        self._content: Optional[bytes] = None
        self.compress = compress
        self.logger = build_log(f"{__name__} {self.filename}")

        os.makedirs(CACHE_DIRECTORY, exist_ok=True)

        if read_on_init:
            self.read()

    def read(self):
        if not os.path.exists(self.path):
            self.logger.warning(f"{self.path} does not exist, setting None value.")
            self._content = None
            return

        try:
            with open(self.path, "rb") as file:
                file_content = file.read()

            if self.compress and file_content.startswith(b"\x78\x9c"):  # zlib compressed data starts with these bytes
                file_content = zlib.decompress(file_content)
            self._content = file_content
        except:
            self.logger.error(f"Failed to load data from {self.path}: {format_exc()}")
            self.logger.debug("Setting None value.")
            self._content = None

    def write(self):
        try:
            save_data = self._content
            if self.compress:
                save_data = zlib.compress(save_data, level=6)

            with open(self.path, "wb") as file:
                file.write(save_data)
        except PermissionError as e:
            self.logger.error(f"Have no permissions to edit {self.path}: {format_exc_only(e)}")

    def wipe(self):
        self._content = None
        self.write()

    def delete(self):
        if not os.path.exists(self.path):
            self.logger.warning(f"File {self.path} does not exist, nothing to delete")
            return

        try:
            os.remove(self.path)
        except Exception as e:
            self.logger.error(f"Failed to delete {self.path}: {format_exc_only(e)}")

    @property
    def content(self) -> Optional[bytes]:
        return self._content

    @content.setter
    def content(self, value: Optional[bytes]):
        self._content = value


class JsonCacheFile(CacheFile):
    def __init__(self, filename: str, default: Any, read_on_init=True, compress=False):
        self._default = copy.deepcopy(default)
        self.json_content = self._get_copy_of_default()
        super().__init__(filename, read_on_init, compress)

    def _get_copy_of_default(self) -> Any:
        return copy.deepcopy(self._default)

    def read(self):
        super().read()

        if not self._content:
            self.json_content = self._get_copy_of_default()
            self._content = json.dumps(self.json_content).encode()

        try:
            self.json_content = json.loads(self._content.decode("utf-8", errors="replace"))
        except (UnicodeDecodeError, json.JSONDecodeError) as e:
            self.logger.error(f"Failed to load JSON from {self.path}: {format_exc_only(e)}")
            self.logger.debug(f"Setting default value.")
            self.json_content = self._get_copy_of_default()

    def write(self):
        self._content = json.dumps(self.json_content).encode("utf-8", errors="replace")
        super().write()

    def wipe(self):
        self.json_content = self._get_copy_of_default()
        super().wipe()

    @property
    def content(self) -> Any:
        if self._content is None:
            return self._get_copy_of_default()
        return self.json_content

    @content.setter
    def content(self, value: Any):
        self.json_content = value


@dataclass
class UpdaterTask:
    plugin_id: str
    channel_id: int
    message_id: int


class AutoUpdater:
    def __init__(self):
        self.thread: Optional[threading.Thread] = None
        self.forced_stop = False
        self.forced_update_check = False
        self.tasks: List[UpdaterTask] = []
        self.msg_edited_ts_cache = JsonCacheFile("zwylib_au__msg_edited_ts", {})  # plugin_id: edit_timestamp_of_message_with_file
        self.hash = str(zlib.adler32(id(self).to_bytes(8, "little")))
        self.logger = build_log(f"{__name__} AU {self.hash}")

    def run(self):
        self.forced_stop = False

        if self.thread is None:
            self.thread = threading.Thread(target=self.cycle)
            self.thread.daemon = True

        if self.thread.is_alive():
            self.logger.info("Thread has not been stopped")
            return

        self.thread.start()
        self.logger.info("Thread was started")

    def force_stop(self):
        if self.thread is None:
            self.logger.info("Ignored: thread has not been started")
            return
        self.forced_stop = True

    def cycle(self):
        event = threading.Event()
        event.wait(5)  # Initial delay

        while not self.forced_stop:
            try:
                self.check_for_updates()
                event.wait(self.get_timeout_time())
                if self.forced_update_check:
                    self.logger.info("Forced update check was requested, checking for updates...")
                    self.forced_update_check = False
            except:
                self.logger.info("Exception in cycle:", format_exc())

        self.thread = None
        self.logger.info("Force stopped")

    def check_for_updates(self):
        def get_message_callback(msg: Optional[TLRPC.TL_message], plugin_task: UpdaterTask):
            debug_mode = is_debug_mode_on()

            if not msg or isinstance(msg, TLRPC.TL_messageEmpty):
                self.logger.info(f"Task {plugin_task.plugin_id} message has not found. Removing the task...")
                self.remove_task(plugin_task)
                return

            if not msg.media:
                self.logger.info(f"Task {plugin_task.plugin_id} message has no document attached. Removing the task...")
                self.remove_task(plugin_task)
                return

            file_loader = get_file_loader()
            document = msg.media.getDocument()
            path = file_loader.getPathToAttach(document, True)

            if not PluginsController.getInstance().isPlugin(path):
                self.logger.info(f"The document attached to task {plugin_task.plugin_id} message is not plugin. Removing task...")
                self.remove_task(plugin_task)
                return

            disable_ts_check = setting_getter("disable_ts_check", DEFAULT_EDIT_TIMESTAMP_CHECK)
            if not disable_ts_check:
                msg_edited_ts = self.msg_edited_ts_cache.content.get(plugin_task.plugin_id)

                if debug_mode:
                    self.logger.info(plugin_task.plugin_id, self.msg_edited_ts_cache.content)
                    self.logger.info(f"{plugin_task.plugin_id} got msg_edited_ts: {msg_edited_ts}")
                    self.logger.info(f"{plugin_task.plugin_id} {msg.edit_date} == {msg_edited_ts}: {msg.edit_date == msg_edited_ts}")

                if msg.edit_date == msg_edited_ts:
                    self.logger.info(f"Attachment for task {plugin_task.plugin_id} has not been updated. Skipping...")
                    return

            self.msg_edited_ts_cache.content[plugin_task.plugin_id] = msg.edit_date
            self.msg_edited_ts_cache.write()
            run_on_queue(lambda: download_and_install_plugin(msg, plugin_task.plugin_id))

        for task in list(self.tasks):  # iterate copy of self.tasks to prevent RuntimeError
            plugin = get_plugin(task.plugin_id)

            if plugin is None:
                self.logger.info(f"Plugin {task.plugin_id} was not found. Removing task...")
                self.remove_task(task)
                continue

            if not plugin.isEnabled():
                self.logger.info(f"Plugin {task.plugin_id} is disabled. Removing task...")
                self.remove_task(task)
                continue

            self.logger.info(f"Executing for task {task.plugin_id}")
            get_message(-task.channel_id, task.message_id, lambda msg, process_task=task: get_message_callback(msg, process_task))

    def is_task_already_present(self, task: UpdaterTask):
        for i in list(self.tasks):
            if i.plugin_id == task.plugin_id:
                return True
        return False

    def add_task(self, task: UpdaterTask):
        if self.is_task_already_present(task):
            self.logger.info(f"Task {task.plugin_id} is already present")
            return

        self.tasks.append(task)
        self.logger.info(f"Added task {task.plugin_id}")

    def remove_task(self, task: UpdaterTask):
        if task not in self.tasks:
            self.logger.info(f"Task {task.plugin_id} is not present")
            return

        self.tasks.remove(task)
        self.logger.info(f"Removed task {task.plugin_id}")

    def remove_task_by_id(self, plugin_id: str):
        filtered_tasks = list(filter(lambda task: task.plugin_id != plugin_id, self.tasks))
        if len(filtered_tasks) < len(self.tasks):
            self.tasks = filtered_tasks
            self.logger.info(f"Removed task {plugin_id}")
        else:
            self.logger.info(f"Task {plugin_id} is not present")

    def get_timeout_time(self) -> int:
        try:
            return int(setting_getter("autoupdate_timeout", DEFAULT_AUTOUPDATE_TIMEOUT))
        except (ValueError, TypeError):
            self.logger.info(format_exc())
            return int(DEFAULT_AUTOUPDATE_TIMEOUT)

    def force_update_check(self):
        self.logger.info("Forced update check was requested")
        self.forced_update_check = True


def download_and_install_plugin(msg, plugin_id: str, is_queued: bool = False):
    def plugin_install_error(arg):
        if arg is not None:
            logger.error(f"Error installing {plugin_id}: {arg}")
            BulletinHelper.show_error(f"Error installing {plugin_id}. More in logcat")

    file_loader = get_file_loader()
    plugins_controller = PluginsController.getInstance()
    document = msg.media.getDocument()
    path = file_loader.getPathToAttach(document, True)

    if not path.exists():
        if is_queued:
            logger.info(f"Waiting 1s for the {plugin_id} plugin file to be downloaded...")
            time.sleep(1)
        else:
            logger.info(f"Started loading the {plugin_id} plugin file...")

        file_loader.loadFile(document, "new_plugin", FileLoader.PRIORITY_NORMAL, 1)
        run_on_queue(lambda: download_and_install_plugin(msg, plugin_id, is_queued=True))
        return

    logger.info(f"Installing {plugin_id}...")

    try:
        plugins_controller.loadPluginFromFile(str(path), Callback1(plugin_install_error))
    except TypeError:
        # there is 3 arguments in refactored plugin engine
        plugins_controller.loadPluginFromFile(str(path), None, Callback1(plugin_install_error))


def get_message(chat_id: int, message_id: int, callback: Callable[[Union[TLRPC.TL_message, TLRPC.TL_messageEmpty, None]], None]):
    def wait_for_db_update(tries_limit = 10, sleep_time = 1):
        method.invoke(msg_controller, array, chat_id, jint(0))

        for _ in range(tries_limit):
            msg = msg_storage.getMessage(chat_id, message_id)
            if msg:
                callback(msg)
                break
            time.sleep(sleep_time)

    msg_controller = get_messages_controller()
    msg_storage = get_messages_storage()
    clazz = msg_controller.getClass()
    method = clazz.getDeclaredMethod("reloadMessages", ArrayList, Long.TYPE, Integer.TYPE)
    method.setAccessible(True)

    array = ArrayList()
    array.add(jint(message_id))
    run_on_queue(wait_for_db_update)


def get_plugin(plugin_id: str) -> Optional[Plugin]:
    return PluginsController.getInstance().plugins.get(plugin_id)


@overload
@deprecated("Use add_autoupdater_task(plugin_id, channel_id, message_id) instead")
def add_autoupdater_task(plugin_id: str, channel_id: int, channel_username: str, message_id: int) -> None: ...


@overload
def add_autoupdater_task(plugin_id: str, channel_id: int, message_id: int) -> None: ...


def add_autoupdater_task(plugin_id: str, channel_id: int, arg3: Union[str, int], arg4: Optional[int] = None) -> None:
    if isinstance(arg3, str) and isinstance(arg4, int):
        logger.warning(f"Ignoring deprecated channel_username='{arg3}'")
        message_id = arg4
    elif isinstance(arg3, int) and arg4 is None:
        message_id = arg3
    else:
        raise TypeError("Invalid arguments for add_autoupdater_task")

    task = UpdaterTask(plugin_id, channel_id, message_id)

    if autoupdater is None:
        logger.info(f"AutoUpdater is not initialized yet, saving task {plugin_id} to pending list...")
        companion.module.autoupdates_tasks.append(task)
        return

    autoupdater.add_task(task)
    logger.info(f"Task {plugin_id} successfully added")


def remove_autoupdater_task(plugin_id: str):
    if autoupdater is None:
        logger.info(f"AutoUpdater is not initialized. Removing {plugin_id} task from cache...")
        companion.module.autoupdates_tasks = list(
            filter(lambda task: task.plugin_id != plugin_id, companion.module.autoupdates_tasks)
        )
        return

    logger.info(f"Removing {plugin_id} task...")
    autoupdater.remove_task_by_id(plugin_id)


def cache_all_autoupdater_tasks():
    companion.module.autoupdates_tasks.clear()
    companion.module.autoupdates_tasks = autoupdater.tasks.copy()


def load_cached_autoupdater_tasks():
    autoupdater.tasks = companion.module.autoupdates_tasks.copy()
    companion.module.autoupdates_tasks.clear()


class CustomLogger(logging.Logger):
    def _log(self, level, msg, args, exc_info=None, extra=None, stack_info=False, stacklevel=1):
        caller_frame = inspect.stack()[2]
        func_name = caller_frame.function

        pre_msg_items = [self.name, func_name]
        pre_msg_items = filter(lambda i: i, pre_msg_items)  # filter out empty items
        pre_msg_items = map(lambda i: f"[{i}]", pre_msg_items)  # put item in brackets

        formatted_args = map(str, args)
        formatted_args = " ".join(formatted_args)
        formatted_args = f" {formatted_args}" if formatted_args else ""

        text = " ".join(pre_msg_items) + f" {msg}{formatted_args}"
        _log(text)


def build_log(plugin_name: str, level = logging.INFO) -> logging.Logger:
    new_logger = logging.getLogger(plugin_name)
    new_logger.setLevel(level)
    return new_logger


def build_bulletin_helper(prefix: str) -> _BulletinHelper:
    class BHelper(_BulletinHelper):
        @classmethod
        def show_info(cls, message, fragment = None):
            super().show_info(f"{prefix}: {message}", fragment)

        @classmethod
        def show_error(cls, message, fragment = None):
            super().show_error(f"{prefix}: {message}", fragment)

        @classmethod
        def show_success(cls, message, fragment = None):
            super().show_success(f"{prefix}: {message}", fragment)
    return BHelper()


class Locales:
    en = {
        "autoupdater_header": "AutoUpdater",
        "autoupdate_timeout_title": "Auto update timeout",
        "autoupdate_timeout_hint": "Time in seconds between update checks",
        "disable_autoupdater_title": "Disable autoupdater",
        f"disable_autoupdater_hint": f"Auto updates will be disabled for all plugins using {__name__}",
        "disable_timestamp_check_title": "Disable message edit check",
        "disable_timestamp_check_hint": "Plugin will be updated even if the file has not been modified",
        "not_sufficient_zwylib_ver": "{plugin_name} needs " + __name__ + " {version}+, got {cur_ver}",
        "update_bulletin_button": "Update",
        "debug_mode_title": "Debug mode",
        "debug_mode_hint": "Prints some info to logcat",
        "debug_message_info": "Switch the debug mode off in plugin prefs",
        "dev_header": "Dev",
    }
    ru = {
        "autoupdater_header": "Автообновление",
        "autoupdate_timeout_title": "Таймаут автообновления",
        "autoupdate_timeout_hint": "Время в секундах между проверками обновлений",
        "disable_autoupdater_title": "Отключить автообновлялку",
        "disable_autoupdater_hint": f"Автообновления будут отключены для всех плагинов, использующих {__name__}",
        "disable_timestamp_check_title": "Отключить проверку редактирования сообщений",
        "disable_timestamp_check_hint": "Плагин будет обновлен, даже если файл не был изменен",
        "not_sufficient_zwylib_ver": "{plugin_name} нужен " + __name__ + " {version}+, текущая {cur_ver}",
        "update_bulletin_button": "Обновить",
        "debug_mode_title": "Режим отладки",
        "debug_mode_hint": "Написывает всякую инфу в logcat",
        "debug_message_info": "Отключите режим отладки в настройках плагина",
        "dev_header": "Dev",
    }
    uk = {
        "autoupdater_header": "Автооновлення",
        "autoupdate_timeout_title": "Таймаут автооновлення",
        "autoupdate_timeout_hint": "Час у секундах між перевірками оновлень",
        "disable_autoupdater_title": "Вимкнути автооновлення",
        "disable_autoupdater_hint": f"Автооновлення будуть вимкнені для всіх плагінів, що використовують {__name__}",
        "disable_timestamp_check_title": "Вимкнути перевірку редагування повідомлень",
        "disable_timestamp_check_hint": "Плагін буде оновлено, навіть якщо файл не було змінено",
        "not_sufficient_zwylib_ver": "{plugin_name} потрібен " + __name__ + " {version}+, поточна {cur_ver}",
        "update_bulletin_button": "Оновити",
        "debug_mode_title": "Режим налагодження",
        "debug_mode_hint": "Написує всяку інформацію у logcat",
        "debug_message_info": "Вимкніть режим налагодження у налаштуваннях плагіна",
        "dev_header": "Dev",
    }
    default = en


def localise(key: str) -> str:
    locale_dict = getattr(Locales, LOCALE, Locales.default)
    return locale_dict.get(key, key)


def is_zwylib_version_sufficient(plugin_name: str, version: str, show_bulletin = True) -> bool:
    is_sufficient = Version(__version__) >= Version(version)

    if show_bulletin and not is_sufficient:
        BulletinHelper.show_with_button(
            localise("not_sufficient_zwylib_ver").format(plugin_name=plugin_name, version=version, cur_ver=__version__),
            R.raw.chats_infotip,
            localise("update_bulletin_button"),
            lambda: get_last_fragment().presentFragment(ChatActivity.of(-AUTOUPDATE_CHANNEL_ID, AUTOUPDATE_MSG_ID)),
        )

    return is_sufficient


def is_debug_mode_on() -> bool:
    global setting_getter

    if setting_getter is None:
        return DEFAULT_DEBUG_MODE
    return setting_getter("debug_mode", DEFAULT_DEBUG_MODE)


class CannotCastError(Exception):
    pass


class WrongArgumentAmountError(Exception):
    pass


class MissingRequiredArguments(Exception):
    pass


class InvalidTypeError(Exception):
    pass


def _register_command(
        target: Dict[str, "Command"],
        command: "Command",
        plugin_id: str,
        is_subcommand: bool = False,
) -> None:
    name = command.name
    log_prefix = f"Command {name}:" if is_subcommand else f"Dispatcher {plugin_id}:"
    cmd_type = "Subcommand" if is_subcommand else "Command"
    pending_commands = companion.module.pending_commands

    if not name:
        cmd_logger.error(f"{log_prefix} {cmd_type} name ({name}) cannot be empty")
        return

    if " " in name:
        cmd_logger.error(f"{log_prefix} {cmd_type} name ({name}) cannot contain spaces")
        return

    if command_manager.temporal and not is_subcommand:
        cmd_logger.info(f"{log_prefix} {cmd_type} manager is not initialized, saving command to pending list.")

        if plugin_id not in pending_commands:
            pending_commands[plugin_id] = []

        if name in map(lambda cmd: cmd.name, pending_commands[plugin_id]):
            cmd_logger.warning(f"{log_prefix} {cmd_type} '{name}' is already in pending list")
            return

        pending_commands[plugin_id].append(command)
        return

    if name in target:
        cmd_logger.warning(f"{log_prefix} {cmd_type} '{name}' is already registered")
        return

    cmd_logger.debug(f"{log_prefix} Registering {cmd_type.lower()} {name}")
    target[name] = command


@dataclass
class CommandTestUnit:
    input: str
    arg_specs: Tuple[inspect.Parameter, ...]
    expected_args: Optional[Tuple[Any, ...]]
    should_succeed: bool
    description: str
    expected_exception: Optional[Type[Exception]] = None


@dataclass
class ArgSpec:
    name: str
    annotation: Any
    kind: inspect._ParameterKind
    default: Any = inspect.Parameter.empty
    is_optional: bool = False

    @classmethod
    def from_parameter(cls, param: inspect.Parameter) -> "ArgSpec":
        annotation = param.annotation if param.annotation != inspect.Parameter.empty else Any
        is_optional = get_origin(annotation) in (Union, Optional) and type(None) in get_args(annotation)
        return cls(
            name=param.name,
            annotation=annotation,
            kind=param.kind,
            default=param.default,
            is_optional=is_optional
        )


@dataclass
class Command:
    func: Callable
    name: str
    args: List[ArgSpec] = field(default_factory=list)
    subcommands: Dict[str, "Command"] = field(default_factory=dict)
    error_handler: Optional[Callable[[Any, int, Exception], HookResult]] = None

    def subcommand(self, name: str):
        def decorator(func: Callable[[], None]):
            sub_cmd = create_command(func=func, name=name)
            _register_command(
                target=self.subcommands,
                command=sub_cmd,
                plugin_id=self.name,
                is_subcommand=True
            )
            return sub_cmd
        return decorator

    def register_error_handler(self, func: Callable[[Any, int, Exception], HookResult]):
        cmd_logger.debug(f"Registering error handler for {self.name} command")
        signature = inspect.signature(func)
        if len(signature.parameters) != 3:
            raise MissingRequiredArguments("Error handler must have only 'param', 'account' and 'exception' arguments")
        self.error_handler = func
        return func

    def __repr__(self):
        return f"{self.__class__.__name__}(name={self.name}, subs={list(self.subcommands.values())})"


def is_allowed_type(arg_type):
    """
    Check if the argument type is supported, including Optional and Union types with NoneType.

    :param arg_type: The type to check.
    :returns: True if the type is supported, False otherwise.
    """
    # Handle simple types
    if arg_type in ALLOWED_ARG_TYPES:
        return True

    # Handle NoneType explicitly for Optional/Union
    if arg_type is type(None):
        return True

    # Handle generic types (Union, Optional)
    origin = get_origin(arg_type)
    if origin in ALLOWED_ORIGIN:
        return all(is_allowed_type(t) for t in get_args(arg_type))
    return False


def create_command(func: Callable, name: str) -> Command:
    signature = inspect.signature(func)
    parameters = list(signature.parameters.values())
    return_type = signature.return_annotation

    if len(parameters) < 2:
        raise MissingRequiredArguments(
            "Command must have 'param' variable as first argument and 'account' variable as second argument"
        )

    args = [ArgSpec.from_parameter(param) for param in parameters]

    for index, arg in enumerate(args):
        if arg.kind == inspect.Parameter.VAR_POSITIONAL:
            origin_type = get_origin(arg.annotation) or arg.annotation
            if not is_allowed_type(origin_type):
                raise InvalidTypeError(
                    f"Variadic argument (index: {index}) type must be one of "
                    f"{*ALLOWED_ARG_TYPES, *ALLOWED_ORIGIN}, got {arg.annotation}"
                )
        elif not is_allowed_type(arg.annotation):
            raise InvalidTypeError(
                f"Command argument (index: {index}) signature must be one of "
                f"{*ALLOWED_ARG_TYPES, *ALLOWED_ORIGIN}, got {arg.annotation}"
            )

    if return_type != HookResult:
        return_type_name = "NoneType" if return_type == inspect.Parameter.empty else return_type
        raise InvalidTypeError(f"Command function must return {HookResult} object, got {return_type_name}")

    return Command(func=func, name=name, args=args)


class Dispatcher:
    def __init__(self, plugin_id: str, prefix: str, commands_priority: int):
        self.plugin_id = plugin_id
        self.prefix = prefix
        self.commands_priority = commands_priority
        self.listeners: Dict[str, Command] = {}  # command_name -> Command

    def set_prefix(self, prefix: str):
        cmd_logger.debug(f"Dispatcher {self.plugin_id}: Set '{prefix}' prefix")
        self.prefix = prefix

    def register_command(self, name: str):
        def decorator(func: Callable[[], None]):
            command = create_command(func=func, name=name)
            _register_command(
                target=self.listeners,
                command=command,
                plugin_id=self.plugin_id,
            )
            return command
        return decorator

    def unregister_command(self, name: str):
        """Unregisters a command and its subcommands by its name."""
        cmd_logger.debug(f"Dispatcher {self.plugin_id}: Unregistering command {name}")
        self.listeners.pop(name, None)


class CommandManager:
    def __init__(self):
        self.dispatchers: Dict[str, Dispatcher] = {}  # plugin_id -> Dispatcher
        self.temporal = True

    def get_dispatcher(self, plugin_id: str, prefix: str = "default", commands_priority = -1) -> Dispatcher:
        if not prefix or prefix == "default":
            prefix = DEFAULT_COMMAND_PREFIX

        if plugin_id not in self.dispatchers:
            self.dispatchers[plugin_id] = Dispatcher(
                plugin_id=plugin_id,
                prefix=prefix,
                commands_priority=commands_priority,
            )

        cmd_logger.debug(f"Getting dispatcher for {plugin_id} with prefix {prefix}")
        return self.dispatchers[plugin_id]

    def remove_dispatcher(self, plugin_id: str):
        cmd_logger.debug(f"Removing dispatcher for {plugin_id}")
        self.dispatchers.pop(plugin_id, None)

    def sort_dispatchers(self):
        """
        Sorts dispatchers by their commands priority.
        Dispatchers with higher priority will be processed first.
        """
        self.dispatchers = dict(sorted(self.dispatchers.items(), key=lambda i: i[1].commands_priority, reverse=True))
        cmd_logger.debug("Dispatchers sorted by commands priority")

    def mark_not_temporal(self):
        self.temporal = False

    def load_pending_commands(self):
        pending_commands: Dict[str, List[Command]] = companion.module.pending_commands
        cmd_logger.debug("Loading pending commands:", pending_commands)

        for plugin_id, commands in pending_commands.items():
            if not commands:
                continue

            cmd_logger.debug(f"Loading pending commands for {plugin_id}")
            dispatcher = self.get_dispatcher(plugin_id)

            for command in commands:
                cmd_logger.debug(f"Registering pending command {command.name} for {plugin_id}")
                dispatcher.listeners[command.name] = command

        pending_commands.clear()

    def save_commands_as_pending(self):
        cmd_logger.info("Saving all commands to pending list...")
        cmd_logger.info("Saving:", self.dispatchers)

        pending_commands: Dict[str, List[Command]] = companion.module.pending_commands
        for plugin_id, dp in self.dispatchers.items():
            pending_commands[plugin_id] = list(dp.listeners.values())

        cmd_logger.debug("Saved commands:", pending_commands)

    def unregister_all(self):
        cmd_logger.debug("Unregistering all dispatchers...")
        self.dispatchers.clear()


def cast_arg(arg: str, target_type: type):
    """
    Just casts a string to the target type.
    :raises CannotCastError: If the string cannot be cast to the target type.
    """

    if target_type == str or target_type == Any:
        return arg
    elif target_type == int:
        return int(arg)
    elif target_type == float:
        return float(arg)
    elif target_type == bool:
        if arg.lower() in ("true", "1", "yes", "on"):
            return True
        elif arg.lower() in ("false", "0", "no", "off"):
            return False
        else:
            raise CannotCastError(f"Cannot cast '{arg}' to bool")
    else:
        raise CannotCastError(f"Unsupported target type: {target_type}")


def smart_cast(arg: str, annotation):
    """
    Casts the string to the type specified in the annotation, including Optional and Union.
    :raises CannotCastError: If the string cannot be cast to any of the types in Union or the annotation is not supported.
    """

    origin = get_origin(annotation)
    args = get_args(annotation)

    if annotation in ALLOWED_ARG_TYPES:
        try:
            return cast_arg(arg, annotation)
        except:
            raise CannotCastError(f"Could not cast '{arg}' to {annotation}")
    elif origin is Union:
        for possible_type in args:
            if possible_type == type(None):
                continue
            try:
                return cast_arg(arg, possible_type)
            except:
                continue
        raise CannotCastError(f"Could not cast '{arg}' to any of: {args}")
    raise CannotCastError(f"Unsupported annotation: {annotation}")


def parse_args(
    raw_args: List[str],
    command_args: List[ArgSpec]
) -> Tuple[Any, ...]:
    """
    Parses a list of raw argument strings into typed arguments based on the command's argument specifications.

    :param raw_args: List of raw argument strings.
    :param command_args: List of ArgSpec describing the expected arguments.
    :returns: Tuple of parsed arguments.
    :raises WrongArgumentAmountError: If the number of provided arguments is incorrect.
    :raises CannotCastError: If an argument cannot be cast to the expected type.
    """
    out: List[Any] = []
    # Исключаем вариадические аргументы из required_arg_count
    required_arg_count = sum(
        1 for arg in command_args
        if not arg.is_optional and arg.default == inspect.Parameter.empty and arg.kind != inspect.Parameter.VAR_POSITIONAL
    )
    is_variadic = any(arg.kind == inspect.Parameter.VAR_POSITIONAL for arg in command_args)
    variadic_arg = next((arg for arg in command_args if arg.kind == inspect.Parameter.VAR_POSITIONAL), None)

    # Check argument count
    if not is_variadic and len(raw_args) > len(command_args):
        raise WrongArgumentAmountError(
            f"Expected at most {len(command_args)} arguments, got {len(raw_args)}"
        )
    if len(raw_args) < required_arg_count:
        raise WrongArgumentAmountError(
            f"Expected at least {required_arg_count} arguments, got {len(raw_args)}"
        )

    # Process arguments
    for i, cmd_arg in enumerate(command_args):
        if cmd_arg.kind == inspect.Parameter.VAR_POSITIONAL:
            # Handle variadic arguments
            variadic_args = raw_args[i:] if i < len(raw_args) else []
            if not variadic_args:
                # Пустой ввод для вариадического аргумента — валидный случай, возвращаем пустой кортеж
                cmd_logger.debug(f"No variadic arguments provided for {cmd_arg.name}, returning empty tuple")
                break
            for arg in variadic_args:
                cmd_logger.debug(f"Processing variadic argument: {arg}, expected type: {cmd_arg.annotation}")
                parsed_arg = smart_cast(arg, cmd_arg.annotation)
                cmd_logger.debug(f"Variadic argument parsed successfully: {parsed_arg}")
                out.append(parsed_arg)
            break
        elif i < len(raw_args):
            # Handle provided argument
            cmd_logger.debug(f"Processing argument {i}: {raw_args[i]}, expected type: {cmd_arg.annotation}")
            parsed_arg = smart_cast(raw_args[i], cmd_arg.annotation)
            cmd_logger.debug(f"Argument {i} parsed successfully: {parsed_arg}")
            out.append(parsed_arg)
        elif cmd_arg.default != inspect.Parameter.empty:
            # Use default value
            cmd_logger.debug(f"Argument {i} missing, using default value: {cmd_arg.default}")
            out.append(cmd_arg.default)
        elif cmd_arg.is_optional:
            # Use None for Optional types
            cmd_logger.debug(f"Argument {i} missing, using None for Optional type: {cmd_arg.annotation}")
            out.append(None)
        else:
            cmd_logger.error(f"Argument {i} missing for non-Optional, non-default type: {cmd_arg.annotation}")
            raise WrongArgumentAmountError(
                f"Expected argument {i} of type {cmd_arg.annotation}, but none provided"
            )

    return tuple(out)


def register_zwylib_commands():
    logger.info("Registering ZwyLib commands...")
    dp = command_manager.get_dispatcher(__id__)

    @dp.register_command("zwylib")
    def zwylib(params, account) -> HookResult:
        return HookResult()

    @zwylib.subcommand("cmds")
    def zwylib_cmds(params, account) -> HookResult:
        def collect_commands(command: Command, prefix=""):
            full_name = (prefix + " " + command.name).strip()
            names = [full_name]
            for sub in command.subcommands.values():
                names.extend(collect_commands(sub, prefix=full_name))
            return names

        lines = []
        for dispatcher in command_manager.dispatchers.values():
            lines.append(f"\n- {dispatcher.plugin_id}:")
            for cmd in dispatcher.listeners.values():
                for name in collect_commands(cmd):
                    lines.append(f"\t- {name}")

        text = "\n".join(lines)
        parsed = markdown_utils.parse_markdown(text)

        params.message = parsed.text
        for ent in parsed.entities:
            params.entities.add(ent.to_tlrpc_object())

        return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=params)

    @zwylib_cmds.subcommand("test")
    def test_command_system(params, account) -> HookResult:
        test_cases = [
            CommandTestUnit(
                input="",
                arg_specs=(),
                expected_args=(),
                should_succeed=True,
                description="No arguments"
            ),
            CommandTestUnit(
                input="hi",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=inspect.Parameter.empty),
                ),
                expected_args=("hi",),
                should_succeed=True,
                description="Single mandatory not annotated argument"
            ),
            CommandTestUnit(
                input="hi",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=Any),
                ),
                expected_args=("hi",),
                should_succeed=True,
                description="Single mandatory Any argument"
            ),
            CommandTestUnit(
                input="hi",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=str),
                ),
                expected_args=("hi",),
                should_succeed=True,
                description="Single mandatory str argument"
            ),
            CommandTestUnit(
                input="42.5",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=float),
                ),
                expected_args=(42.5,),
                should_succeed=True,
                description="Float argument"
            ),
            CommandTestUnit(
                input="true",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=bool),
                ),
                expected_args=(True,),
                should_succeed=True,
                description="Single mandatory bool argument"
            ),
            CommandTestUnit(
                input="",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=int),
                ),
                expected_args=None,
                should_succeed=False,
                description="Missing mandatory int argument",
                expected_exception=WrongArgumentAmountError
            ),
            CommandTestUnit(
                input="",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=str, default="default"),
                ),
                expected_args=("default",),
                should_succeed=True,
                description="Argument with default value"
            ),
            CommandTestUnit(
                input="42 default 1",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=int),
                    inspect.Parameter(name="arg2", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=str),
                    inspect.Parameter(name="arg3", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=int),
                ),
                expected_args=(42, "default", 1),
                should_succeed=True,
                description="Multiple arguments with int and str"
            ),
            CommandTestUnit(
                input="hi",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=Optional[str]),
                ),
                expected_args=("hi",),
                should_succeed=True,
                description="Optional str argument with valid input"
            ),
            CommandTestUnit(
                input="",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=Optional[str]),
                ),
                expected_args=(None,),
                should_succeed=True,
                description="Optional str argument with no input"
            ),
            CommandTestUnit(
                input="hi",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=Optional[int]),
                ),
                expected_args=(None,),
                should_succeed=False,
                description="Optional int argument with invalid input",
                expected_exception=CannotCastError
            ),
            CommandTestUnit(
                input="1 2 3",
                arg_specs=(
                    inspect.Parameter(name="args", kind=inspect.Parameter.VAR_POSITIONAL, annotation=int),
                ),
                expected_args=(1, 2, 3),
                should_succeed=True,
                description="Variadic int arguments"
            ),
            CommandTestUnit(
                input="1 two 3",
                arg_specs=(
                    inspect.Parameter(name="args", kind=inspect.Parameter.VAR_POSITIONAL, annotation=int),
                ),
                expected_args=(None, None, None),
                should_succeed=False,
                description="Variadic int arguments with invalid input",
                expected_exception=CannotCastError
            ),
            CommandTestUnit(
                input="",
                arg_specs=(
                    inspect.Parameter(name="args", kind=inspect.Parameter.VAR_POSITIONAL, annotation=str),
                ),
                expected_args=(),
                should_succeed=True,
                description="Variadic str arguments with no input"
            ),
            CommandTestUnit(
                input="",
                arg_specs=(
                    inspect.Parameter(name="args", kind=inspect.Parameter.VAR_POSITIONAL, annotation=inspect.Parameter.empty),
                ),
                expected_args=(),
                should_succeed=True,
                description="Variadic Any arguments with no input"
            ),
        ]

        results = []
        for i, case in enumerate(test_cases):
            test_number = i + 1

            try:
                cmd_parameters = [ArgSpec.from_parameter(param) for param in case.arg_specs]
                args = shlex.split(case.input) if case.input.strip() else []
                parsed_args = parse_args(args, cmd_parameters)

                if case.should_succeed:
                    if parsed_args == case.expected_args:
                        results.append(f"Test {test_number} ({case.description}): Passed")
                    else:
                        results.append(f"Test {test_number} ({case.description}): Failed - Expected args {case.expected_args}, got {parsed_args}\nInput: {case.input}")
                else:
                    results.append(f"Test {test_number} ({case.description}): Failed - Expected to fail, but succeeded with args {parsed_args}\nInput: {case.input}")
            except Exception as e:
                if case.should_succeed:
                    results.append(f"Test {test_number} ({case.description}): Failed with {format_exc_only(e)}\nInput: {case.input}")
                elif case.expected_exception and isinstance(e, case.expected_exception):
                    results.append(f"Test {test_number} ({case.description}): Passed")
                else:
                    results.append(f"Test {test_number} ({case.description}): Failed with unexpected error {format_exc_only(e)}\nInput: {case.input}")

        text = "Command system tests:\n\n" + "\n\n".join(results)
        parsed = markdown_utils.parse_markdown(text)

        params.message = parsed.text
        for ent in parsed.entities:
            params.entities.add(ent.to_tlrpc_object())

        return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=params)

    @zwylib.subcommand("clear")
    def zwylib_clear(params, account) -> HookResult:
        for _ in range(60):
            logger.info("\n")

        BulletinHelper.show_info(localise("debug_message_info"))
        return HookResult(strategy=HookStrategy.CANCEL)

    @zwylib.subcommand("au")
    def zwylib_au(params, account) -> HookResult:
        return HookResult()

    @zwylib_au.subcommand("list")
    def zwylib_au_list(params, account) -> HookResult:
        text = "ZwyLib autoupdater tasks:\n" + "\n".join([f"\t- [{i.plugin_id}](t.me/c/{i.channel_id}/{i.message_id})" for i in autoupdater.tasks])
        new_msg = markdown_utils.parse_markdown(text)

        params.message = new_msg.text
        for i in new_msg.entities:
            params.entities.add(i.to_tlrpc_object())

        return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=params)


def format_exc():
    return traceback.format_exc().strip()


def format_exc_only(e: Exception) -> str:
    exc = traceback.format_exception_only(type(e), e)
    return "".join(exc).strip()


class Companion(metaclass=SingletonMeta):
    defaults = {
        "autoupdates_tasks": [],
        "pending_commands": {},
    }

    def __init__(self):
        self.module = None

    @staticmethod
    def create():
        lines = ["# Auto-generated zwylib companion file\n"]
        for key, default in Companion.defaults.items():
            lines.append(f"\n{key} = {repr(default)}")

        os.makedirs(os.path.dirname(COMPANION_PATH), exist_ok=True)
        with open(COMPANION_PATH, "w", encoding="utf-8") as f:
            f.writelines(lines)

    def import_it(self):
        import zwylib_companion
        self.module = zwylib_companion


logging.setLoggerClass(CustomLogger)

AUTOUPDATE_CHANNEL_ID = 2521243181
AUTOUPDATE_MSG_ID = 48
LOG_PREFIX = __name__

DEFAULT_EDIT_TIMESTAMP_CHECK = False
DEFAULT_DISABLE_AUTOUPDATER = False
DEFAULT_DEBUG_MODE = False
DEFAULT_AUTOUPDATE_TIMEOUT = str(10 * 60)
DEFAULT_COMMAND_PREFIX = "."
LOCALE = Locale.getDefault().getLanguage()
ALLOWED_ARG_TYPES_SIGNATURE = Union[str, int, float, bool, None, Any]
ALLOWED_ARG_TYPES = (str, int, float, bool, Any)
ALLOWED_ORIGIN = (Union, Optional)
PLUGINS_DIRECTORY = PluginsController.getInstance().pluginsDir.getAbsolutePath()
CACHE_DIRECTORY = os.path.join(PLUGINS_DIRECTORY, "cache")
COMPANION_DIRECTORY = "zwylib_companion"
COMPANION_PATH = os.path.join(PLUGINS_DIRECTORY, COMPANION_DIRECTORY, "__init__.py")

setting_getter: Optional[Callable[[str, Optional[Any]], Any]] = None
autoupdater: Optional[AutoUpdater] = None
logger = build_log(LOG_PREFIX)
cmd_logger = build_log(f"{LOG_PREFIX} commands", logging.DEBUG)
BulletinHelper = build_bulletin_helper(LOG_PREFIX)
is_plugin_validating = False
command_manager = CommandManager()
companion = Companion()

companion.create()
companion.import_it()


class ZwyLib(BasePlugin):
    def create_settings(self):
        def force_update_check_onclick(_):
            if autoupdater:
                autoupdater.force_update_check()
            else:
                BulletinHelper.show_error("AutoUpdater is not initialized yet")

        try:
            return [
                Header(text=localise("autoupdater_header")),
                Text("Force update check", icon="msg_photo_switch2", on_click=force_update_check_onclick),
                Input(
                    key="autoupdate_timeout",
                    text=localise("autoupdate_timeout_title"),
                    subtext=localise("autoupdate_timeout_hint"),
                    default=DEFAULT_AUTOUPDATE_TIMEOUT,
                    icon="msg2_autodelete",
                ),
                Switch(
                    key="disable_autoupdate",
                    text=localise("disable_autoupdater_title"),
                    subtext=localise("disable_autoupdater_hint"),
                    default=DEFAULT_DISABLE_AUTOUPDATER,
                    icon="msg_download",
                    on_change=lambda enabled: autoupdater.force_stop() if enabled else run_on_ui_thread(autoupdater.run)
                ),
                Switch(
                    key="disable_ts_check",
                    text=localise("disable_timestamp_check_title"),
                    subtext=localise("disable_timestamp_check_hint"),
                    default=DEFAULT_EDIT_TIMESTAMP_CHECK,
                    icon="msg_recent",
                ),
                Header(text=localise("dev_header")),
                Switch(
                    key="debug_mode",
                    text=localise("debug_mode_title"),
                    subtext=localise("debug_mode_hint"),
                    default=DEFAULT_DEBUG_MODE,
                    icon="msg_log",
                ),
            ]
        except:
            text = (
                f"An exception occurred on {self.__class__.__name__}.create_settings():\n{format_exc()}"
            )
            logger.info(text)
            return [Divider(text=text)]

    def on_plugin_load(self):
        global autoupdater, setting_getter, is_plugin_validating, command_manager
        setting_getter = self.get_setting
        is_plugin_validating = "plugintemp" in __file__

        disable_autoupdate = setting_getter("disable_autoupdate", DEFAULT_DISABLE_AUTOUPDATER)
        if not is_plugin_validating and not disable_autoupdate:
            logger.info("Initialising AutoUpdater...")
            autoupdater = AutoUpdater()

            logger.info("Adding tasks from cache...")
            load_cached_autoupdater_tasks()

            add_autoupdater_task(__id__, AUTOUPDATE_CHANNEL_ID, AUTOUPDATE_MSG_ID)
            autoupdater.run()

        logger.info("Registering command manager...")
        command_manager.mark_not_temporal()
        command_manager.load_pending_commands()
        register_zwylib_commands()

        logger.info("Hooking...")
        self.add_on_send_message_hook(priority=999)

        logger.info("Loaded")

    def on_plugin_unload(self):
        if not is_plugin_validating and autoupdater:
            logger.info("Caching all tasks to add them again after reloading the plugin...")
            cache_all_autoupdater_tasks()

            logger.info("Force-stopping the AutoUpdater...")
            autoupdater.force_stop()

        command_manager.remove_dispatcher(__id__)
        command_manager.save_commands_as_pending()
        command_manager.unregister_all()

        logger.info("Unloaded")

    def on_send_message_hook(self, account, params):
        original_text = getattr(params, "message")
        if not original_text:
            return HookResult()

        command_manager.sort_dispatchers()
        for plugin_id, dp in command_manager.dispatchers.items():
            cmd_logger.debug(f"Searching for commands in {plugin_id} dispatcher...")

            if not original_text.startswith(dp.prefix):
                continue

            msg_text = original_text[len(dp.prefix):]
            args: List[Any] = shlex.split(msg_text.strip())

            if not args:
                continue

            cmd = dp.listeners.get(args[0])
            if not cmd:
                continue

            cmd_logger.debug(f"Found command: {cmd.name}. Looking for subcommands...")

            args = args[1:]
            while args and args[0] in cmd.subcommands:
                cmd = cmd.subcommands[args[0]]
                args = args[1:]
                cmd_logger.debug(f"Found subcommand: {cmd.name}. Continuing to search...")

            args.insert(0, params)
            args.insert(1, account)

            try:
                cmd_logger.debug("Preparing arguments...")
                parsed_args = parse_args(args, cmd.args)
                cmd_logger.debug(f"Executing command with args {parsed_args}...")
                return cmd.func(*parsed_args)
            except Exception as e:
                if cmd.error_handler:
                    cmd_logger.debug(f"Executing error handler for command {cmd.name}...")
                    return cmd.error_handler(params, account, e)

                message = f"Error executing command {cmd.name}: {format_exc()}"
                cmd_logger.error(message)
                message = markdown_utils.parse_markdown(f"```\n{message}\n```")

                params.message = message.text
                for i in message.entities:
                    params.entities.add(i.to_tlrpc_object())

                return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=params)
        return HookResult()
