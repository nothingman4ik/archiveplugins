from ui.settings import Header, Input, Switch, Selector, Divider
from base_plugin import BasePlugin, HookResult, HookStrategy
import json
import requests
from java.util import Locale
import traceback
from markdown_utils import parse_markdown
import time
import threading
from org.telegram.ui.ActionBar import AlertDialog
from client_utils import send_message, get_last_fragment, get_send_messages_helper, get_messages_controller, get_user_config, send_request
from android_utils import log
from java.io import File
from org.telegram.messenger import ApplicationLoader
from org.telegram.tgnet.tl import TL_account
from ui.bulletin import BulletinHelper
import os
import uuid
from typing import Optional, Any

__id__ = "steam"
__name__ = "Steam"
__version__ = "1.4.0"
__description__ = "üéÆ –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Ç–µ–∫—É—â—É—é –∏–≥—Ä—É –≤ Steam\n\nüìã –ö–æ–º–∞–Ω–¥—ã:\n‚Ä¢ [.nowsteam] ‚Äî —Ç–µ–∫—É—â–∞—è –∏–≥—Ä–∞\n‚Ä¢ [.slibrary] ‚Äî –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä\n‚Ä¢ [.sflibrary] ‚Äî –ø–æ–ª–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞\n\nüé® Design by @reNightly, @qmrrchh"
__author__ = "@KangelPlugins & @MGEPlugins"
__min_version__ = "11.9.0"
__icon__ = "OMGKAWAIIANGELGOD/3"
__load__ = True


class Locales:
    default = {
        "settings_main_header": "‚öôÔ∏è Basic Settings",
        "settings_steam_id": "Steam ID",
        "settings_steam_id_subtext": "Enter your Steam ID",
        "settings_api_key": "Steam API Key",
        "settings_api_key_subtext": "Get it at: https://steamcommunity.com/dev/apikey",
        "settings_auto_update_header": "üéÆ Profile Auto-Update",
        "settings_enable_auto": "Enable auto-update",
        "settings_enable_auto_subtext": "Automatically updates profile with game info",
        "settings_check_interval": "Check interval (seconds)",
        "settings_check_interval_subtext": "How often to check game status",
        "settings_update_location": "Update location",
        "settings_update_location_items": ["About", "Location (Premium)"],
        "settings_text_template": "Text template",
        "settings_text_template_subtext": "Use {game} for game name",
        "settings_default_text": "Default text",
        "settings_default_text_subtext": "Shown when no game is running",
        "settings_sort_by_playtime": "Sort by playtime",
        "settings_sort_by_playtime_subtext": "If disabled, sorts by last played date",
        "settings_usage_divider": "Usage: .nowsteam",
        "error_steam_id_not_set": "First set up your Steam ID in plugin settings!",
        "error_api_key_not_set": "First set up your API key in plugin settings!",
        "error_steam_id_not_found": "Steam ID not found or profile is hidden",
        "error_invalid_api_key": "Invalid API key. Get a new key at https://steamcommunity.com/dev/apikey",
        "error_network": "Network error! Check your internet connection",
        "error_api": "Error: Invalid response from Steam API",
        "error_unknown": "Error: {e}",
        "searching": "Searching...",
        "not_playing": "Not playing anything...",
        "playing_format": "üéÆ | Currently playing: {game}",
        "developers": "üë®‚Äçüíª | **Developers:** {developers}",
        "publishers": "üè¢ | **Publishers:** {publishers}",
        "metacritic": "‚≠ê | **Metacritic Score:** {score}/100",
        "genres": "üè∑ | **Genres:** {genres}",
        "playtime": "‚è± | **Playtime:** {hours} hrs. {minutes} min.",
        "playtime_minutes": "‚è± | **Playtime:** {minutes} min.",
        "game_link": "üéÆ | [Game Link]({url})",
        "post_found_header": "üéÆ *Game found!*\n\n",
        "requested_tags_line": "üîç *Requested tags:* `{tags}`\n\n",
        "post_tags_line": "üè∑Ô∏è *Tags in post:* `{tags}`\n\n",
        "image_link_line": "üîó *Link:* [Open image]({url})",
    }
    en = default
    ru = {
        "settings_main_header": "‚öôÔ∏è –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏",
        "settings_steam_id": "Steam ID",
        "settings_steam_id_subtext": "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à Steam ID",
        "settings_api_key": "Steam API Key",
        "settings_api_key_subtext": "–ü–æ–ª—É—á–∏—Ç—å: https://steamcommunity.com/dev/apikey",
        "settings_auto_update_header": "üéÆ –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è",
        "settings_enable_auto": "–í–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ",
        "settings_enable_auto_subtext": "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –ø—Ä–æ—Ñ–∏–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± –∏–≥—Ä–µ",
        "settings_check_interval": "–ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ (—Å–µ–∫—É–Ω–¥—ã)",
        "settings_check_interval_subtext": "–ö–∞–∫ —á–∞—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å —Å—Ç–∞—Ç—É—Å –∏–≥—Ä—ã",
        "settings_update_location": "–ú–µ—Å—Ç–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è",
        "settings_update_location_items": ["–û —Å–µ–±–µ", "–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è (–ü—Ä–µ–º–∏—É–º)"],
        "settings_text_template": "–®–∞–±–ª–æ–Ω —Ç–µ–∫—Å—Ç–∞",
        "settings_text_template_subtext": "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ {game} –¥–ª—è –Ω–∞–∑–≤–∞–Ω–∏—è –∏–≥—Ä—ã",
        "settings_default_text": "–¢–µ–∫—Å—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é",
        "settings_default_text_subtext": "–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è, –∫–æ–≥–¥–∞ –∏–≥—Ä–∞ –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞",
        "settings_sort_by_playtime": "–°–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã",
        "settings_sort_by_playtime_subtext": "–ï—Å–ª–∏ –≤—ã–∫–ª—é—á–µ–Ω–æ, —Å–æ—Ä—Ç–∏—Ä—É–µ—Ç –ø–æ –¥–∞—Ç–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–ø—É—Å–∫–∞",
        "settings_usage_divider": "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: .nowsteam",
        "error_steam_id_not_set": "–°–Ω–∞—á–∞–ª–∞ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ Steam ID –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø–ª–∞–≥–∏–Ω–∞!",
        "error_api_key_not_set": "–°–Ω–∞—á–∞–ª–∞ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ API –∫–ª—é—á –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø–ª–∞–≥–∏–Ω–∞!",
        "error_steam_id_not_found": "Steam ID –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –ø—Ä–æ—Ñ–∏–ª—å —Å–∫—Ä—ã—Ç",
        "error_invalid_api_key": "–ù–µ–≤–µ—Ä–Ω—ã–π API –∫–ª—é—á. –ü–æ–ª—É—á–∏—Ç–µ –Ω–æ–≤—ã–π –∫–ª—é—á –Ω–∞ https://steamcommunity.com/dev/apikey",
        "error_network": "–û—à–∏–±–∫–∞ —Å–µ—Ç–∏! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É",
        "error_api": "–û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç Steam API",
        "error_unknown": "–û—à–∏–±–∫–∞: {e}",
        "searching": "–ò—â–µ–º –∏–≥—Ä—É...",
        "not_playing": "–°–µ–π—á–∞—Å –Ω–µ –∏–≥—Ä–∞—é –Ω–∏ –≤–æ —á—Ç–æ...",
        "playing_format": "üéÆ | –°–µ–π—á–∞—Å –∏–≥—Ä–∞—é –≤: {game}",
        "developers": "üë®‚Äçüíª | **–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏:** {developers}",
        "publishers": "üè¢ | **–ò–∑–¥–∞—Ç–µ–ª–∏:** {publishers}",
        "metacritic": "‚≠ê | **–û—Ü–µ–Ω–∫–∞ Metacritic:** {score}/100",
        "genres": "üè∑ | **–ñ–∞–Ω—Ä—ã:** {genres}",
        "playtime": "‚è± | **–í—Ä–µ–º—è –≤ –∏–≥—Ä–µ:** {hours} —á. {minutes} –º–∏–Ω.",
        "playtime_minutes": "‚è± | **–í—Ä–µ–º—è –≤ –∏–≥—Ä–µ:** {minutes} –º–∏–Ω.",
        "game_link": "üéÆ | [–°—Å—ã–ª–∫–∞ –Ω–∞ –∏–≥—Ä—É]({url})",
        "post_found_header": "üéÆ *–ù–∞–π–¥–µ–Ω–∞ –∏–≥—Ä–∞!*\n\n",
        "requested_tags_line": "üîç *–ó–∞–ø—Ä–æ—à–µ–Ω–Ω—ã–µ —Ç–µ–≥–∏:* `{tags}`\n\n",
        "post_tags_line": "üè∑Ô∏è *–¢–µ–≥–∏ –≤ –ø–æ—Å—Ç–µ:* `{tags}`\n\n",
        "image_link_line": "üîó *–°—Å—ã–ª–∫–∞:* [–û—Ç–∫—Ä—ã—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ]({url})",
    }

def localise(key: str, **kwargs) -> str:
    lang = Locale.getDefault().getLanguage()
    locale_dict = getattr(Locales, lang, Locales.default)
    text = locale_dict.get(key, key)
    return text.format(**kwargs) if kwargs else text

TEMP_DIR_NAME = "temp_steam_images"
DEFAULT_STREAM_STRING = localise("playing_format")
DEFAULT_STREAM_TEXT = localise("not_playing")
DEFAULT_CHECK_INTERVAL = 30  
progress_dialog = None

class SteamPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._temp_dir = None
        self._streamer_thread = None
        self._stop_streamer = False
        threading.Thread(target=self._streamer, daemon=True).start()

    def _streamer(self):
        log("[Steam] Streamer started")
        while not self._stop_streamer:
            try:
                if self.get_setting("update_bio", False):
                    log("[Steam] Update bio is enabled")
                    userFull = get_messages_controller().getUserFull(get_user_config().getClientUserId())
                    if not userFull:
                        log("[Steam] Failed to get userFull")
                        time.sleep(5)
                        continue

                    stream_place = self.get_setting("stream_place", 1 if get_user_config().isPremium() else 0)
                    max_len = 140 if get_user_config().isPremium() else 70

                    steam_id = self.get_setting("steam_id", "")
                    api_key = self.get_setting("api_key", "")
                    
                    if not steam_id:
                        log("[Steam] Steam ID is not set")
                        time.sleep(5)
                        continue

                    log(f"[Steam] Fetching game for user {steam_id}")
                    result, _, _, _ = self.get_game(steam_id, api_key)
                    log(f"[Steam] Got result from get_game: {result}")
                    
                    if result != self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT) and result != 'Steam ID –Ω–µ –Ω–∞–π–¥–µ–Ω...':
                        log(f"[Steam] Found game: {result}")
                        new_about_text = self.get_setting("track_display_format", DEFAULT_STREAM_STRING)
                        log(f"[Steam] Original format: {new_about_text}")
                        if isinstance(result, dict):
                            log(f"[Steam] Result is a dict, using name: {result['name']}")
                            new_about_text = new_about_text.replace("{game}", str(result['name']))
                        else:
                            log(f"[Steam] Result is a string: {result}")
                            new_about_text = new_about_text.replace("{game}", str(result))
                        log(f"[Steam] Final about text: {new_about_text}")
                        
                        if stream_place == 0:
                            if userFull.about != new_about_text[:max_len]:
                                try:
                                    req = TL_account.updateProfile()
                                    req.flags = 4
                                    req.about = new_about_text[:max_len]
                                    send_request(req, ())
                                    log("[Steam] Successfully updated bio")
                                except Exception as e:
                                    log(f"[Steam] Error updating bio: {e}")
                                    time.sleep(5)
                        else:
                            if not get_user_config().isPremium():
                                log("[Steam] User is not premium, can't update business location")
                                time.sleep(5)
                                continue
                            try:
                                req = TL_account.updateBusinessLocation()
                                req.address = new_about_text[:96]
                                req.flags = 1
                                send_request(req, ())
                                log("[Steam] Successfully updated business location")
                            except Exception as e:
                                log(f"[Steam] Error updating business location: {e}")
                                time.sleep(5)
                    else:
                        log("[Steam] No game found")
                        default_bio = self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT)
                        if stream_place == 0:
                            if userFull.about != default_bio[:max_len]:
                                try:
                                    req = TL_account.updateProfile()
                                    req.flags = 4
                                    req.about = default_bio[:max_len]
                                    send_request(req, ())
                                    log("[Steam] Set default bio")
                                except Exception as e:
                                    log(f"[Steam] Error setting default bio: {e}")
                                    time.sleep(5)
                        else:
                            if not get_user_config().isPremium():
                                log("[Steam] User is not premium, can't update business location")
                                time.sleep(5)
                                continue
                            try:
                                req = TL_account.updateBusinessLocation()
                                req.address = default_bio[:96]
                                req.flags = 1
                                send_request(req, ())
                                log("[Steam] Set default bio in business location")
                            except Exception as e:
                                log(f"[Steam] Error setting default bio in business location: {e}")
                                time.sleep(5)

                    check_interval = self.get_setting("check_interval", DEFAULT_CHECK_INTERVAL)
                    time.sleep(check_interval)
            except Exception as e:
                log(f"[Steam] Streamer error: {e}")
                time.sleep(10)

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self._temp_dir = self._get_temp_dir()
        if self._temp_dir:
            log("Steam plugin loaded successfully")
            steam_id = self.get_setting("steam_id", "")
            api_key = self.get_setting("api_key", "")
            update_bio = self.get_setting("update_bio", False)
            log(f"[Steam] Loaded settings - Steam ID: {steam_id}, API Key: {'*' * 8 + api_key[-4:] if api_key else 'Not set'}, Update Bio: {update_bio}")
        else:
            log("Failed to initialize temp directory for Steam")

    def _get_temp_dir(self):
        try:
            base_dir = ApplicationLoader.getFilesDirFixed()
            if not base_dir:
                return None
            temp_dir = File(base_dir, TEMP_DIR_NAME)
            if not temp_dir.exists() and not temp_dir.mkdirs():
                return None
            return temp_dir
        except Exception as e:
            log(f"Error getting temp directory: {e}")
            return None

    def download_game_image(self, image_url):
        if not image_url:
            return None
        temp_dir = self._get_temp_dir()
        if not temp_dir or not temp_dir.isDirectory():
            return None

        filename = f"game_{uuid.uuid4()}.jpg"
        temp_photo_path = File(temp_dir, filename).getAbsolutePath()

        try:
            head = requests.head(image_url, timeout=5)
            content_length = int(head.headers.get('content-length', 0))
            if content_length > 10 * 1024 * 1024:
                return None

            resp = requests.get(image_url, stream=True, timeout=10)
            resp.raise_for_status()

            with open(temp_photo_path, 'wb') as f:
                for chunk in resp.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
            return temp_photo_path
        except Exception as e:
            try:
                if os.path.exists(temp_photo_path):
                    os.remove(temp_photo_path)
            except Exception:
                pass
            return None

    def delete_temp_file_async(self, file_path, delay_seconds=5):
        def _delete():
            try:
                time.sleep(delay_seconds)
                if os.path.exists(file_path):
                    os.remove(file_path)
            except Exception as e:
                pass
        threading.Thread(target=_delete, daemon=True).start()

    def create_settings(self):
        lang = Locale.getDefault().getLanguage()
        update_bio = self.get_setting("update_bio", False)
        
        settings = [
            Header(text=localise("settings_main_header")),
            Input(
                key="steam_id",
                text=localise("settings_steam_id"),
                subtext=localise("settings_steam_id_subtext"),
                default="",
                icon="filled_username"
            ),
            Input(
                key="api_key",
                text=localise("settings_api_key"),
                subtext=localise("settings_api_key_subtext"),
                default="",
                icon="msg_secret"
            ),
            Divider(),
            Header(text=localise("settings_auto_update_header")),
            Switch(
                key="update_bio",
                text=localise("settings_enable_auto"),
                default=False,
                subtext=localise("settings_enable_auto_subtext"),
                on_change=lambda new_value: self._show_stream_alert(new_value),
                icon="ic_ab_search"
            ),
            Input(
                key="check_interval",
                text=localise("settings_check_interval"),
                subtext=localise("settings_check_interval_subtext"),
                default=str(DEFAULT_CHECK_INTERVAL),
                icon="input_schedule"
            ) if update_bio else None,
            Selector(
                key="stream_place",
                text=localise("settings_update_location"),
                default=1 if get_user_config().isPremium() else 0,
                items=localise("settings_update_location_items"),
                icon="menu_premium_location" if get_user_config().isPremium() else "msg_openprofile"
            ) if update_bio and get_user_config().isPremium() else None,
            Input(
                key="track_display_format",
                text=localise("settings_text_template"),
                default=DEFAULT_STREAM_STRING,
                subtext=localise("settings_text_template_subtext"),
                icon="input_forward"
            ) if update_bio else None,
            Input(
                key="default_stream_text",
                text=localise("settings_default_text"),
                default=DEFAULT_STREAM_TEXT,
                subtext=localise("settings_default_text_subtext"),
                icon="input_reply"
            ) if update_bio else None,
            Divider(),
            Header(text="üìö –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏"),
            Switch(
                key="sort_by_playtime",
                text=localise("settings_sort_by_playtime"),
                default=True,
                subtext=localise("settings_sort_by_playtime_subtext"),
                icon="sort"
            ),
        ]
        return [s for s in settings if s is not None]

    def _show_stream_alert(self, value):
        if value:
            lang = Locale.getDefault().getLanguage()
            if lang.startswith('ru'):
                title = "‚ö†Ô∏è‚ö†Ô∏è–í–ù–ò–ú–ê–ù–ò–ï‚ö†Ô∏è‚ö†Ô∏è"
                message = "–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ –∏–∑-–∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π Telegram –Ω–∞ —á–∞—Å—Ç—É—é —Å–º–µ–Ω—É –ø—Ä–æ—Ñ–∏–ª—è. –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–∞ —Å–≤–æ–π —Å—Ç—Ä–∞—Ö –∏ —Ä–∏—Å–∫."
            else:
                title = "‚ö†Ô∏è‚ö†Ô∏èWARNING‚ö†Ô∏è‚ö†Ô∏è"
                message = "This feature may work inconsistently due to Telegram's profile change limits. Your profile information may not update immediately. Use at your own risk."
            fragment = get_last_fragment()
            ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
            dialog = AlertDialog(ctx, 3)
            dialog.setTitle(title)
            dialog.setMessage(message)
            dialog.setButton("OK", None)
            dialog.show()

    def get_game(self, id_steam, api_key):
        if not api_key:
            BulletinHelper.show_error("API –∫–ª—é—á –Ω–µ —É–∫–∞–∑–∞–Ω")
            return '‚ùå –û—à–∏–±–∫–∞: API –∫–ª—é—á –Ω–µ —É–∫–∞–∑–∞–Ω', None, None, None
            
        if not id_steam or not id_steam.strip():
            BulletinHelper.show_error("Steam ID –Ω–µ —É–∫–∞–∑–∞–Ω")
            return '‚ùå –û—à–∏–±–∫–∞: Steam ID –Ω–µ —É–∫–∞–∑–∞–Ω', None, None, None
            
        if not id_steam.isdigit():
            BulletinHelper.show_error("Steam ID –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã")
            return '‚ùå –û—à–∏–±–∫–∞: Steam ID –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã', None, None, None
            
        link = 'http://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002'
        params = {
            'key': api_key,
            'steamids': id_steam,
            'format': 'json'
        }
        max_retries = 3
        retry_delay = 2
        
        for attempt in range(max_retries):
            try:
                log(f"[SteamPlugin] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –∫ Steam API (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{max_retries})...")
                r = requests.get(link, params=params, timeout=20)
                
                if r.status_code == 403:
                    BulletinHelper.show_error("–ù–µ–≤–µ—Ä–Ω—ã–π API –∫–ª—é—á. –ü–æ–ª—É—á–∏—Ç–µ –Ω–æ–≤—ã–π –∫–ª—é—á –Ω–∞ https://steamcommunity.com/dev/apikey")
                    return '‚ùå –û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π API –∫–ª—é—á', None, None, None
                    
                r.raise_for_status()
                da = json.loads(r.text)
                log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –æ—Ç Steam API: {da}")
                
                if not da['response']['players']:
                    log("[SteamPlugin] Steam ID –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return '‚ùå –û—à–∏–±–∫–∞: Steam ID –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –ø—Ä–æ—Ñ–∏–ª—å —Å–∫—Ä—ã—Ç', None, None, None
                    
                player = da['response']['players'][0]
                log(f"[SteamPlugin] –î–∞–Ω–Ω—ã–µ –∏–≥—Ä–æ–∫–∞: {player}")
                
                if 'gameextrainfo' not in player:
                    log("[SteamPlugin] –ò–≥—Ä–æ–∫ –Ω–µ –≤ –∏–≥—Ä–µ")
                    return self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT), None, None, None
                    
                game_name = player['gameextrainfo']
                game_id = player.get('gameid')
                log(f"[SteamPlugin] –ù–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã: {game_name}, ID –∏–≥—Ä—ã: {game_id}")
                
                if not game_id:
                    log("[SteamPlugin] ID –∏–≥—Ä—ã –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return game_name, None, None, None
                    
                game_store_url = f"https://store.steampowered.com/app/{game_id}/"
                
                stats_link = f'http://api.steampowered.com/IPlayerService/GetOwnedGames/v0001/'
                stats_params = {
                    'key': api_key,
                    'steamid': id_steam,
                    'include_appinfo': 1,
                    'include_played_free_games': 1,
                    'format': 'json'
                }
                try:
                    log("[SteamPlugin] –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏–≥—Ä—ã...")
                    stats_r = requests.get(stats_link, params=stats_params, timeout=10)
                    stats_r.raise_for_status()
                    stats_data = json.loads(stats_r.text)
                    log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: {stats_data}")
                    
                    playtime = 0  
                    if 'response' in stats_data and 'games' in stats_data['response']:
                        for game in stats_data['response']['games']:
                            if str(game.get('appid')) == str(game_id):
                                playtime = game.get('playtime_forever', 0)
                                log(f"[SteamPlugin] –ù–∞–π–¥–µ–Ω–æ –≤—Ä–µ–º—è –∏–≥—Ä—ã: {playtime} –º–∏–Ω—É—Ç")
                                break
                except Exception as e:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã: {e}")
                    playtime = 0
                    
                game_link = 'http://store.steampowered.com/api/appdetails'
                game_params = {
                    'appids': game_id,
                    'l': 'russian',
                    'format': 'json'
                }
                try:
                    log("[SteamPlugin] –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –¥–µ—Ç–∞–ª–∏ –∏–≥—Ä—ã...")
                    game_r = requests.get(game_link, params=game_params, timeout=10)
                    game_r.raise_for_status()
                    game_data = json.loads(game_r.text)
                    log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω—ã –¥–µ—Ç–∞–ª–∏ –∏–≥—Ä—ã: {game_data}")
                    
                    if str(game_id) in game_data and game_data[str(game_id)]['success']:
                        game_info = game_data[str(game_id)]['data']
                        log(f"[SteamPlugin] –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∏–≥—Ä–µ: {game_info}")
                        
                        image_url = None
                        if 'header_image' in game_info:
                            image_url = game_info['header_image']
                        elif 'background' in game_info:
                            image_url = game_info['background']
                        elif 'screenshots' in game_info and game_info['screenshots']:
                            image_url = game_info['screenshots'][0]['path_full']
                            
                        metacritic_score = 'N/A'
                        if 'metacritic' in game_info and isinstance(game_info['metacritic'], dict):
                            metacritic_score = game_info['metacritic'].get('score', 'N/A')
                        
                        game_details = {
                            'name': game_name,
                            'developers': game_info.get('developers', []),
                            'publishers': game_info.get('publishers', []),
                            'metacritic': metacritic_score,
                            'genres': [g['description'] for g in game_info.get('genres', [])],
                            'categories': [c['description'] for c in game_info.get('categories', [])],
                            'release_date': game_info.get('release_date', {}).get('date', 'N/A'),
                            'short_description': game_info.get('short_description', ''),
                            'playtime': playtime,
                            'store_url': game_store_url
                        }
                        
                        log(f"[SteamPlugin] –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω—ã –¥–µ—Ç–∞–ª–∏ –∏–≥—Ä—ã: {game_details}")
                        return game_details, image_url, playtime, game_store_url
                        
                    log("[SteamPlugin] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª–∏ –∏–≥—Ä—ã")
                    return game_name, None, playtime, game_store_url
                    
                except Exception as e:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∏–≥—Ä–µ: {e}")
                    return game_name, None, playtime, game_store_url
                    
            except requests.exceptions.RequestException as e:
                log(f"[SteamPlugin] –û—à–∏–±–∫–∞ —Å–µ—Ç–∏ (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{max_retries}): {e}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    continue
                return '‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É', None, None, None
            except json.JSONDecodeError as e:
                log(f"[SteamPlugin] –û—à–∏–±–∫–∞ JSON: {e}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    continue
                return '‚ùå –û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç Steam API', None, None, None
            except Exception as e:
                log(f"[SteamPlugin] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {e}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    continue
                return f'‚ùå –û—à–∏–±–∫–∞: {str(e)}', None, None, None

    def _dismiss_dialog(self):
        global progress_dialog
        try:
            if progress_dialog is not None and progress_dialog.isShowing():
                progress_dialog.dismiss()
        except Exception:
            pass
        finally:
            progress_dialog = None

    def get_steam_library(self, steam_id, api_key):
        """–ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–≥—Ä –∏–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ Steam –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–≥—Ä –¥–ª—è Steam ID: {steam_id}")
        
        if not steam_id or not steam_id.strip() or not steam_id.isdigit():
            error_msg = "‚ùå –û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π Steam ID"
            log(f"[SteamPlugin] {error_msg}")
            return None, error_msg
            
        if not api_key or not api_key.strip():
            error_msg = "‚ùå –û—à–∏–±–∫–∞: –ù–µ —É–∫–∞–∑–∞–Ω API –∫–ª—é—á"
            log(f"[SteamPlugin] {error_msg}")
            return None, error_msg
            
        url = 'http://api.steampowered.com/IPlayerService/GetOwnedGames/v0001/'
        params = {
            'key': api_key,
            'steamid': steam_id,
            'include_appinfo': 1,
            'include_played_free_games': 1,
            'format': 'json'
        }
        
        try:
            log(f"[SteamPlugin] –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ Steam API: {url}")
            response = requests.get(url, params=params, timeout=20)
            log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç. –°—Ç–∞—Ç—É—Å: {response.status_code}")
            
            if response.status_code != 200:
                error_msg = f"‚ùå –û—à–∏–±–∫–∞ API: {response.status_code} - {response.text}"
                log(f"[SteamPlugin] {error_msg}")
                return None, error_msg
                
            data = response.json()
            log(f"[SteamPlugin] –û—Ç–≤–µ—Ç API: {json.dumps(data, ensure_ascii=False)[:500]}...")
            
            if 'response' not in data:
                error_msg = "‚ùå –û—à–∏–±–∫–∞: –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç Steam API"
                log(f"[SteamPlugin] {error_msg}")
                return None, error_msg
                
            if 'games' not in data['response']:
                error_msg = "‚ùå –û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∏–≥—Ä. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏ –ø—Ä–æ—Ñ–∏–ª—è."
                log(f"[SteamPlugin] {error_msg}")
                return None, error_msg
                
            games = data['response'].get('games', [])
            log(f"[SteamPlugin] –ù–∞–π–¥–µ–Ω–æ –∏–≥—Ä: {len(games)}")
            
            if not games:
                log("[SteamPlugin] –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä –ø—É—Å—Ç–∞")
                return [], "üìö –í–∞—à–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä –ø—É—Å—Ç–∞"
                
            sorted_games = sorted(games, key=lambda x: x.get('playtime_forever', 0), reverse=True)
            log(f"[SteamPlugin] –£—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω–æ –∏ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ {len(sorted_games)} –∏–≥—Ä")
            return sorted_games, None
            
        except requests.exceptions.RequestException as e:
            error_msg = f"‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏: {str(e)}"
            log(f"[SteamPlugin] {error_msg}")
            return None, error_msg
        except json.JSONDecodeError as e:
            error_msg = f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞–∑–±–æ—Ä–∞ JSON: {str(e)}"
            log(f"[SteamPlugin] {error_msg}")
            return None, error_msg
        except Exception as e:
            import traceback
            error_msg = f"‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {str(e)}\n{traceback.format_exc()}"
            log(f"[SteamPlugin] {error_msg}")
            return None, error_msg

    def on_callback_query_hook(self, account, params):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏–π –Ω–∞ inline-–∫–Ω–æ–ø–∫–∏"""
        try:
            if not hasattr(params, 'data'):
                return HookResult()
                
            data = params.data
            log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω callback: {data}")
            
            if data.startswith('sort_'):
                sort_type, steam_id = data.split('_', 1)[1].split('_', 1)
                
                api_key = self.get_setting("api_key", "").strip()
                
                try:
                    get_messages_controller().callCallbackQuery(params.query_id, "")
                except:
                    pass
                
                self.send_sorted_library(params.peer, steam_id, api_key, sort_type)
                
                try:
                    get_messages_controller().editMessageReplyMarkup(params.peer, params.msg_id, None)
                except Exception as e:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∫–Ω–æ–ø–æ–∫: {str(e)}")
                
                return HookResult(strategy=HookStrategy.CANCEL)
                
        except Exception as e:
            log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –≤ on_callback_query_hook: {str(e)}")
            import traceback
            log(f"[SteamPlugin] –¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞: {traceback.format_exc()}")
            
        return HookResult()
        
    def send_sorted_library(self, peer, steam_id, api_key, sort_type='hours', full_list=False):

        def _send():
            try:
                log(f"[SteamPlugin] –ó–∞–≥—Ä—É–∑–∫–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ —Å —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–æ–π: {sort_type}, full_list={full_list}")
                games, error = self.get_steam_library(steam_id, api_key)
                
                if error:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏: {error}")
                    send_message({"peer": peer, "message": error})
                    return
                    
                if not games:
                    log("[SteamPlugin] –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä –ø—É—Å—Ç–∞")
                    send_message({"peer": peer, "message": "üìö –í–∞—à–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä –ø—É—Å—Ç–∞"})
                    return
                
                if sort_type == 'hours':
                    games_sorted = sorted(games, key=lambda x: x.get('playtime_forever', 0), reverse=True)
                    sort_text = "–ü–æ –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã (–ø–æ —É–±—ã–≤–∞–Ω–∏—é)"
                else:
                    games_sorted = sorted(games, 
                        key=lambda x: x.get('rtime_last_played', x.get('last_played', 0)), 
                        reverse=True)
                    sort_text = "–ü–æ –¥–∞—Ç–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–ø—É—Å–∫–∞"
                
                games_list = []
                total_games = len(games_sorted)
                total_playtime = sum(game.get('playtime_forever', 0) for game in games_sorted) // 60
                
                max_games = 30
                games_to_show = games_sorted[:max_games]
                
                for i, game in enumerate(games_to_show, 1):
                    try:
                        name = game.get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∏–≥—Ä–∞')
                        playtime = game.get('playtime_forever', 0)
                        hours = playtime // 60
                        minutes = playtime % 60
                        
                        last_played = ""
                        if sort_type == 'last_played' and 'rtime_last_played' in game:
                            from datetime import datetime
                            last_played_ts = game['rtime_last_played']
                            if last_played_ts > 0:
                                last_played_date = datetime.fromtimestamp(last_played_ts).strftime('%d.%m.%Y')
                                last_played = f" (–ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞–∑: {last_played_date})"
                        
                        if hours > 0:
                            playtime_str = f"{hours}—á {minutes}–º{last_played}"
                        else:
                            playtime_str = f"{minutes}–º{last_played}"
                            
                        games_list.append(f"{i}. {name} - {playtime_str}")
                    except Exception as game_err:
                        log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–≥—Ä—ã {i}: {str(game_err)}")
                
                if total_games > max_games:
                    games_list.append(f"\n...–∏ –µ—â–µ {total_games - max_games} –∏–≥—Ä")
                
                if full_list:
                    message = f"üéÆ *–ü–æ–ª–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ Steam*\n–í—Å–µ–≥–æ –∏–≥—Ä: {total_games} | –û–±—â–µ–µ –≤—Ä–µ–º—è: {total_playtime}—á\n\n"
                    
                    games_by_letter = {}
                    for game in games_sorted:
                        name = game.get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∏–≥—Ä–∞')
                        first_letter = name[0].upper() if name and name[0].isalpha() else '#'
                        if first_letter not in games_by_letter:
                            games_by_letter[first_letter] = []
                        games_by_letter[first_letter].append(name)
                    
                    sorted_letters = sorted(games_by_letter.keys())
                    
                    for letter in sorted_letters:
                        games_str = ', '.join(games_by_letter[letter])
                        message += f"\n*{letter}*: {games_str}\n"
                    
                    message += f"\nüìä *–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞:* {sort_text}"
                else:
                    sort_buttons = [
                        [{"text": "üïí –ü–æ –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã", "callback_data": f"sort_hours_{steam_id}"}],
                        [{"text": "üìÖ –ü–æ –¥–∞—Ç–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–ø—É—Å–∫–∞", "callback_data": f"sort_last_played_{steam_id}"}]
                    ]

                    message = f"üéÆ *–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä Steam*\n–í—Å–µ–≥–æ –∏–≥—Ä: {total_games} | –û–±—â–µ–µ –≤—Ä–µ–º—è: {total_playtime}—á\n\n"
                    message += "\n".join(games_list)
                    message += f"\n\nüìä *–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞:* {sort_text}"
                
                log(f"[SteamPlugin] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º {'–ø–æ–ª–Ω—ã–π' if full_list else '–æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π'} —Å–ø–∏—Å–æ–∫ –∏–≥—Ä")
                parsed = parse_markdown(message)
                
                message_data = {
                    "peer": peer,
                    "message": parsed.text,
                    "entities": [entity.to_tlrpc_object() for entity in parsed.entities]
                }
                
                if not full_list and 'sort_buttons' in locals():
                    message_data["reply_markup"] = {"inline_keyboard": sort_buttons}
                
                send_message(message_data)
                
            except Exception as e:
                log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏: {str(e)}")
                import traceback
                log(f"[SteamPlugin] –¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞: {traceback.format_exc()}")
                try:
                    send_message({
                        "peer": peer,
                        "message": "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏."
                    })
                except:
                    pass
        
        threading.Thread(target=_send, daemon=True).start()
    
    def on_send_message_hook(self, account, params):
        if not hasattr(params, "message") or not isinstance(params.message, str):
            return HookResult()
            
        message = params.message.strip()
        
        if message in (".slibrary", ".sflibrary"):
            is_full_library = message == ".sflibrary"
            command_name = ".sflibrary" if is_full_library else ".slibrary"
            
            try:
                log(f"[SteamPlugin] –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã {command_name}")
                steam_id = self.get_setting("steam_id", "").strip()
                api_key = self.get_setting("api_key", "").strip()
                
                if not steam_id:
                    params.message = "‚ùå Steam ID –Ω–µ —É–∫–∞–∑–∞–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –µ–≥–æ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø–ª–∞–≥–∏–Ω–∞."
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)
                    
                if not api_key:
                    params.message = "‚ùå API –∫–ª—é—á –Ω–µ —É–∫–∞–∑–∞–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –µ–≥–æ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø–ª–∞–≥–∏–Ω–∞."
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)
                
                try:
                    BulletinHelper.show_info("üîç –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–ø–∏—Å–æ–∫ –∏–≥—Ä...")
                    log("[SteamPlugin] –ü–æ–∫–∞–∑–∞–Ω–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∑–∞–≥—Ä—É–∑–∫–µ")
                except Exception as e:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∫–∞–∑–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {str(e)}")
                
                def send_library_message(peer):
                    try:
                        log("[SteamPlugin] –ó–∞–≥—Ä—É–∑–∫–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏...")
                        games, error = self.get_steam_library(steam_id, api_key)
                        
                        if error:
                            log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏: {error}")
                            message = error
                        else:
                            if not games:
                                log("[SteamPlugin] –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä –ø—É—Å—Ç–∞")
                                message = "üìö –í–∞—à–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä –ø—É—Å—Ç–∞"
                            else:
                                log(f"[SteamPlugin] –£—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω–æ {len(games)} –∏–≥—Ä")
                                games_sorted = sorted(games, key=lambda x: x.get('playtime_forever', 0), reverse=True)
                                
                                games_list = []
                                total_games = len(games_sorted)
                                total_playtime = sum(game.get('playtime_forever', 0) for game in games_sorted) // 60 
                                
                                max_games = 30
                                games_to_show = games_sorted[:max_games]
                                
                                for i, game in enumerate(games_to_show, 1):
                                    try:
                                        name = game.get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∏–≥—Ä–∞')
                                        playtime = game.get('playtime_forever', 0)
                                        hours = playtime // 60
                                        minutes = playtime % 60
                                        if hours > 0:
                                            playtime_str = f"{hours}—á {minutes}–º"
                                        else:
                                            playtime_str = f"{minutes}–º"
                                        games_list.append(f"{i}. {name} - {playtime_str}")
                                    except Exception as game_err:
                                        log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–≥—Ä—ã {i}: {str(game_err)}")
                                
                                if total_games > max_games:
                                    games_list.append(f"\n...–∏ –µ—â–µ {total_games - max_games} –∏–≥—Ä")
                                
                                sort_buttons = [
                                    [{"text": "üïí –ü–æ –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã", "callback_data": f"sort_hours_{steam_id}"}],
                                    [{"text": "üìÖ –ü–æ –¥–∞—Ç–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–ø—É—Å–∫–∞", "callback_data": f"sort_last_played_{steam_id}"}]
                                ]
                                
                                message = f"üéÆ *–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä Steam*\n–í—Å–µ–≥–æ –∏–≥—Ä: {total_games} | –û–±—â–µ–µ –≤—Ä–µ–º—è: {total_playtime}—á\n\n"
                                message += "\n".join(games_list)
                                message += "\n\nüìä *–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞:* –ü–æ –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã (–ø–æ —É–±—ã–≤–∞–Ω–∏—é)"
                                log("[SteamPlugin] –°–æ–æ–±—â–µ–Ω–∏–µ —Å –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–æ")
                        
                        log("[SteamPlugin] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π –∏ –∫–Ω–æ–ø–∫–∞–º–∏")
                        parsed = parse_markdown(message)
                        send_message({
                            "peer": peer,
                            "message": parsed.text,
                            "entities": [entity.to_tlrpc_object() for entity in parsed.entities],
                            "reply_markup": {
                                "inline_keyboard": sort_buttons
                            }
                        })
                        
                    except Exception as e:
                        import traceback
                        error_msg = f"‚ùå –ù–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {str(e)}\n\n{traceback.format_exc()}"
                        log(f"[SteamPlugin] {error_msg}")
                        try:
                            send_message({
                                "peer": peer,
                                "message": "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏."
                            })
                        except:
                            pass
                
                try:
                    BulletinHelper.show_info("üîç –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–ø–∏—Å–æ–∫ –∏–≥—Ä...")
                    sort_type = 'hours' if self.get_setting("sort_by_playtime", True) else 'last_played'
                    self.send_sorted_library(params.peer, steam_id, api_key, sort_type, is_full_library)
                except Exception as e:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø–æ—Ç–æ–∫–∞: {str(e)}")
                    params.message = "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∑–∞–≥—Ä—É–∑–∫–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏"
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)
                
                return HookResult(strategy=HookStrategy.CANCEL)
                
            except Exception as e:
                import traceback
                error_msg = f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {str(e)}\n\n{traceback.format_exc()}"
                log(f"[SteamPlugin] {error_msg}")
                params.message = "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏."
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
        
        if not message.startswith(".nowsteam"):
            return HookResult()

        try:
            steam_id = self.get_setting("steam_id", "")
            api_key = self.get_setting("api_key", "")
            
            log(f"[SteamPlugin] –ö–æ–º–∞–Ω–¥–∞ .nowsteam –ø–æ–ª—É—á–µ–Ω–∞. Steam ID: {steam_id}, API Key: {'*' * 8 + api_key[-4:] if api_key else '–ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'}")
            
            if not steam_id:
                BulletinHelper.show_error(localise("error_steam_id_not_set"))
                return HookResult(strategy=HookStrategy.CANCEL)

            if not api_key:
                BulletinHelper.show_error(localise("error_api_key_not_set"))
                return HookResult(strategy=HookStrategy.CANCEL)

            def search_and_reply(peer):
                try:
                    log("[SteamPlugin] –ù–∞—á–∏–Ω–∞–µ–º –ø–æ–∏—Å–∫ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∏–≥—Ä–µ...")
                    result, image_url, playtime, game_url = self.get_game(steam_id, api_key)
                    log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {result}")
                    
                    if isinstance(result, str) and result.startswith('‚ùå –û—à–∏–±–∫–∞'):
                        BulletinHelper.show_error(result)
                        return

                    if result == self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT):
                        log("[SteamPlugin] –ò–≥—Ä–æ–∫ –Ω–µ –≤ –∏–≥—Ä–µ")
                        markdown_text = f'üéÆ | **{result}**'
                        parsed = parse_markdown(markdown_text)
                        send_message({
                            "peer": peer,
                            "message": parsed.text,
                            "entities": [entity.to_tlrpc_object() for entity in parsed.entities]
                        })
                        return

                    playtime_text = ""
                    if isinstance(result, dict) and 'playtime' in result:
                        log(f"[SteamPlugin] –í—Ä–µ–º—è –∏–≥—Ä—ã –∏–∑ —Å–ª–æ–≤–∞—Ä—è: {result['playtime']}")
                        hours = result['playtime'] // 60
                        minutes = result['playtime'] % 60
                        if hours > 0:
                            playtime_text = localise("playtime", hours=hours, minutes=minutes)
                        else:
                            playtime_text = localise("playtime_minutes", minutes=minutes)
                    elif playtime is not None:
                        log(f"[SteamPlugin] –í—Ä–µ–º—è –∏–≥—Ä—ã –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞: {playtime}")
                        hours = playtime // 60
                        minutes = playtime % 60
                        if hours > 0:
                            playtime_text = localise("playtime", hours=hours, minutes=minutes)
                        else:
                            playtime_text = localise("playtime_minutes", minutes=minutes)

                    if isinstance(result, dict):
                        log("[SteamPlugin] –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ —Å–ª–æ–≤–∞—Ä—è —Å –¥–µ—Ç–∞–ª—è–º–∏")
                        message = localise("playing_format", game=result['name'])
                        log(f"[SteamPlugin] –ë–∞–∑–æ–≤–∞—è —á–∞—Å—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è: {message}")
                        
                        if result.get('developers'):
                            log(f"[SteamPlugin] –î–æ–±–∞–≤–ª—è–µ–º —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤: {result['developers']}")
                            message += "\n" + localise("developers", developers=', '.join(result['developers']))
                            log(f"[SteamPlugin] –°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤: {message}")
                            
                        if result.get('publishers') and result['publishers'] != result.get('developers', []):
                            log(f"[SteamPlugin] –î–æ–±–∞–≤–ª—è–µ–º –∏–∑–¥–∞—Ç–µ–ª–µ–π: {result['publishers']}")
                            message += "\n" + localise("publishers", publishers=', '.join(result['publishers']))
                            log(f"[SteamPlugin] –°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∏–∑–¥–∞—Ç–µ–ª–µ–π: {message}")
                            
                        log(f"[SteamPlugin] –î–æ–±–∞–≤–ª—è–µ–º –æ—Ü–µ–Ω–∫—É Metacritic: {result.get('metacritic', 'N/A')}")
                        message += "\n" + localise("metacritic", score=result.get('metacritic', 'N/A'))
                        log(f"[SteamPlugin] –°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è Metacritic: {message}")
                        
                        if result.get('genres'):
                            log(f"[SteamPlugin] –î–æ–±–∞–≤–ª—è–µ–º –∂–∞–Ω—Ä—ã: {result['genres']}")
                            message += "\n" + localise("genres", genres=', '.join(result['genres'][:3]))
                            log(f"[SteamPlugin] –°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∂–∞–Ω—Ä–æ–≤: {message}")
                            
                        message += playtime_text
                        log(f"[SteamPlugin] –°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã: {message}")
                        
                        if result.get('store_url'):
                            log(f"[SteamPlugin] –î–æ–±–∞–≤–ª—è–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ Steam Store: {result['store_url']}")
                            message += "\n\n" + localise("game_link", url=result['store_url'])
                            log(f"[SteamPlugin] –ò—Ç–æ–≥–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ: {message}")
                    else:
                        log("[SteamPlugin] –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–æ—Å—Ç–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ")
                        message = localise("playing_format", game=result) + playtime_text
                        if game_url:
                            message += "\n\n" + localise("game_link", url=game_url)

                    log(f"[SteamPlugin] –ò—Ç–æ–≥–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ: {message}")

                    if image_url:
                        log(f"[SteamPlugin] –ü—ã—Ç–∞–µ–º—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: {image_url}")
                        temp_photo_path = self.download_game_image(image_url)
                        if temp_photo_path:
                            try:
                                helper = get_send_messages_helper()
                                generated_photo = helper.generatePhotoSizes(temp_photo_path, None)

                                if generated_photo is not None:
                                    log("[SteamPlugin] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Ñ–æ—Ç–æ")
                                    parsed_caption = parse_markdown(message)

                                    send_message({
                                        "peer": peer,
                                        "photo": generated_photo,
                                        "path": temp_photo_path,
                                        "caption": parsed_caption.text,
                                        "entities": [entity.to_tlrpc_object() for entity in parsed_caption.entities],
                                        "message": None
                                    })
                                    self.delete_temp_file_async(temp_photo_path)
                                    return
                                else:
                                    log("[SteamPlugin] –ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ñ–æ—Ç–æ")
                                    self.delete_temp_file_async(temp_photo_path)
                            except Exception as e:
                                log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–æ—Ç–æ: {e}")
                                self.delete_temp_file_async(temp_photo_path)
                    
                    log("[SteamPlugin] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ")
                    parsed = parse_markdown(message)
                    send_message({
                        "peer": peer,
                        "message": parsed.text,
                        "entities": [entity.to_tlrpc_object() for entity in parsed.entities]
                    })
                except Exception as e:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –≤ –ø–æ—Ç–æ–∫–µ –ø–æ–∏—Å–∫–∞: {e}")
                    BulletinHelper.show_error(localise("error_unknown", e=str(e)))

            try:
                BulletinHelper.show_info(localise("searching"))
            except Exception as e:
                log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –¥–∏–∞–ª–æ–≥–∞: {e}")

            threading.Thread(target=lambda: search_and_reply(params.peer), daemon=True).start()
            return HookResult(strategy=HookStrategy.CANCEL)
            
        except Exception as e:
            params.message = localise("error_unknown", e=str(e))
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

    def on_plugin_unload(self):
        log("Steam plugin unloaded") 