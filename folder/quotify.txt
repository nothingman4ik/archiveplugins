from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Header, Selector, Input, Text, Switch
from client_utils import get_send_messages_helper, get_messages_controller, send_request, RequestCallback, send_message
from org.telegram.messenger import ApplicationLoader
from org.telegram.tgnet import TLRPC
from java.io import File
from java.util import Locale

from PIL import Image, ImageDraw, ImageFont, ImageOps
import requests, uuid, os, traceback, random, threading

__id__ = "tailed-quotify"
__name__ = "quotify [FORK]"
__description__ = "quote messages by replying with .q command"
__author__ = "@tailsjs | Fork by: @ArThirtyFour | @KangelPlugins"
__min_version__ = "11.9.0"
__icon__ = "OMGKAWAIIANGELGOD/1"
__version__ = "1.2"

class DebugLogger:
    logs_dir = "/storage/emulated/0/Download/tailed_quotes_logs"
    logs = []
    
    @staticmethod
    def make_log(log):
        DebugLogger.logs.append(log)
        
    @staticmethod
    def save_logs():
        save_dir = DebugLogger.logs_dir + f"/log-{uuid.uuid4()}.txt"
        Filesystem.write_file(save_dir, '\n'.join(DebugLogger.logs).encode('utf-8'))
        return save_dir
    
    @staticmethod
    def format_tl_error(error):
        return f"TLRPC Error: {error.text} ({error.code})"

class QuoterPlugin(BasePlugin):
    def on_plugin_load(self):
        try:
            FontManager.init()
            LocalizationManager.init()
            self.add_on_send_message_hook()
            self._alert_builder_instance = None
        except Exception as e:
            DebugLogger.make_log("on_plugin_load\n" + str(traceback.format_exc()))

    def _show_font_faq_alert(self, view=None):
        from ui.alert import AlertDialogBuilder
        from org.telegram.messenger import ApplicationLoader
        from client_utils import get_last_fragment
        lang = Locale.getDefault().getLanguage()
        if lang.startswith('ru'):
            title = "üé® –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã"
            text = (
                "üìù –ö–∞–∫ –¥–æ–±–∞–≤–∏—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç?\n\n"
                "1Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ '–ö–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç' –≤ —Å–µ–ª–µ–∫—Ç–æ—Ä–µ —à—Ä–∏—Ñ—Ç–æ–≤\n\n"
                "2Ô∏è‚É£ –í –ø–æ–ª–µ '–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç' –≤—Å—Ç–∞–≤—å—Ç–µ –ø—Ä—è–º—É—é —Å—Å—ã–ª–∫—É –Ω–∞ .ttf —Ñ–∞–π–ª\n\n"
                "üîó –ü—Ä–∏–º–µ—Ä—ã —Å—Å—ã–ª–æ–∫:\n"
                "‚Ä¢ https://example.com/font.ttf\n"
                "‚Ä¢ https://fonts.gstatic.com/s/roboto/v30/font.ttf\n\n"
                "üí° –í –ö–û–ù–¶–ï –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –î–û–õ–ñ–ù–û –ë–´–¢–¨ .ttf\n\n"
                "3Ô∏è‚É£ –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ —Å–æ–∑–¥–∞–π—Ç–µ —Ü–∏—Ç–∞—Ç—É (.q)\n\n"
                "‚ö° –ü–ª–∞–≥–∏–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–∫–∞—á–∞–µ—Ç —à—Ä–∏—Ñ—Ç –∏ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ!\n\n"
                "üö® –í–ê–ñ–ù–û! –ü–†–ò –ü–ï–†–í–û–ú –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ò/–°–ú–ï–ù–ï –®–†–ò–§–¢–ê –ö–ê–†–¢–û–ß–ö–ê –ë–£–î–ï–¢ –°–û–ó–î–ê–í–ê–¢–¨–°–Ø –î–û–õ–¨–®–ï\n\n"
                "üíª –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∑–∞–≥—Ä—É–∂–∞—Ç—å —à—Ä–∏—Ñ—Ç—ã –Ω–∞ Github\n\n"
                "üåê –ì–¥–µ –∏—Å–∫–∞—Ç—å —à—Ä–∏—Ñ—Ç—ã (—Å –ø—Ä—è–º—ã–º–∏ —Å—Å—ã–ª–∫–∞–º–∏):\n"
                "‚Ä¢ https://fontsaddict.com\n"
                "‚Ä¢ https://en.bestfonts.pro\n"
            )
            close_button = "‚úÖ –ü–æ–Ω—è–ª"
        else:
            title = "üé® How to use custom fonts"
            text = (
                "üìù How to add a custom font?\n\n"
                "1Ô∏è‚É£ Select 'Custom font' in the font selector\n\n"
                "2Ô∏è‚É£ In the 'Custom font link' field, paste a direct link to the .ttf file\n\n"
                "üîó Example links:\n"
                "‚Ä¢ https://example.com/font.ttf\n"
                "‚Ä¢ https://fonts.gstatic.com/s/roboto/v30/font.ttf\n\n"
                "üí° AND THERE MUST BE .ttf AT THE END\n\n"
                "3Ô∏è‚É£ Save settings and create a quote (.q)\n\n"
                "‚ö° The plugin will automatically download and use the font!\n\n"
                "üö® IMPORTANT! ON FIRST USE/FONT CHANGE, CARD CREATION WILL TAKE LONGER\n\n"
                "üíª Recommended to upload fonts to Github\n\n"
                "üåê Where to find fonts (with direct links):\n"
                "‚Ä¢ https://fontsaddict.com\n"
                "‚Ä¢ https://en.bestfonts.pro\n"
            )
            close_button = "‚úÖ Got it"
        fragment = get_last_fragment()
        ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
        builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        builder.set_title(title)
        builder.set_message(text)
        builder.set_positive_button(close_button, lambda d, w: None)
        builder.set_cancelable(True)
        builder.set_canceled_on_touch_outside(True)
        builder.show()
        self._alert_builder_instance = builder

    def create_settings(self):
        return [
            Header(
                LocalizationManager.get_string("SETTINGS_TITLE")
            ),
            Selector(
                key="font",
                text=LocalizationManager.get_string("SETTINGS_FONT"),
                default=0,
                items=FontManager.get_fonts_names(),
                icon="msg_photo_text_regular"
            ),
            Input(
                key="custom_font_url",
                text=LocalizationManager.get_string("SETTINGS_CUSTOM_FONT_URL"),
                default="",
                subtext=LocalizationManager.get_string("SETTINGS_CUSTOM_FONT_URL_SUB"),
                icon="msg_photo_text_framed3"
            ),
            Text(
                text=LocalizationManager.get_string("SETTINGS_CUSTOM_FONT_FAQ"),
                icon="msg_info",
                on_click=self._show_font_faq_alert
            )
        ]
        
    def on_send_message_hook(self, account, params) -> HookStrategy:
        if not isinstance(params.message, str):
            return HookResult()
        
        if params.message.startswith(".quotedebuglogs"):
            save_dir = DebugLogger.save_logs()
            params.message = f"logs saved into {save_dir}"
            return HookResult(strategy=HookStrategy.MODIFY, params=params)
        
        if not params.message.startswith(".q"):
            return HookResult()
        
        if not params.replyToMsg:
            params.message = LocalizationManager.get_string("FORGOT_TO_REPLY")
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

        try:
            font_index = self.get_setting("font", 0)
            custom_font_url = self.get_setting("custom_font_url", "")
            FontManager.custom_font_url = custom_font_url
            quote = QuoteManager(params, font_index)
            
            quote.generate_quote()
            
            return HookResult(strategy=HookStrategy.CANCEL)
        except Exception as e:
            params.message = LocalizationManager.get_string("PLUGIN_ERROR")
            DebugLogger.make_log("on_send_message_hook\n" + str(traceback.format_exc()))
            return HookResult(strategy=HookStrategy.MODIFY, params=params)
       
class LocalizationManager:
    language = "en"
    @staticmethod
    def init():
        language = Locale.getDefault().getLanguage()
        LocalizationManager.language = language if language in LocalizationManager._get_supported_languages() else "en"
        
    @staticmethod
    def get_string(string):
        locali = LocalizationManager.strings[LocalizationManager.language][string] 
        return locali if locali is not None else string
    
    @staticmethod
    def _get_supported_languages():
        return LocalizationManager.strings.keys()
    
    strings = {
        "ru": {
            "FORGOT_TO_REPLY": "‚ö†Ô∏è –¢—ã –∑–∞–±—ã–ª —Ä–µ–ø–ª–∞–π–Ω—É—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ!",
            "TLRPC_USERPHOTOS_ERROR": "‚õî –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –ø–æ–ª—É—á–∏—Ç—å –∞–≤—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!",
            "TLRPC_GETFILE_ERROR": "‚õî –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ –∞–≤—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!",
            "PLUGIN_ERROR": "‚õî –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –≤ –∫–æ–¥–µ –ø–ª–∞–≥–∏–Ω–∞",
            "USERPHOTOS_ERROR": "‚õî –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –≤ –∫–æ–¥–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!",
            "GETFILE_ERROR": "‚õî –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –≤ –∫–æ–¥–µ —Å–∫–∞—á–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!",
            "SETTINGS_TITLE": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–ª–∞–≥–∏–Ω–∞",
            "SETTINGS_FONT": "–®—Ä–∏—Ñ—Ç",
            "SETTINGS_CUSTOM_FONT_URL": "–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç (.ttf)",
            "SETTINGS_CUSTOM_FONT_URL_SUB": "–í—Å—Ç–∞–≤—å—Ç–µ –ø—Ä—è–º—É—é —Å—Å—ã–ª–∫—É –Ω–∞ .ttf —Ñ–∞–π–ª. –ü—Ä–∏–º–µ—Ä: https://example.com/font.ttf",
            "SETTINGS_SHOW_IN_REPLY": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å '(–≤ –æ—Ç–≤–µ—Ç ...)' –≤ —Ü–∏—Ç–∞—Ç–µ",
            "SETTINGS_SHOW_IN_REPLY_SUB": "–ü–æ–¥–ø–∏—Å—å '(–≤ –æ—Ç–≤–µ—Ç ...)' –≤ —Ü–∏—Ç–∞—Ç–µ",
            "SETTINGS_CUSTOM_FONT_FAQ": "–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã",
            "ATTACH_TYPE_1": "[—Ñ–æ—Ç–æ]",
            "ATTACH_TYPE_2": "[–≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ]",
            "ATTACH_TYPE_3": "[–≤–∏–¥–µ–æ]", 
            "ATTACH_TYPE_4": "[–≥–µ–æ]", 
            "ATTACH_TYPE_5": "[–∫—Ä—É–∂–æ–∫]", 
            "ATTACH_TYPE_6": "[–∑–∞–≥—Ä—É–∑–∫–∞]", 
            "ATTACH_TYPE_8": "[–≥–∏—Ñ]", 
            "ATTACH_TYPE_9": "[—Ñ–∞–π–ª]", 
            "ATTACH_TYPE_10": "[–¥–∞—Ç–∞]", 
            "ATTACH_TYPE_11": "[—Ñ–æ—Ç–æ]", 
            "ATTACH_TYPE_12": "[–∫–æ–Ω—Ç–∞–∫—Ç]", 
            "ATTACH_TYPE_13": "[—Å—Ç–∏–∫–µ—Ä]", 
            "ATTACH_TYPE_14": "[–º—É–∑—ã–∫–∞]", 
            "ATTACH_TYPE_15": "[–∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å—Ç–∏–∫–µ—Ä]", 
            "ATTACH_TYPE_16": "[–∑–≤–æ–Ω–æ–∫]", 
            "ATTACH_TYPE_17": "[–æ–ø—Ä–æ—Å]", 
            "ATTACH_TYPE_18": "[–ø—Ä–µ–º–∏—É–º]", 
            "ATTACH_TYPE_19": "[—ç–º–æ–¥–∑–∏]", 
            "ATTACH_TYPE_20": "[–ø—Ä–µ–≤—å—é]", 
            "ATTACH_TYPE_21": "[–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Ñ–æ—Ç–æ]", 
            "ATTACH_TYPE_22": "[–∑–∞–¥–Ω–∏–π —Ñ–æ–Ω]", 
            "ATTACH_TYPE_23": "[–∏—Å—Ç–æ—Ä–∏—è]", 
            "ATTACH_TYPE_24": "[—É–ø–æ–º–∏–Ω–∞–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏–∏]", 
            "ATTACH_TYPE_25": "[–ø—Ä–µ–º–∏—É–º]", 
            "ATTACH_TYPE_26": "[—Ä–∞–∑–¥–∞—á–∞]", 
            "ATTACH_TYPE_27": "[–∑–∞—à—ë–ª –≤ –∫–∞–Ω–∞–ª]", 
            "ATTACH_TYPE_28": "[—Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–∑–¥–∞—á–∏]", 
            "ATTACH_TYPE_29": "[–ø–ª–∞—Ç–Ω–æ–µ –≤–ª–æ–∂–µ–Ω–∏–µ]", 
            "ATTACH_TYPE_30": "[–∑–≤—ë–∑–¥—ã]",
            "IN_REPLY": "[–≤ –æ—Ç–≤–µ—Ç {0}]"
        },
        "en": {
            "FORGOT_TO_REPLY": "‚ö†Ô∏è you forgot to reply to message!",
            "TLRPC_GETCHANNELS_ERROR": "‚õî an error occurred while trying to fetch the chat data!",
            "TLRPC_GETCHATPHOTO_ERROR": "‚õî an error occurred while trying to fetch the chat thumbnail!",
            "TLRPC_USERPHOTOS_ERROR": "‚õî an error occurred while trying to fetch the user's avatar!",
            "TLRPC_GETFILE_ERROR": "‚õî an error occurred while downloading avatar!",
            "PLUGIN_ERROR": "‚õî an error occurred in plugin code!",
            "SETTINGS_TITLE": "Plugin settings",
            "SETTINGS_FONT": "Font",
            "SETTINGS_CUSTOM_FONT_URL": "Custom font link (.ttf)",
            "SETTINGS_CUSTOM_FONT_URL_SUB": "Paste a direct link to a .ttf file. Example: https://example.com/font.ttf",
            "SETTINGS_SHOW_IN_REPLY": "Show '(in reply ...)' in quote",
            "SETTINGS_SHOW_IN_REPLY_SUB": "Show '(in reply ...)' in quote",
            "SETTINGS_CUSTOM_FONT_FAQ": "How to use custom fonts",
            "ATTACH_TYPE_1": "[photo]",
            "ATTACH_TYPE_2": "[voice message]",
            "ATTACH_TYPE_3": "[video]",
            "ATTACH_TYPE_4": "[geo]",
            "ATTACH_TYPE_5": "[round message]",
            "ATTACH_TYPE_6": "[upload]",
            "ATTACH_TYPE_8": "[gif]",
            "ATTACH_TYPE_9": "[file]",
            "ATTACH_TYPE_10": "[date]",
            "ATTACH_TYPE_11": "[photo]",
            "ATTACH_TYPE_12": "[contact]",
            "ATTACH_TYPE_13": "[sticker]",
            "ATTACH_TYPE_14": "[music]",
            "ATTACH_TYPE_15": "[animated sticker]",
            "ATTACH_TYPE_16": "[call]",
            "ATTACH_TYPE_17": "[poll]",
            "ATTACH_TYPE_18": "[premium]",
            "ATTACH_TYPE_19": "[emoji]",
            "ATTACH_TYPE_20": "[preview]",
            "ATTACH_TYPE_21": "[photo suggestion]",
            "ATTACH_TYPE_22": "[background]",
            "ATTACH_TYPE_23": "[story]",
            "ATTACH_TYPE_24": "[story mention]",
            "ATTACH_TYPE_25": "[premium]",
            "ATTACH_TYPE_26": "[giveaway]",
            "ATTACH_TYPE_27": "[joined channel]",
            "ATTACH_TYPE_28": "[giveaway result]",
            "ATTACH_TYPE_29": "[paid attachment]",
            "ATTACH_TYPE_30": "[stars]",
            "IN_REPLY": "[in reply to {0}]"
        }
    }
    
class Filesystem:
    @staticmethod
    def write_file(file_path, content):
        file_full_path = "/".join(file_path.split("/")[:-1])
        if not os.path.exists(file_full_path):
            os.makedirs(file_full_path)
            
        with open(file_path, 'wb') as file:
            file.write(content)
            
    @staticmethod
    def get_absolute_path(dir, file_name):
        return File(dir, file_name).getAbsolutePath()
            
    @staticmethod
    def get_temp_dir():
        try:
            fixed_dir = ApplicationLoader.getFilesDirFixed()
            
            if not fixed_dir:
                return None
            
            temp_dir = File(fixed_dir, "tailed_quotes").getAbsolutePath()
            
            if not os.path.exists(temp_dir):
                os.makedirs(temp_dir)
                
            return temp_dir
            
        except Exception as e:
            DebugLogger.make_log("get_temp_dir\n" + str(traceback.format_exc()))
            return None
        
class TelegramUtils:
    @staticmethod
    def get_user(user_id):
        return get_messages_controller().getUser(user_id)
    
    @staticmethod 
    def get_channel(channel_id, callback):
        req = TLRPC.TL_channels_getChannels()
        input_channel = get_messages_controller().getInputChannel(channel_id)
        req.id.add(input_channel)
        
        cb = RequestCallback(callback)
        
        send_request(req, cb)
        
    @staticmethod
    def get_chat(chat_id, callback):
        req = TLRPC.TL_messages_getChats()
        input_chat = get_messages_controller().getInputChat(chat_id)
        req.id.add(input_chat)
        
        cb = RequestCallback(callback)
        
        send_request(req, cb)
        
    @staticmethod
    def create_input_location(photo, size):
        location = TLRPC.TL_inputPhotoFileLocation()
        
        location.id = photo.id
        location.access_hash = photo.access_hash
        location.file_reference = photo.file_reference
        location.thumb_size = size.type

        return location
    
    @staticmethod
    def create_peer_input_location(chat, peer):
        location = TLRPC.TL_inputPeerPhotoFileLocation()
        location.big = True
        location.peer = get_messages_controller().getInputPeer(peer)
        location.photo_id = chat.photo.photo_id
        
        return location
        
    @staticmethod
    def get_chat_thumbnail(chat, peer, callback):
        req = TLRPC.TL_upload_getFile()
        cb = RequestCallback(callback)
        
        location = TelegramUtils.create_peer_input_location(chat, peer)
        
        req.location = location
        req.offset = 0
        req.limit = 1024 * 1024
        
        send_request(req, cb)
        
    
class ReplyerID:
    def __init__(self, peer):
        if peer is None:
            self.channel_id = 0
            self.chat_id = 0
            self.user_id = -1
            self.peer = None
            return
        
        self.channel_id = peer.channel_id
        self.chat_id = peer.chat_id
        self.user_id = peer.user_id
        
        self.peer = peer
        
    def get_replyer_type(self):
        if self.channel_id is not 0:
            return 2
        elif self.chat_id is not 0:
            return 1
        else:
            return 0
        
    def get_id(self):
        if self.channel_id is not 0:
            return self.channel_id
        elif self.chat_id is not 0:
            return self.chat_id
        else:
            return self.user_id
        
class Replyer:
    def __init__(self):
        self.name = ""

class QuoteManager:
    def __init__(self, params, font_index):
        self.params = params
        self.user = None
        self.replyer_id = None
        self.replyer = Replyer()
        self.font_index = font_index
        
    def generate_quote(self):
        try:
            self.replyer_id = self.init_replyer_id()
            
            replyer_type = self.replyer_id.get_replyer_type()
            
            if replyer_type is 0:
                if self.replyer_id.user_id is -1:
                    return self.create_quote_without_input()
                user = TelegramUtils.get_user(self.replyer_id.user_id)

                self.user = user
                
                self.replyer.name = self.get_full_replyer_name()
                
                req = TLRPC.TL_photos_getUserPhotos()

                cb = RequestCallback(self.handle_user_photos_callback)

                input_user = get_messages_controller().getInputUser(user.id)

                req.user_id = input_user
                req.limit = 1
                
                send_request(req, cb)
            elif replyer_type is 1:
                TelegramUtils.get_chat(self.replyer_id.chat_id, self.handle_get_channels_callback)
            elif replyer_type is 2:
                TelegramUtils.get_channel(self.replyer_id.channel_id, self.handle_get_channels_callback)
        except Exception as e:
            DebugLogger.make_log("generate_quote\n" + str(traceback.format_exc()))
            
    def handle_get_channels_callback(self, response, error):
        if error:
            DebugLogger.make_log(DebugLogger.format_tl_error(error))
            self._send_message(LocalizationManager.get_string("TLRPC_GETCHANNELS_ERROR"))
            return
        
        if not error and response:
            if response.chats is None or response.chats.size() == 0:
                return None
            
            chat = response.chats.get(0)
            
            self.replyer.name = chat.title
            
            if chat.photo.photo_id is 0:
                return self.create_quote_without_input()
            
            TelegramUtils.get_chat_thumbnail(chat, self.replyer_id.peer, self.handle_get_file_callback)
            
    def get_quote_message(self):
        raw_message = self.get_replyer()
        message = raw_message.message if isinstance(raw_message.message, str) else ""
        
        try:
            message_type = self.params.replyToMsg.type
            
            if message_type is not None and message_type in range(1, 30):
                message = LocalizationManager.get_string("ATTACH_TYPE_" + str(message_type)) + "\n" + message
            return message
        except Exception as e:
            DebugLogger.make_log("get_quote_message\n" + str(traceback.format_exc()))
            
            self._send_message(LocalizationManager.get_string("PLUGIN_ERROR"))
        
    def init_replyer_id(self):
        replyer = self.get_replyer()
        replyer_peer = replyer.from_id
        
        if replyer.fwd_from is not None:
            replyer_peer = replyer.fwd_from.from_id
            
            if replyer.fwd_from.from_id is None:
                self.replyer.name = replyer.fwd_from.saved_from_name
        
        return ReplyerID(replyer_peer)
            
    def get_full_replyer_name(self):
        first_name = self.user.first_name
        first_name = first_name if first_name is not None else ""
        
        last_name = self.user.last_name
        last_name = last_name if last_name is not None else ""
        
        return " ".join([first_name, last_name]).strip()
    
    def get_full_replyer_name_from_userobject(self, user):
        first_name = user.first_name
        first_name = first_name if first_name is not None else ""
        
        last_name = user.last_name
        last_name = last_name if last_name is not None else ""
        
        return " ".join([first_name, last_name]).strip()
            
    def get_replyer(self):
        return self.params.replyToMsg.messageOwner
            
    def get_replyer_id(self):
        return self.replyer_id.get_id()
    
    def _send_message(self, message):
        params = {
            "message": message,
            "peer": self.params.peer
        }
        
        send_message(params)
        
    def handle_user_photos_callback(self, response, error):
        if error:
            DebugLogger.make_log(DebugLogger.format_tl_error(error))
            self._send_message(LocalizationManager.get_string("TLRPC_USERPHOTOS_ERROR"))
            return
        
        if not error and response:
            try:
                if response.photos is None or response.photos.size() == 0:
                    return self.create_quote_without_input()
                photo = response.photos.get(0)
                size = photo.sizes.get(0)
                
                req = TLRPC.TL_upload_getFile()
                cb = RequestCallback(self.handle_get_file_callback)
                
                input_file = TelegramUtils.create_input_location(photo, size)
                
                req.location = input_file
                req.offset = 0
                req.limit = 1024 * 1024
                
                send_request(req, cb)
            except Exception as e:
                try:
                    self.create_quote_without_input()
                except Exception as ee:
                    DebugLogger.make_log("handle_user_photos_callback.user_photo_empty\n" + str(traceback.format_exc()))
                    self._send_message(LocalizationManager.get_string("USERPHOTOS_ERROR"))
                    return
                
                DebugLogger.make_log("handle_user_photos_callback\n" + str(traceback.format_exc()))
                self._send_message(LocalizationManager.get_string("USERPHOTOS_ERROR"))
    
    def create_quote_without_input(self):
        try:
            tmp_file = f"tmp_{self.get_replyer_id()}.jpg"
                        
            temp_dir = Filesystem.get_temp_dir()
                        
            file_path = Filesystem.get_absolute_path(
                temp_dir, tmp_file
            )
                        
            full_replyer_name = self.replyer.name
            message = self.get_quote_message()
                        
            self.create_and_send_image(
                output_path=file_path,
                author=full_replyer_name,
                quote=message
            )
        except Exception as e:
            DebugLogger.make_log("create_quote_without_input\n" + str(traceback.format_exc()))
                
    def handle_get_file_callback(self, response, error):
        if error:
            DebugLogger.make_log(DebugLogger.format_tl_error(error))
            self._send_message(LocalizationManager.get_string("TLRPC_GETFILE_ERROR"))
            return
            
        if not error and response:
            try:
                buffer = response.bytes.buffer
                buffer.rewind()
                length = buffer.remaining()
                
                py_bytes = bytes([buffer.get() & 0xFF for _ in range(length)])
                
                tmp_file = f"img_{self.get_replyer_id()}.jpg"
                
                temp_dir = Filesystem.get_temp_dir()
                
                file_path = Filesystem.get_absolute_path(
                    temp_dir, tmp_file
                )
                
                Filesystem.write_file(file_path, py_bytes)
                
                full_replyer_name = self.replyer.name
                message = self.get_quote_message()
                
                self.create_and_send_image(
                    image_path=file_path,
                    output_path=file_path,
                    author=full_replyer_name,
                    quote=message
                )
            except Exception as e:
                DebugLogger.make_log("handle_get_file_callback\n" + str(traceback.format_exc()))
                self._send_message(LocalizationManager.get_string("GETFILE_ERROR"))
                
    def create_and_send_image(
        self, 
        bg_color=(0, 0, 0),
        image_path=None,
        quote="",
        author="",
        output_path="quote_dynamic_stretch.png",
        img_width=300,
        canvas_width=900,
        min_canvas_height=400,
        padding=30
    ):
        from PIL import ImageFilter
        font_path = FontManager.get(self.font_index).get_path()
        quote_font = ImageFont.truetype(font_path, 36)
        author_font = ImageFont.truetype(font_path, 28)

        dummy_img = Image.new("RGB", (canvas_width, min_canvas_height), (0,0,0))
        dummy_draw = ImageDraw.Draw(dummy_img)
        max_text_width = canvas_width - img_width - padding * 3
        wrapped_quote = "\n".join(
            self._wrap_text(dummy_draw, line, quote_font, max_text_width)
            for line in quote.split("\n")
        )
        author_text = f"‚Äî {author}"
        quote_size = dummy_draw.multiline_textsize(wrapped_quote, font=quote_font)
        author_size = dummy_draw.textsize(author_text, font=author_font)
        total_text_height = quote_size[1] + author_size[1] + 15
        canvas_height = max(min_canvas_height, total_text_height + padding * 2)

        
        if image_path:
            orig_img = Image.open(image_path).convert("RGBA")
            bg = orig_img.resize((canvas_width, canvas_height)).filter(ImageFilter.GaussianBlur(24))
            overlay = Image.new("RGBA", (canvas_width, canvas_height), (0, 0, 0, 160))
            bg = Image.alpha_composite(bg, overlay)
            canvas = bg.convert("RGB")
        else:
            rnd_color = tuple(random.randint(100, 255) for _ in range(3))
            canvas = Image.new("RGB", (canvas_width, canvas_height), rnd_color)

        draw = ImageDraw.Draw(canvas)

        img = None
        img_height = img_width
        if image_path:
            orig_img = Image.open(image_path).convert("RGBA")
            orig_w, orig_h = orig_img.size
            scale_factor = img_width / orig_w
            img_height = int(orig_h * scale_factor)
            img = orig_img.resize((img_width, img_height))
            mask = Image.new("L", (img_width, img_height), 0)
            mask_draw = ImageDraw.Draw(mask)
            mask_draw.ellipse((0, 0, img_width, img_height), fill=255)
            img.putalpha(mask)
        else:
            img = Image.new("RGBA", (img_width, img_width), (0, 0, 0, 0))
            circle_draw = ImageDraw.Draw(img)
            rnd_color = tuple(random.randint(100, 255) for _ in range(3))
            circle_draw.ellipse((0, 0, img_width, img_width), fill=rnd_color)
            letter_font = ImageFont.truetype(font_path, int(img_width * 0.4))
            letter = author.strip()[0].upper() if author.strip() else "?"
            w, h = circle_draw.textsize(letter, font=letter_font)
            circle_draw.text(
                ((img_width - w) // 2, (img_width - h) // 2),
                letter,
                font=letter_font,
                fill=(255, 255, 255)
            )
            img_height = img_width

        img_pos = (padding, (canvas_height - img_height) // 2)
        canvas.paste(img, img_pos, img)

        text_x = img_pos[0] + img_width + padding
        text_y = (canvas_height - total_text_height) // 2
        draw.multiline_text((text_x, text_y), wrapped_quote, font=quote_font, fill=(255, 255, 255))
        draw.text((text_x, text_y + quote_size[1] + 10), author_text, font=author_font, fill=(180, 180, 180))

        canvas.save(output_path)
        self._send_quote(output_path)
        
    def _send_quote(self, output_path):
        send_helper = get_send_messages_helper()
        photo = send_helper.generatePhotoSizes(output_path, None)
        
        params = {
            "message": None,
            "peer": self.params.peer
        }
        
        params["photo"] = photo
        params["path"] = output_path
        
        params["replyToMsg"] = self.params.replyToMsg
        params["replyToTopMsg"] = self.params.replyToTopMsg
        
        send_message(params)
        
    def _wrap_text(self, draw, text, font, max_width):
        lines = []
        words = text.split()
        while words:
            line_words = []
            while words:
                line_words.append(words.pop(0))
                w, _ = draw.textsize(" ".join(line_words + words[:1]), font=font)
                if w > max_width:
                    break
            lines.append(" ".join(line_words))
        return "\n".join(lines)

class FontManager:
    fonts = []
    custom_font_url = ""
    custom_font_path = None
    @staticmethod
    def init():
        FontManager.fonts = [
            Font("Hack", "https://github.com/source-foundry/Hack/raw/refs/heads/master/build/ttf/Hack-Bold.ttf"),
            Font("Monocraft", "https://github.com/IdreesInc/Monocraft/raw/refs/heads/main/dist/Monocraft.ttf"),
            Font("Times New Roman", "https://github.com/misuchiru03/font-times-new-roman/raw/refs/heads/master/Times%20New%20Roman.ttf"),
            Font("–ö–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç", None)
        ]
        threading.Thread(target=FontManager._download_fonts, daemon=True).start()
                
    @staticmethod
    def _download_fonts():
        for font in FontManager.fonts:
            if font.download_uri and not font.exists():
                font.download()
    @staticmethod
    def get(index):
        if index == 3:  
            url = FontManager.custom_font_url
            if not url or not url.strip():
                return FontManager.fonts[0] # fallback
            temp_dir = Filesystem.get_temp_dir()
            font_path = Filesystem.get_absolute_path(temp_dir, "custom_font.ttf")
            if not os.path.exists(font_path):
                try:
                    response = requests.get(url, timeout=10)
                    with open(font_path, 'wb') as f:
                        f.write(response.content)
                except Exception as e:
                    DebugLogger.make_log(f"custom font download failed: {e}")
                    return FontManager.fonts[0]
            FontManager.custom_font_path = font_path
            return Font("–ö–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç", None, custom_path=font_path)
        return FontManager.fonts[index]
    
    @staticmethod
    def get_fonts_names():
        fonts = []
        for font in FontManager.fonts:
            fonts.append(font.name)
        return fonts

class Font:
    def __init__(self, name, download_uri, custom_path=None):
        self.name = name
        self.download_uri = download_uri
        self.custom_path = custom_path
        
    def get_path(self):
        if self.custom_path:
            return self.custom_path
        temp_dir = Filesystem.get_temp_dir()
        file_name = self.name + "." + self.get_type()
        return Filesystem.get_absolute_path(temp_dir, file_name)
    
    def get_type(self):
        if self.download_uri:
            return self.download_uri.split(".")[-1]
        return "ttf"
    
    def exists(self):
        return os.path.exists(self.get_path())
        
    def download(self):
        if self.exists() or not self.download_uri:
            return
        font_path = self.get_path()
        response = requests.get(self.download_uri)
        with open(font_path, 'wb') as file:
            file.write(response.content)