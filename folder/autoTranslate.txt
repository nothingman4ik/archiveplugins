import requests 
from ui .settings import Header ,Switch ,Selector ,Text ,Divider ,Input 

# List of supported DeepL languages (as of June 2024)
DEEPL_LANG_CODES = [
    "bg",  # Bulgarian
    "cs",  # Czech
    "da",  # Danish
    "de",  # German
    "el",  # Greek
    "en",  # English
    "es",  # Spanish
    "et",  # Estonian
    "fi",  # Finnish
    "fr",  # French
    "hu",  # Hungarian
    "id",  # Indonesian
    "it",  # Italian
    "ja",  # Japanese
    "ko",  # Korean
    "lt",  # Lithuanian
    "lv",  # Latvian
    "nb",  # Norwegian (Bokmål)
    "nl",  # Dutch
    "pl",  # Polish
    "pt",  # Portuguese
    "ro",  # Romanian
    "ru",  # Russian
    "sk",  # Slovak
    "sl",  # Slovenian
    "sv",  # Swedish
    "tr",  # Turkish
    "uk",  # Ukrainian
    "zh",  # Chinese (simplified)
]
DEEPL_LANG_NAMES = [
    "Bulgarian", "Czech", "Danish", "German", "Greek", "English", "Spanish", "Estonian", "Finnish", "French",
    "Hungarian", "Indonesian", "Italian", "Japanese", "Korean", "Lithuanian", "Latvian", "Norwegian (Bokmål)",
    "Dutch", "Polish", "Portuguese", "Romanian", "Russian", "Slovak", "Slovenian", "Swedish", "Turkish",
    "Ukrainian", "Chinese (simplified)"
]

from base_plugin import BasePlugin ,HookResult ,HookStrategy 
from java .util import Locale 
import time 


from org .telegram .messenger import AndroidUtilities ,ApplicationLoader 
from org .telegram .ui .Components import BulletinFactory ,RLottieDrawable 
from typing import Optional ,Any ,List 
from android_utils import log ,run_on_ui_thread 
from base_plugin import MenuItemData ,MenuItemType 
from ui .bulletin import BulletinHelper 
from client_utils import run_on_queue ,send_message ,get_last_fragment ,get_messages_controller ,send_request ,get_file_loader 
from com .exteragram .messenger .utils import ChatUtils 
from org .telegram .tgnet import TLRPC 
from ui .alert import AlertDialogBuilder 
from org .telegram .ui .ActionBar import AlertDialog 
import re 
import random 
import html 
from android .content import ClipData ,Context 
from org .telegram .messenger import R as R_tg 
from org .telegram .messenger import ApplicationLoader 
from android .os import Build 
import json 


from com .exteragram .messenger .plugins import PluginsController 
from com .exteragram .messenger .plugins .ui import PluginSettingsActivity 

__id__ ="autoTranslate"
__name__ ="Auto Translate"
__description__ ="Automatically translates outgoing messages using Google Translate. Toggle in settings."
__author__ ="@luvztroy"
__min_version__ ="11.12.0"
__version__ ="2.1.2"
__icon__ ="luvztroyIcons/0"
__category__ ="utility"
__priority__ =100 



TRANSLATE_API_URL ="https://translate.googleapis.com/translate_a/single"


_http =requests .Session ()


GEMINI_API_URL_TEMPLATE ="https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent"


GEMINI_MODELS =[
"gemini-2.0-flash",
"gemini-2.5-flash",
]


PHOENIX_API_URL ="https://api.phoenixbot.lol/v1/chat/completions"
PHOENIX_MODELS =[
"chatgpt-4o-latest",
"claude-opus-4",
"claude-sonnet-4",
"deepseek-v3",
"deepseek-r1",
"deepseek-v3-0324",
"gemini-2.5-flash-preview-05-20",
"gemini-2.5-flash-preview-05-20-thinking",
"gemini-2.5-pro-preview-06-05",
"gpt-4.1",
"gpt-4.5-preview",
"gpt-4o",
"gpt-4o-search-preview",
"o3",
"o3-mini",
"o4-mini",
"sonar-deep-research"
]


AI_ROLE_NAMES = [
    "None",
    "Assistant",
    "Translator",
    "Teacher",
    "Developer",
    "Comedian",
    "Motivational Coach",
    "Sarcastic",
    "Empath",
    "Philosopher",
    "Tech Guru",
    "Storyteller",
    "Poet",
    "Strict Teacher",
    "Cheerleader",
    "Old Wise Sage",
    "Minimalist",
    "Gamer",
    "AI Researcher",
    "Mystic",
    "Pirate",
    "Shakespearean",
    "Motivational Drill Sergeant",
    "Custom"
]

AI_BASE_PROMPT =(
"Please provide a concise and helpful response to the following message. "
"If the message is a question, answer it directly. "
"If it's a statement, respond appropriately. Keep responses brief and to the point.")

# Persona-specific prompts for AI personas
AI_PERSONA_PROMPTS = {
    "Comedian": (
        "You are a witty comedian. Respond to the user with humor, clever jokes, and lighthearted banter. Always try to make the user laugh, but keep it appropriate and relevant to their message."
    ),
    "Motivational Coach": (
        "You are a motivational coach. Respond with encouragement, positivity, and uplifting advice. Inspire the user to take action, overcome challenges, and feel empowered."
    ),
    "Sarcastic": (
        "You are extremely sarcastic. Respond with dry, biting wit and irony. Make it clear you are being sarcastic, but do not be mean-spirited."
    ),
    "Empath": (
        "You are an empathetic listener. Respond with deep understanding, validation, and emotional support. Make the user feel truly heard and cared for."
    ),
    "Philosopher": (
        "You are a philosopher. Respond with thoughtful, reflective, and sometimes abstract answers. Ponder deeper meanings and encourage the user to think critically."
    ),
    "Tech Guru": (
        "You are a tech guru. Explain things with technical depth, provide troubleshooting, and use tech jargon. Offer practical solutions and insights on technology."
    ),
    "Storyteller": (
        "You are a storyteller. Respond in the form of short stories, anecdotes, or parables. Make the conversation engaging and memorable."
    ),
    "Poet": (
        "You are a poet. Respond in verse, rhyme, or poetic prose. Use vivid imagery and emotion in your answers."
    ),
    "Strict Teacher": (
        "You are a strict teacher. Give direct, no-nonsense, and sometimes tough-love responses. Focus on discipline, clarity, and improvement."
    ),
    "Cheerleader": (
        "You are a cheerleader. Respond with over-the-top encouragement and excitement, using lots of exclamation marks and energy! Always root for the user's success!"
    ),
    "Old Wise Sage": (
        "You are an old wise sage. Use proverbs, ancient wisdom, and 'back in my day' style. Offer timeless advice and perspective."
    ),
    "Minimalist": (
        "You are a minimalist. Respond with extreme brevity, giving the shortest possible answers. No extra words or explanations."
    ),
    "Gamer": (
        "You are a gamer. Use gaming slang, metaphors, and humor. Relate everything to gaming culture and experiences."
    ),
    "AI Researcher": (
        "You are an AI researcher. Be very factual, cite studies or research if possible, and avoid speculation. Use precise, academic language."
    ),
    "Mystic": (
        "You are a mystic. Speak in riddles, metaphors, and mystical language. Encourage the user to find hidden meanings."
    ),
    "Pirate": (
        "You are a pirate. Respond in pirate-speak with plenty of 'Arrr matey!' and nautical flair. Make the user feel like they're on the high seas."
    ),
    "Shakespearean": (
        "You are Shakespearean. Respond in Early Modern English, as if from a Shakespeare play. Use poetic, dramatic language and references."
    ),
    "Motivational Drill Sergeant": (
        "You are a motivational drill sergeant. Be tough, loud, but always push the user to succeed. Use military-style encouragement and discipline."
    ),
}


class LocalizationManager :
    def __init__ (self ):
        self .language =Locale .getDefault ().getLanguage ()
        self .language =self .language if self .language in self ._get_supported_languages ()else "en"

    def get_string (self, key):
        return self.strings[self.language].get(key, key)
        
    # Alias for get_string to maintain compatibility
    def get(self, key):
        return self.get_string(key)

    def _get_supported_languages (self ):
        return self .strings .keys ()

    strings ={
    "be":{
        "SETTINGS_TITLE": "Налады аўтаматычнага перакладу",
        "PER_CHAT_LANG_REMOVED": "Мова для гэтага чата скінута.",
        "NO_PER_CHAT_LANG": "Для гэтага чата не ўсталявана мова па змаўчанні.",
        "PER_CHAT_LANG_SET": "Мова для гэтага чата ўсталявана: {0}",
        "INVALID_LANG_CODE": "Няправільны код мовы.",
        "SWITCHED_TO_GOOGLE": "Пераключана на Google Translate",
        "SWITCHED_TO_YANDEX": "Пераключана на Yandex Translate",
        "SWITCHED_TO_DEEPL": "Пераключана на DeepL Translate",
        "STATUS_ALREADY_ENABLED": "Аўтаматычны пераклад ужо ўключаны ў гэтым чаце",
        "STATUS_ENABLED": "Аўтаматычны пераклад уключаны ў гэтым чаце",
        "STATUS_ALREADY_DISABLED": "Аўтаматычны пераклад ужо адключаны ў гэтым чаце",
        "STATUS_DISABLED": "Аўтаматычны пераклад адключаны ў гэтым чаце",
        "STATUS_DISABLED_EXCLUDED": "Аўтаматычны пераклад адключаны ў гэтым чаце (выключаны па змаўчанні)",
        "BULLETIN_MSGS": [
            "Хочаце аўтаматычна перакладаць свае паведамленні? Увядзіце !on, каб уключыць пераклад у гэтым чаце!",
            "Тут даступны аўтаматычны пераклад! Выкарыстоўвайце !on, каб пачаць перакладаць паведамленні.",
            "Хуткая парада: увядзіце !on, каб уключыць аўтаматычны пераклад у гэтым чаце!",
            "Вашыя паведамленні могуць быць аўтаматычна перакладзеныя! Проста скажыце !on, каб пачаць.",
            "Функцыя перакладу гатовая! Увядзіце !on, каб уключыць яе для гэтага чата.",
            "Хочаце, каб вашы паведамленні перакладаліся аўтаматычна? Увядзіце !on, каб уключыць!",
            "Аўтаматычны пераклад чакае вас! Увядзіце !on, каб актываваць яго ў гэтым чаце.",
            "Гатовыя да перакладу? Увядзіце !on, каб уключыць аўтаматычны пераклад тут!",
            "Даступная магія перакладу! Выкарыстоўвайце !on, каб уключыць яе для гэтага чата.",
            "Вашыя паведамленні могуць атрымаць пераклад! Увядзіце !on, каб уключыць.",
            "Чат гатовы да перакладу! Увядзіце !on, каб пачаць.",
            "Аўтаматычны пераклад гатовы да выкарыстання! Хочаце ўбачыць яго ў дзеянні? Скажыце !on.",
            "Мы можам перакладаць паведамленні ў фонавым рэжыме. Скажыце !on, каб дадаць перцу.",
            "Рэжым перакладу выключаны. Хочаце магіі? Увядзіце !on.",
            "У гэтым чаце ёсць убудаваная магія перакладу. Хочаце актываваць яе? Проста скажыце !on.",
            "Словы могуць хутка змяніцца. Увядзіце !on, каб надаць ім бляску.",
            "Вашыя паведамленні могуць быць аўтаматычна перакладзены для зручнага спічвання. Увядзіце !on, каб палепшыць камунікацыю.",
            "Зараз пераклады выключаны. Выкарыстоўвайце !on, каб уключыць іх.",
            "Аўтаматычны пераклад у рэжыме чакання. Скажыце !on, каб ажывіць яго.",
            "Мы можам хутка змяніць мову вашых слоў. Хочаце паспрабаваць? Увядзіце !on.",
            "Паведамленні можна перакладаць на ляту. Ці цікава? !on — ваш выбар!"
        ],
        "EXPORT_DIALOG_TITLE": "Экспарт наладаў",
        "EXPORT_DIALOG_DESC": "Выберыце, што экспартаваць:",
        "EXPORT_OPTION_FULL": "📋 Поўны экспарт - Усе налады, аналітыка і адладачная інфармацыя",
        "EXPORT_OPTION_SETTINGS": "⚙️ Толькі налады - Вашы бягучыя налады",
        "EXPORT_OPTION_ANALYTICS": "📊 Толькі аналітыка - Статыстыка перакладаў і кэш-дадзеныя",
        "EXPORT_OPTION_DEBUG": "🐛 Адладачная інфармацыя - Тэхнічныя дэталі для дыягностыкі",
        "EXPORT_CLIPBOARD_NOTE": "Экспартаваныя дадзеныя будуць скапіяваны ў буфер абмену.",
        "BUTTON_FULL_EXPORT": "Поўны экспарт",
        "BUTTON_SETTINGS": "Налады",
        "BUTTON_CANCEL": "Скасаваць",
        "BUTTON_RESET_DATA": "Скінуць дадзеныя",
        "BUTTON_CLOSE": "Зачыніць",
        "TRANSLATE_BY_DEFAULT": "Перакладаць па змаўчанні",
        "TRANSLATE_BY_DEFAULT_SUB": "Уключыць пераклад ва ўсіх чатах па змаўчанні. Паведамленне-падказка не будзе паказвацца.",
        "ENABLE_TRANSLATOR": "Уключыць аўтаматычны пераклад",
        "ENABLE_TRANSLATOR_SUB": "Уключыць аўтаматычны пераклад глабальна. Выкарыстоўвайце !on у чатах для ўключэння перакладу.",
        "TARGET_LANGUAGE": "Мова перакладу",
        "BYPASS_COMMANDS": "Абыходзіць каманды",
        "BYPASS_COMMANDS_SUB": "Прапускаць пераклад паведамленняў, якія пачынаюцца з '!'",
        "TRANSLATION_ERROR": "Памылка перакладу! Паведамленне не адпраўлена.",
        "GRAMMAR_CHECK": "Праверка граматыкі",
        "GRAMMAR_CHECK_SUB": "Правяраць граматыку перакладзенага тэксту з дапамогай ШІ",
        "MEME_MODE": "Рэжым мемаў",
        "MEME_MODE_SUB": "Перакладаць тэкст у стылі мемаў (толькі англійская)",
        "TRANSLATION_SETTINGS": "Налады перакладу",
        "PROVIDER": "Правайдэр",
        "DEEPL_API_KEY": "Ключ DeepL API",
        "DEEPL_API_KEY_SUB": "Увядзіце ваш ключ DeepL API",
        "FORMALITY": "Фармальнасць",
        "FORMALITY_DEFAULT": "Па змаўчанні",
        "FORMALITY_FORMAL": "Фармальна",
        "FORMALITY_CASUAL": "Нефармальна",
        "AI_CHAT_SETTINGS": "Налады ШІ чата",
        "ENABLE_AI_CHAT": "Уключыць ШІ чат",
        "ENABLE_AI_CHAT_SUB": "Дазволіць выкарыстанне каманды !ai для размовы з ШІ",
        "AI_PROVIDER": "Правайдэр ШІ",
        "AI_PERSONA": "Асоба ШІ",
        "CUSTOM_PERSONA_PROMPT": "Уласны загад для асобы",
        "CUSTOM_PERSONA_PROMPT_SUB": "Увядзіце ўласны загад для асобы ШІ.",
        "GEMINI_API_KEY": "Ключ Gemini API",
        "GEMINI_API_KEY_SUB": "Увядзіце ваш ключ Gemini API",
        "GEMINI_MODEL": "Мадэль Gemini",
        "PHOENIX_API_KEY": "Ключ Phoenix API",
        "PHOENIX_MODEL": "Мадэль Phoenix",
        "ADVANCED_SETTINGS": "Дадатковыя налады",
        "ADVANCED_SETTINGS_SUB": "Уключыць дадатковыя кантролі, напрыклад, спіс выключаных моў.",
        "EXCLUDED_LANGUAGES": "Выключаныя мовы",
        "EXCLUDED_LANGUAGES_SUB": "Выберыце мовы, якія не будуць перакладацца.",
        "ADD_EXCLUDED_LANGUAGE": "Дадаць мову",
        "REMOVE": "Выдаліць",
        "NO_LANGUAGES_EXCLUDED": "Няма выключаных моў",
        "EXCLUDE_LANGUAGE_TITLE": "Выключыць мову",
        "EXCLUDE_LANGUAGE_HINT": "Выберыце мову для выключэння з перакладу.",
        "DRY_RUN_MODE": "Тэставы рэжым",
        "DRY_RUN_MODE_SUB": "Паказваць пераклад у апавяшчэнні, не адпраўляць.",
        "ALLOW_FIRST_MESSAGE": "Дазволіць першае паведамленне",
        "ALLOW_FIRST_MESSAGE_SUB": "Адпраўляць першае паведамленне без перакладу",
        "TRANSLATION_SETTINGS": "Налады перакладу",
        "AI_PROCESSING": "AI & Апрацоўка",
        "ANALYTICS": "Аналітыка",
        "SKIP_REGEX_LIST": "Спіс Regex для прапушкання",
        "SKIP_REGEX_LIST_SUB": "Рэгулярныя выразы праз коску; паведамленні, якія супадаюць, не будуць перакладацца.",
        "ANALYTICS_MONITORING": "Аналітыка і маніторынг",
        "ENABLE_ANALYTICS": "Уключыць аналітыку перакладаў",
        "ENABLE_ANALYTICS_SUB": "Сачыць за статыстыкай перакладаў, паспяховасцю і шаблонамі выкарыстання.",
        "VIEW_ANALYTICS": "Праглед аналітыкі",
        "ABOUT": "Пра праграму",
        "HELP_USAGE": "Дапамога / Выкарыстанне",
        "CHANGELOG": "Спіс зменаў",
        "SELECT_LANGUAGES_TO_BYPASS_TRANSLATION": "Выключаныя мовы",
        "SELECT_LANGUAGES_TO_BYPASS_TRANSLATION_SUB": "Паведамленні на гэтых мовах не будуць перакладацца.",
        "THANK_YOU": "Дзякуй за выкарыстанне Auto Translate! Зваротная сувязь?\nДалучайцеся: @luvztroyPlugins",
        "HELP_DIALOG_TITLE": "Дапамога па Auto Translate",
        "CHANGELOG_DIALOG_TITLE": "Спіс зменаў Auto Translate",
        "CHANGELOG_DIALOG_TEXT": "[2.1.0] - 2025-07-05\n\n• Дададзены руская і беларуская лакалізацыя\n• Плагін цяпер захоўвае налады перакладу для кожнага чата\n• Выдаленыя налады з выцяжнога меню\n• Пашыраныя налады вынесены на асобную старонку\n\n[2.0.0] - 2025-06-30\n\n• Дададзены новыя персанажы\n• Дададзена карыстальніцкае поле ўводу\n• Дададзена падтрымка DeepL\n• Опцыя фармальнасці для DeepL\n• Паляпшэнні інтэрфейсу\n\n[1.0.9] - 2025-06-29\n\n• Абноўлены значок плагіна\n• Новы перамыкач перакладу па змаўчанні\n• Кнопка капіявання ў тэставым рэжыме\n• Мема-рэжым цяпер падтрымлівае іншыя мовы\n\n[1.0.8] - Папярэдняя версія\n\n• AI чат заўсёды даступны\n• Палепшана арганізацыя наладаў\n• Асабістыя мовы чата\n• Захаванне/загрузка моў па чатах\n• Выпраўленні і паляпшэнні стабільнасці\n\n[1.0.7] - Старэйшая версія\n\n• Перамыкач для першага паведамлення\n• Аналітыка перакладаў\n• Палепшаны пераклад на хіндзі з дапамогай AI\n• Экспарт/імпарт наладаў",
        "HELP_DIALOG_TEXT": "Плагін Auto Translate — Каманды\n\nАСНОЎНЫЯ\n\n!on — Уключыць пераклад у гэтым чаце\n!off — Выключыць пераклад у гэтым чаце\n\nПРАВАЙДЭР\n\n!google — Пераключыцца на Google Translate\n!yandex — Пераключыцца на Yandex Translate\n!deepl — Пераключыцца на DeepL Translate\n!dry — Уключыць рэжым прагляду (толькі прагляд перакладу)\n\nМОВА & ЧАТ\n\n!tl <код_мовы> <тэкст> — Перакласці <тэкст> на <код_мовы> (напрыклад, !tl es Прывітанне)\n!tl hi-hinglish <тэкст> — Перакласці <тэкст> на Hinglish (Roman Hindi)\n!tlchat <код_мовы> — Усталяваць мову па змаўчанні для чата\n!tlchat none — Прыбраць мову па змаўчанні для чата\n!ex <коды> — Выключыць мовы з перакладу (напрыклад, !ex en,es,fr)\n!ex none — Ачысціць усе выключэнні\n\nШІ & МЭМЫ\n\n!ai <тэкст> — Пагутарыць з ШІ (Gemini/Phoenix)\n!meme — Уключыць/выключыць рэжым мемаў\n\nАНАЛІТЫКА & ЭКСПАРТ\n\n!analytics — Паказаць статыстыку перакладаў\n!cache — Паказаць/ачысціць кэш перакладаў\n!export — Экспартаваць усе налады і аналітыку\n\n!help, !commands — Паказаць гэта акно дапамогі\nБольш інфармацыі: @luvztroyPlugins",
        "CHANGELOG_DIALOG_TEXT": "[2.0.0] - 2025-06-30\n\n• Дададзены новыя асобы\n• Дадана карыстальніцкае поле ўводу\n• Дадана падтрымка DeepL\n• Опцыя фармальнасці для DeepL\n• Паляпшэнні інтэрфейсу\n\n[1.0.9] - 2025-06-29\n\n• Абноўлены значок плагіна\n• Новы перамыкач перакладу па змаўчанні\n• Кнопка капіявання ў тэставым рэжыме\n• Рэжым мемаў цяпер падтрымлівае іншыя мовы\n\n[1.0.8] - Папярэдняя версія\n\n• AI чат заўсёды даступны\n• Палепшана арганізацыя наладаў\n• Асабістыя мовы чата\n• Захаванне/загрузка моў па чатах\n• Выпраўленні і паляпшэнні стабільнасці\n\n[1.0.7] - Больш старая версія\n\n• Перамыкач для першага паведамлення\n• Аналітыка перакладаў\n• Палепшаны пераклад на хіндзі з ШІ\n• Экспарт/імпорт наладаў",
        "TRANSLATION_OFF_USE_ON": "Пераклад ВЫКЛЮЧАНЫ ў гэтым чаце. Выкарыстоўвайце !on для ўключэння.",
        "UNKNOWN_LANGUAGE_CODE": "Невядомы код мовы",
        "TARGET_LANGUAGE_ALREADY_ENGLISH": "Мова перакладу ўжо англійская",
        "TARGET_LANGUAGE_SET": "Мова перакладу ўсталявана: {0}",
        "NOTHING_TO_TRANSLATE": "Няма тэксту для перакладу",
        "TRANSLATION_RESULT": "Пераклад: {0}",
        "GOOGLE_ALREADY_ACTIVE": "Google ужо абраны як правайдэр",
        "PROVIDER_SET_GOOGLE": "Правайдэр перакладу ўсталяваны: Google",
        "YANDEX_ALREADY_ACTIVE": "Yandex ужо абраны як правайдэр",
        "PROVIDER_SET_YANDEX": "Правайдэр перакладу ўсталяваны: Yandex",
        "DEEPL_ALREADY_ACTIVE": "DeepL ужо абраны як правайдэр",
        "PROVIDER_SET_DEEPL": "Правайдэр перакладу ўсталяваны: DeepL",
        "DRY_RUN_MODE": "Тэставы рэжым {0}",
        "MODEL_ALREADY_ACTIVE": "Мадэль {0} ужо актыўная",
        "MODEL_SWITCHED": "Пераключана на мадэль {0}",
        "DEVELOPER_MODE": "{0}",
        "NO_INTERNET_CONNECTION": "Няма падключэння да Інтэрнэту"
    },
    "en":{
    "SETTINGS_TITLE":"Auto Translate Settings",
    "EXPORT_DIALOG_TITLE":"Export Settings",
    "EXPORT_DIALOG_DESC":"Choose what to export:",
    "PER_CHAT_LANG_REMOVED":"Per-chat language removed for this chat.",
    "NO_PER_CHAT_LANG":"No per-chat language set for this chat.",
    "PER_CHAT_LANG_SET":"Per-chat language set to {0} for this chat.",
    "INVALID_LANG_CODE":"Invalid language code.",
    "SWITCHED_TO_GOOGLE":"Switched to Google Translate",
    "SWITCHED_TO_YANDEX":"Switched to Yandex Translate",
    "SWITCHED_TO_DEEPL":"Switched to DeepL Translate",
    "STATUS_ALREADY_ENABLED":"Auto Translate already enabled in this chat",
    "STATUS_ENABLED":"Auto Translate enabled in this chat",
    "STATUS_ALREADY_DISABLED":"Auto Translate already disabled in this chat",
    "STATUS_DISABLED":"Auto Translate disabled in this chat",
    "STATUS_DISABLED_EXCLUDED":"Auto Translate disabled in this chat (excluded from default)",
    "BULLETIN_MSGS": [
        "Want to auto-translate your messages? Type !on to enable translation in this chat!",
        "Auto-translate is available here! Use !on to start translating your messages.",
        "Quick translation tip: Type !on to enable auto-translate in this chat!",
        "Your messages can be auto-translated! Just say !on to get started.",
        "Translation feature ready! Type !on to enable it for this chat.",
        "Want your messages translated automatically? Use !on to turn it on!",
        "Auto-translate is waiting for you! Type !on to activate it in this chat.",
        "Ready to translate? Type !on to enable auto-translation here!",
        "Translation magic available! Use !on to enable it for this chat.",
        "Your messages can get the translation treatment! Type !on to enable it.",
        "Chat's getting the translation treatment! Type !on to start it up.",
        "Auto-Translate is ready to go! Want it in action? Say !on.",
        "We can translate messages behind the scenes. Say !on to spice it up.",
        "Translation mode is off. Want the magic? Hit it with a !on.",
        "This chat's got built-in translation magic. Want to activate it? Just say !on.",
        "Words can get a quick makeover. Type !on to glam it up.",
        "Your messages can be auto-translated for smooth chatting. Type !on to polish the flow.",
        "Translations are off right now. Use !on to fire them up.",
        "Auto-Translate is on standby. Say !on to bring it to life.",
        "We can give your words a quick language flip. Want the flip? Try !on.",
        "Things can be translated on the fly. Into it? !on is your go!"
    ],
    "EXPORT_OPTION_FULL":"📋 Full Export - All settings, analytics, and debug info",
    "EXPORT_OPTION_SETTINGS":"⚙️ Settings Only - Just your current settings",
    "EXPORT_OPTION_ANALYTICS":"📊 Analytics Only - Translation statistics and cache data",
    "EXPORT_OPTION_DEBUG":"🐛 Debug Info - Technical details for troubleshooting",
    "EXPORT_CLIPBOARD_NOTE":"The exported data will be copied to your clipboard.",
    "BUTTON_FULL_EXPORT":"Full Export",
    "BUTTON_SETTINGS":"Settings",
    "BUTTON_CANCEL":"Cancel",
    "BUTTON_RESET_DATA":"Reset Data",
    "BUTTON_CLOSE":"Close",
    "TRANSLATE_BY_DEFAULT":"Translate by default",
    "TRANSLATE_BY_DEFAULT_SUB":"Enable translation in all chats by default. No suggestion bulletin will be shown.",
    "ENABLE_TRANSLATOR":"Enable Outgoing Auto Translator",
    "ENABLE_TRANSLATOR_SUB":"Enable auto-translation globally. Use !on in chats to enable translation.",
    "TARGET_LANGUAGE":"Target Language",
    "BYPASS_COMMANDS":"Bypass Commands",
    "BYPASS_COMMANDS_SUB":"Skip translation for messages starting with '!'",
    "TRANSLATION_ERROR":"Translation failed! Message not sent.",
    "TRANSLATION_SETTINGS":"Translation Settings",
    "PROVIDER":"Provider",
    "DEEPL_API_KEY":"DeepL API Key",
    "DEEPL_API_KEY_SUB":"Enter your DeepL API Key",
    "FORMALITY":"Formality",
    "FORMALITY_DEFAULT":"Default",
    "FORMALITY_FORMAL":"Formal",
    "FORMALITY_CASUAL":"Casual",
    "GRAMMAR_CHECK":"Grammar Check",
    "GRAMMAR_CHECK_SUB":"Run grammar check on translated text using AI",
    "MEME_MODE":"Meme Mode",
    "MEME_MODE_SUB":"Translate text into cursed meme speak (English only)",
    "AI_CHAT_SETTINGS":"AI Chat Settings",
    "ENABLE_AI_CHAT":"Enable AI Chat",
    "ENABLE_AI_CHAT_SUB":"Allow using the !ai command to chat with AI",
    "AI_PROVIDER":"AI Provider",
    "AI_PERSONA":"AI Persona",
    "CUSTOM_PERSONA_PROMPT":"Custom Persona Prompt",
    "CUSTOM_PERSONA_PROMPT_SUB":"Enter your custom prompt for the AI persona.",
    "GEMINI_API_KEY":"Gemini API Key",
    "GEMINI_API_KEY_SUB":"Enter your Gemini API Key",
    "GEMINI_MODEL":"Gemini Model",
    "PHOENIX_API_KEY":"Phoenix API Key",
    "PHOENIX_MODEL":"Phoenix Model",
    "ADVANCED_SETTINGS":"Advanced Settings",
    "ADVANCED_SETTINGS_SUB":"Enable extra controls like excluded words list.",
    "EXCLUDED_LANGUAGES":"Excluded Languages",
    "DRY_RUN_MODE":"Dry-run mode",
    "DRY_RUN_MODE_SUB":"Show translation in bulletin, don't send.",
    "ALLOW_FIRST_MESSAGE":"Allow First Message",
    "ALLOW_FIRST_MESSAGE_SUB": "Send the first message without translation",
    "TRANSLATION_SETTINGS": "Translation Settings",
    "AI_PROCESSING": "AI & Processing",
    "ANALYTICS": "Analytics",
    "SKIP_REGEX_LIST":"Skip Regex List",
    "SKIP_REGEX_LIST_SUB":"Comma-separated regex patterns; matching messages won't be translated.",
    "ANALYTICS_MONITORING":"Analytics & Monitoring",
    "ENABLE_ANALYTICS":"Enable Translation Analytics",
    "ENABLE_ANALYTICS_SUB":"Track translation statistics, success rates, and usage patterns.",
    "VIEW_ANALYTICS":"View Analytics",
    "ABOUT":"About",
    "HELP_USAGE":"Help / Usage",
    "CHANGELOG":"Changelog",
    "SELECT_LANGUAGES_TO_BYPASS_TRANSLATION": "Excluded Languages",
    "SELECT_LANGUAGES_TO_BYPASS_TRANSLATION_SUB": "Messages in these languages will not be translated.",
    "THANK_YOU":"Thank you for using Auto Translate! Feedback?\nJoin: @luvztroyPlugins",
    "HELP_DIALOG_TITLE": "Auto Translate Help",
    "CHANGELOG_DIALOG_TITLE": "Auto Translate Changelog",
    "HELP_DIALOG_TEXT": "Auto Translate Plugin — Commands\n\nBASIC\n\n!on — Enable translation for this chat\n!off — Disable translation for this chat\n\nPROVIDER\n\n!google — Switch to Google Translate\n!yandex — Switch to Yandex Translate\n!deepl — Switch to DeepL Translate\n!dry — Toggle dry run mode (shows translation as popup only)\n\nLANGUAGE & CHAT\n\n!tl <lang_code> <text> — Translate <text> to <lang_code> (e.g. !tl es Hello)\n!tl hi-hinglish <text> — Translate <text> to Hinglish (Roman Hindi)\n!tlchat <lang_code> — Set per-chat default language\n!tlchat none — Remove per-chat language\n!ex <codes> — Exclude languages from translation (e.g. !ex en,es,fr)\n!ex none — Clear all exclusions\n\nCACHE MANAGEMENT\n\n!cache — Show cache information and options\n!clearcache — Clear all cached translations\n\nAI & MEME\n\n!ai <text> — Chat with AI (Gemini/Phoenix)\n!meme — Toggle meme translation mode\n\nANALYTICS & EXPORT\n\n!analytics — Show translation stats\n!export — Export all settings & analytics\n\n!help, !commands — Show this help dialog\nMore info: @luvztroyPlugins",

    "CHANGELOG_DIALOG_TEXT": "[2.1.0] - 2025-07-05\n\n• Added Russian and Belarusian localization\n• Plugin now remembers per-chat translation on/off preference\n• Removed settings from drawer menu\n• Moved advanced settings to a separate page\n\n[2.0.0] - 2025-06-30\n\n• Added new personas\n• Added custom input field\n• Added DeepL Support\n• Formality Option for DeepL\n• UI Improvements\n\n[1.0.9] - 2025-06-29\n\n• Updated icon for plugin\n• New toggle for translating messages by default\n• Added a copy button in dry run mode\n• Now meme mode supports other languages as well\n\n[1.0.8] - Previous Version\n\n• Made AI Chat settings always visible (no dev mode needed)\n• Improved settings organization\n• Added per-chat language settings functionality\n• Added save/load of target languages per chat\n• Various bug fixes and stability improvements\n\n[1.0.7] - Older Version\n\n• Added a toggle for sending the first message without clearing from the composer\n• Added translation analytics\n• Improved Hindi language translation with AI\n• Added settings export/import feature"

    },
    "ru":{
        "SETTINGS_TITLE":"Настройки автоперевода",
        "PER_CHAT_LANG_REMOVED":"Язык для этого чата сброшен.",
        "NO_PER_CHAT_LANG":"Для этого чата не установлен язык по умолчанию.",
        "PER_CHAT_LANG_SET":"Язык для этого чата установлен: {0}",
        "INVALID_LANG_CODE":"Неверный код языка.",
        "SWITCHED_TO_GOOGLE":"Переключено на Google Translate",
        "SWITCHED_TO_YANDEX":"Переключено на Yandex Translate",
        "SWITCHED_TO_DEEPL":"Переключено на DeepL Translate",
        "STATUS_ALREADY_ENABLED":"Автоперевод уже включён в этом чате",
        "STATUS_ENABLED":"Автоперевод включён в этом чате",
        "STATUS_ALREADY_DISABLED":"Автоперевод уже отключён в этом чате",
        "STATUS_DISABLED":"Автоперевод отключён в этом чате",
        "STATUS_DISABLED_EXCLUDED":"Автоперевод отключён в этом чате (исключён по умолчанию)",
        "BULLETIN_MSGS": [
            "Хотите автоматически переводить свои сообщения? Введите !on, чтобы включить перевод в этом чате!",
            "Здесь доступен автоперевод! Используйте !on, чтобы начать переводить сообщения.",
            "Быстрый совет: введите !on, чтобы включить автоперевод в этом чате!",
            "Ваши сообщения могут быть автоматически переведены! Просто скажите !on, чтобы начать.",
            "Функция перевода готова! Введите !on, чтобы включить её для этого чата.",
            "Хотите, чтобы ваши сообщения переводились автоматически? Введите !on, чтобы включить!",
            "Автоперевод ждёт вас! Введите !on, чтобы активировать его в этом чате.",
            "Готовы переводить? Введите !on, чтобы включить автоперевод здесь!",
            "Доступна магия перевода! Используйте !on, чтобы включить её для этого чата.",
            "Ваши сообщения могут получить перевод! Введите !on, чтобы включить.",
            "Чат готов к переводу! Введите !on, чтобы начать.",
            "Автоперевод готов к работе! Хотите увидеть его в действии? Скажите !on.",
            "Мы можем переводить сообщения в фоновом режиме. Скажите !on, чтобы добавить изюминку.",
            "Режим перевода выключен. Хотите магии? Введите !on.",
            "В этом чате есть встроенная магия перевода. Хотите активировать её? Просто скажите !on.",
            "Слова могут быстро преобразиться. Введите !on, чтобы придать им блеска.",
            "Ваши сообщения могут быть автоматически переведены для плавного общения. Введите !on, чтобы улучшить коммуникацию.",
            "Сейчас переводы выключены. Используйте !on, чтобы включить их.",
            "Автоперевод в режиме ожидания. Скажите !on, чтобы оживить его.",
            "Мы можем быстро изменить язык ваших слов. Хотите попробовать? Введите !on.",
            "Сообщения можно переводить на лету. Заинтересованы? !on — ваш выбор!"
        ],
        "TRANSLATE_BY_DEFAULT":"Переводить по умолчанию",
        "TRANSLATE_BY_DEFAULT_SUB":"Включить перевод во всех чатах по умолчанию. Сообщение-подсказка не будет показано.",
        "ENABLE_TRANSLATOR":"Включить автопереводчик исходящих",
        
        # Export Settings Dialog
        "EXPORT_DIALOG_TITLE": "Экспорт настроек",
        "EXPORT_DIALOG_DESC": "Выберите, что экспортировать:",
        "EXPORT_OPTION_FULL": "📋 Полный экспорт - Все настройки, аналитика и отладочная информация",
        "EXPORT_OPTION_SETTINGS": "⚙️ Только настройки - Текущие настройки",
        "EXPORT_OPTION_ANALYTICS": "📊 Только аналитика - Статистика переводов и кэш-данные",
        "EXPORT_OPTION_DEBUG": "🐛 Отладочная информация - Технические детали для диагностики",
        "EXPORT_CLIPBOARD_NOTE": "Экспортированные данные будут скопированы в буфер обмена.",
        "BUTTON_FULL_EXPORT": "Полный экспорт",
        "BUTTON_SETTINGS": "Настройки",
        "BUTTON_CANCEL": "Отмена",
        
        "ENABLE_TRANSLATOR_SUB":"Включить автоперевод глобально. Используйте !on в чатах для включения перевода.",
        "TARGET_LANGUAGE":"Язык перевода",
        "BYPASS_COMMANDS":"Пропускать команды",
        "BYPASS_COMMANDS_SUB":"Пропускать перевод для сообщений, начинающихся с '!'",
        "TRANSLATION_ERROR":"Ошибка перевода! Сообщение не отправлено.",
        "GRAMMAR_CHECK":"Грамматическая проверка",
        "GRAMMAR_CHECK_SUB":"Проверять грамматику переведённого текста с помощью ИИ",
        "MEME_MODE":"Мем-режим",
        "MEME_MODE_SUB":"Переводить текст в стиле мемов (только английский)",
        "TRANSLATION_SETTINGS":"Настройки перевода",
        "PROVIDER":"Провайдер",
        "DEEPL_API_KEY":"Ключ DeepL API",
        "DEEPL_API_KEY_SUB":"Введите ваш ключ DeepL API",
        "FORMALITY":"Формальность",
        "FORMALITY_DEFAULT":"По умолчанию",
        "FORMALITY_FORMAL":"Формально",
        "FORMALITY_CASUAL":"Неформально",
        "AI_CHAT_SETTINGS":"Настройки AI чата",
        "ENABLE_AI_CHAT":"Включить AI чат",
        "ENABLE_AI_CHAT_SUB":"Позволяет использовать команду !ai для общения с AI",
        "AI_PROVIDER":"Провайдер AI",
        "AI_PERSONA":"Персона AI",
        "CUSTOM_PERSONA_PROMPT":"Свой промпт для AI",
        "CUSTOM_PERSONA_PROMPT_SUB":"Введите свой промпт для AI-персоны.",
        "GEMINI_API_KEY":"Ключ Gemini API",
        "GEMINI_API_KEY_SUB":"Введите ваш ключ Gemini API",
        "GEMINI_MODEL":"Модель Gemini",
        "PHOENIX_API_KEY":"Ключ Phoenix API",
        "PHOENIX_MODEL":"Модель Phoenix",
        "ADVANCED_SETTINGS":"Расширенные настройки",
        "ADVANCED_SETTINGS_SUB":"Включить дополнительные опции, например, список исключённых языков.",
        "EXCLUDED_LANGUAGES":"Исключённые языки",
        "EXCLUDED_LANGUAGES_SUB":"Выберите языки, которые не будут переводиться.",
        "ADD_EXCLUDED_LANGUAGE":"Добавить язык",
        "REMOVE":"Удалить",
        "NO_LANGUAGES_EXCLUDED":"Нет исключённых языков",
        "EXCLUDE_LANGUAGE_TITLE":"Исключить язык",
        "EXCLUDE_LANGUAGE_HINT":"Выберите язык для исключения из перевода.",
        "EXCLUDED_LANGUAGES_SUB":"Выберите языки, которые не будут переводиться.",
        "ADD_EXCLUDED_LANGUAGE":"Добавить язык",
        "REMOVE":"Удалить",
        "NO_LANGUAGES_EXCLUDED":"Нет исключённых языков",
        "EXCLUDE_LANGUAGE_TITLE":"Исключить язык",
        "EXCLUDE_LANGUAGE_HINT":"Выберите язык для исключения из перевода.",
        "DRY_RUN_MODE":"Тестовый режим",
        "DRY_RUN_MODE_SUB":"Показывать перевод в буллетине, не отправлять.",
        "ALLOW_FIRST_MESSAGE":"Разрешить первое сообщение",
        "ALLOW_FIRST_MESSAGE_SUB": "Отправлять первое сообщение без перевода",
        "TRANSLATION_SETTINGS": "Настройки перевода",
        "AI_PROCESSING": "ИИ и обработка",
        "ANALYTICS": "Аналитика",
        "SKIP_REGEX_LIST":"Список Regex для пропуска",
        "SKIP_REGEX_LIST_SUB":"Регулярные выражения через запятую; совпадающие сообщения не будут переводиться.",
        "ANALYTICS_MONITORING":"Аналитика и мониторинг",
        "ENABLE_ANALYTICS":"Включить аналитику переводов",
        "ENABLE_ANALYTICS_SUB":"Отслеживать статистику переводов, успехи и использование.",
        "VIEW_ANALYTICS":"Посмотреть аналитику",
        "ABOUT":"О программе",
        "HELP_USAGE":"Помощь / Использование",
        "CHANGELOG":"Список изменений",
        "SELECT_LANGUAGES_TO_BYPASS_TRANSLATION": "Выберите языки для исключения из перевода",
        "SELECT_LANGUAGES_TO_BYPASS_TRANSLATION_SUB": "Сообщения на этих языках не будут переводиться.",
        "THANK_YOU":"Спасибо за использование Auto Translate! Обратная связь?\nПрисоединяйтесь: @luvztroyPlugins",
    "HELP_DIALOG_TITLE": "Помощь Auto Translate",
    "CHANGELOG_DIALOG_TITLE": "Список изменений Auto Translate",
    "HELP_DIALOG_TEXT": "Плагин Auto Translate — Команды\n\nОСНОВНЫЕ\n\n!on — Включить перевод для этого чата\n!off — Выключить перевод для этого чата\n\nПРОВАЙДЕР\n\n!google — Переключиться на Google Translate\n!yandex — Переключиться на Yandex Translate\n!deepl — Переключиться на DeepL Translate\n!dry — Включить предпросмотр (только просмотр перевода)\n\nЯЗЫК & ЧАТ\n\n!tl <код_языка> <текст> — Перевести <текст> на <код_языка> (например, !tl es Hello)\n!tl hi-hinglish <текст> — Перевести <текст> на Hinglish (Roman Hindi)\n!tlchat <код_языка> — Установить язык по умолчанию для чата\n!tlchat none — Убрать язык по умолчанию для чата\n!ex <коды> — Исключить языки из перевода (например, !ex en,es,fr)\n!ex none — Очистить все исключения\n\nИИ & МЕМ\n\n!ai <текст> — Чат с ИИ (Gemini/Phoenix)\n!meme — Включить/выключить мем-режим\n\nАНАЛИТИКА & ЭКСПОРТ\n\n!analytics — Показать статистику переводов\n!cache — Показать/очистить кэш переводов\n!export — Экспортировать все настройки и аналитику\n\n!help, !commands — Показать это окно помощи\nБольше информации: @luvztroyPlugins",

    "CHANGELOG_DIALOG_TEXT": "[2.1.0] - 2025-07-05\n\n• Добавлена русская и белорусская локализация\n• Плагин теперь запоминает настройки перевода для каждого чата\n• Удалены настройки из выдвижного меню\n• Расширенные настройки вынесены на отдельную страницу\n\n[2.0.0] - 2025-06-30\n\n• Добавлены новые персоны\n• Добавлено пользовательское поле ввода\n• Добавлена поддержка DeepL\n• Опция формальности для DeepL\n• Улучшения интерфейса\n\n[1.0.9] - 2025-06-29\n\n• Обновлён значок плагина\n• Новый переключатель перевода по умолчанию\n• Кнопка копирования в тестовом режиме\n• Мем-режим теперь поддерживает другие языки\n\n[1.0.8] - Предыдущая версия\n\n• AI чат всегда доступен\n• Улучшена организация настроек\n• Персональные языки чата\n• Сохранение/загрузка языков по чатам\n• Исправления и улучшения стабильности\n\n[1.0.7] - Более старая версия\n\n• Переключатель для первого сообщения\n• Аналитика переводов\n• Улучшен перевод на хинди с AI\n• Экспорт/импорт настроек",

        "TRANSLATION_OFF_USE_ON": "Перевод ВЫКЛЮЧЕН в этом чате. Используйте !on для включения.",
        "UNKNOWN_LANGUAGE_CODE": "Неизвестный код языка",
        "TARGET_LANGUAGE_ALREADY_ENGLISH": "Язык перевода уже английский",
        "TARGET_LANGUAGE_SET": "Язык перевода установлен: {0}",
        "NOTHING_TO_TRANSLATE": "Нет текста для перевода",
        "TRANSLATION_RESULT": "Перевод: {0}",
        "GOOGLE_ALREADY_ACTIVE": "Google уже выбран как провайдер",
        "PROVIDER_SET_GOOGLE": "Провайдер перевода установлен: Google",
        "YANDEX_ALREADY_ACTIVE": "Yandex уже выбран как провайдер",
        "PROVIDER_SET_YANDEX": "Провайдер перевода установлен: Yandex",
        "DRY_RUN_MODE": "Тестовый режим {0}",
        "MODEL_ALREADY_ACTIVE": "Модель {0} уже активна",
        "MODEL_SWITCHED": "Переключено на модель {0}",
        "DEVELOPER_MODE": "{0}",
        "NO_INTERNET_CONNECTION": "Нет подключения к интернету"
    }
    }

LANG_CODES =[
"af","am","ar","as","ay","az","be","bg","bn","bs","ca","ceb","co","cs","cy","da","de","el","en","eo","es","et","eu","fa","fi","fil","fr","fy","ga","gd","gl","gu","ha","haw","he","hi","hi-hinglish","hmn","hr","ht","hu","hy","id","ig","is","it","iw","ja","jw","ka","kk","km","kn","ko","ku","ky","la","lb","lo","lt","lv","mg","mi","mk","ml","mn","mr","ms","mt","my","ne","nl","no","ny","or","pa","pl","ps","pt","ro","ru","si","sk","sl","sm","sn","so","sq","sr","st","su","sv","sw","ta","te","tg","th","tk","tl","tr","tt","ug","uk","ur","uz","vi","xh","yi","yo","zh","zu"
]
LANG_NAMES =[
"Afrikaans","Amharic","Arabic","Assamese","Aymara","Azerbaijani","Belarusian","Bulgarian","Bengali","Bosnian","Catalan","Cebuano","Corsican","Czech","Welsh","Danish","German","Greek","English","Esperanto","Spanish","Estonian","Basque","Persian","Finnish","Filipino","French","Frisian","Irish","Scots Gaelic","Galician","Gujarati","Hausa","Hawaiian","Hebrew","Hindi","Hinglish","Hmong","Croatian","Haitian Creole","Hungarian","Armenian","Indonesian","Igbo","Icelandic","Italian","Hebrew","Japanese","Javanese","Georgian","Kazakh","Khmer","Kannada","Korean","Kurdish","Kyrgyz","Latin","Luxembourgish","Lao","Lithuanian","Latvian","Malagasy","Maori","Macedonian","Malayalam","Mongolian","Marathi","Malay","Maltese","Myanmar","Nepali","Dutch","Norwegian","Nyanja","Odia","Punjabi","Polish","Pashto","Portuguese","Romanian","Russian","Sinhala","Slovak","Slovenian","Samoan","Shona","Somali","Albanian","Serbian","Sesotho","Sundanese","Swedish","Swahili","Tamil","Telugu","Tajik","Thai","Turkmen","Tagalog","Turkish","Tatar","Uyghur","Ukrainian","Urdu","Uzbek","Vietnamese","Xhosa","Yiddish","Yoruba","Chinese","Zulu"
]

locali = LocalizationManager()


class AutoTranslatePlugin (BasePlugin ):
    def _translate_with_deepl(self, text, target_lang):
        """
        Translate text using DeepL API.
        """
        api_key = self.get_setting("deepl_api_key", "").strip()
        if not api_key:
            log("[DeepL] API key not set!")
            return None
        # DeepL expects language codes like EN, DE, FR, etc. (uppercased)
        deepl_lang_map = {
            'en': 'EN', 'de': 'DE', 'fr': 'FR', 'es': 'ES', 'it': 'IT', 'nl': 'NL', 'pl': 'PL', 'ru': 'RU',
            'ja': 'JA', 'zh': 'ZH', 'bg': 'BG', 'cs': 'CS', 'da': 'DA', 'el': 'EL', 'et': 'ET', 'fi': 'FI',
            'hu': 'HU', 'lt': 'LT', 'lv': 'LV', 'pt': 'PT', 'ro': 'RO', 'sk': 'SK', 'sl': 'SL', 'sv': 'SV',
            'tr': 'TR', 'uk': 'UK', 'ko': 'KO', 'nb': 'NB'
        }
        # DeepL formality supported language codes
        deepl_formality_supported = {"de","fr","it","es","nl","pl","pt","ru"}
        # Try to map our target_lang to DeepL's
        deepl_target = deepl_lang_map.get(target_lang.lower(), target_lang.upper())
        url = "https://api-free.deepl.com/v2/translate"
        headers = {
            "Authorization": f"DeepL-Auth-Key {api_key}",
            "Content-Type": "application/x-www-form-urlencoded"
        }
        data = {
            "text": text,
            "target_lang": deepl_target
        }
        # Add formality if supported
        if target_lang.lower() in deepl_formality_supported:
            formality_idx = self.get_setting("deepl_formality", 0)
            formality_map = {0: "default", 1: "more", 2: "less"}
            formality_value = formality_map.get(formality_idx, "default")
            data["formality"] = formality_value
        try:
            response = requests.post(url, headers=headers, data=data, timeout=5)
            if response.status_code == 200:
                resp_json = response.json()
                if resp_json.get("translations"):
                    # Always return the DeepL result, even if it's identical to input
                    return resp_json["translations"][0]["text"]
            else:
                log(f"[DeepL] Error: {response.status_code} {response.text}")
        except Exception as e:
            log(f"[DeepL] Exception: {e}")
        return None

    def _load_cache_from_storage(self):
        """Load the cache from persistent storage"""
        try:
            cached_data = self.get_setting("persistent_cache", {})
            if isinstance(cached_data, dict):
                # Convert string timestamps back to float
                current_time = time.time()
                return {
                    key: (float(timestamp), value) 
                    for key, (timestamp, value) in cached_data.items()
                    if (current_time - float(timestamp)) <= self.cache_timeout
                }
        except Exception as e:
            log(f"Error loading cache from storage: {e}")
        return {}

    def _save_cache_to_storage(self):
        """Save the current cache to persistent storage"""
        try:
            # Only store non-expired entries
            current_time = time.time()
            cache_to_save = {
                key: (str(timestamp), value)  # Convert timestamp to string for JSON serialization
                for key, (timestamp, value) in self.translation_cache.items()
                if (current_time - timestamp) <= self.cache_timeout
            }
            self.set_setting("persistent_cache", cache_to_save)
        except Exception as e:
            log(f"Error saving cache to storage: {e}")

    def _cleanup_cache(self):
        """Remove expired entries from the cache"""
        current_time = time.time()
        expired_keys = [
            key for key, (timestamp, _) in self.translation_cache.items()
            if (current_time - timestamp) > self.cache_timeout
        ]
        for key in expired_keys:
            del self.translation_cache[key]
        
        # Only save if we actually removed something
        if expired_keys:
            self._save_cache_to_storage()
        
        self.last_cache_cleanup = current_time
        return len(expired_keys)

    def __init__ (self ):
        super ().__init__ ()
        self.cache_timeout = 300  # Fixed 5 minute cache timeout
        log(f"AutoTranslatePlugin initializing with cache timeout: {self.cache_timeout} seconds")
        
        # Load cache from persistent storage
        self.translation_cache = self._load_cache_from_storage()
        log(f"Loaded {len(self.translation_cache)} cached translations from storage")
        
        self.last_cache_cleanup = time.time()
        
        # Initialize localization manager
        self.localization_manager = LocalizationManager()
        self.verbose_logging = False 
        self.last_exception :Optional [str ] = None

        self .is_sending_translated =False 
        self .progress_dialog :Optional [AlertDialogBuilder ]=None 

        self.excluded_chats: set[int] = set()
        self.enabled_chats: set[int] = set()
        self._status_bulletins_shown: set[int] = set()

        self ._drawer_settings_item =None 
        self ._chat_settings_item =None 

        self .PREMIUM_EMO_TAG_RE =re .compile (r'<emoji[^>]*?/?>|<emoji[^>]*?>.*?</emoji>',flags =re .S |re .I )

        # Load excluded chats from settings
        self._load_excluded()

        self.translation_stats = {

            'total_translations': 0,
            'successful_translations': 0,
            'failed_translations': 0,
            'cache_hits': 0,
            'cache_misses': 0,
            'language_stats': {},
            'provider_stats': {'google': 0, 'yandex': 0, 'deepl': 0, 'cache': 0},
            'daily_stats': {},
            'last_reset_date': time.strftime('%Y-%m-%d')
        }
        
        self._load_analytics_data()

        # Per-chat language mapping (persistent)
        self.chat_target_languages = {}
        self._load_chat_languages()  # Load mapping on object creation
        self._load_enabled()  # Load enabled chats on object creation


    
    def _load_enabled(self):
        """Load enabled chats from persistent storage."""
        try:
            raw = self.get_setting("enabled_chats", "")
            if raw.strip():
                self.enabled_chats = set(int(x) for x in raw.split(',') if x.strip())
            else:
                self.enabled_chats = set()
            log(f"[AutoTranslate] Loaded {len(self.enabled_chats)} enabled chats")
        except Exception as e:
            log(f"[AutoTranslate] Failed to load enabled chats: {e}")
            self.enabled_chats = set()

    def _save_enabled(self):
        """Save enabled chats to persistent storage."""
        try:
            if self.enabled_chats:
                self.set_setting("enabled_chats", ",".join(str(chat_id) for chat_id in self.enabled_chats))
            else:
                self.set_setting("enabled_chats", "")
            log(f"[AutoTranslate] Saved {len(self.enabled_chats)} enabled chats")
        except Exception as e:
            log(f"[AutoTranslate] Failed to save enabled chats: {e}")

    def _load_chat_languages(self):
        """Load per-chat language mapping from persistent plugin settings."""
        try:
            raw = self.get_setting("chat_target_languages", "{}")
            self.chat_target_languages = json.loads(raw)
            log(f"[PerChatLang] Loaded chat_target_languages: {self.chat_target_languages}")
        except Exception as e:
            log(f"[PerChatLang] Failed to load chat_target_languages: {e}")
            self.chat_target_languages = {}

    def _save_chat_languages(self):
        """Save per-chat language mapping to persistent plugin settings."""
        try:
            self.set_setting("chat_target_languages", json.dumps(self.chat_target_languages))
            log(f"[PerChatLang] Saved chat_target_languages: {self.chat_target_languages}")
        except Exception as e:
            log(f"[PerChatLang] Failed to save chat_target_languages: {e}")

    def _delayed_changelog_check (self ):
        try :
            log ("[Changelog] Starting delayed changelog check...")
            self ._check_and_show_changelog ()
        except Exception as e :
            log (f"[Changelog] Error in delayed changelog check: {e }")


    
    def _load_analytics_data(self):
        """Load analytics data from settings"""
        try:
            analytics_json = self.get_setting("translation_analytics", "{}")
            if analytics_json:
                loaded_stats = json.loads(analytics_json)
                
                for key, value in self.translation_stats.items():
                    if key not in loaded_stats:
                        loaded_stats[key] = value
                self.translation_stats = loaded_stats
                
                current_date = time.strftime('%Y-%m-%d')
                if self.translation_stats.get('last_reset_date') != current_date:
                    self.translation_stats['daily_stats'] = {}
                    self.translation_stats['last_reset_date'] = current_date
                    self._save_analytics_data()
                    
        except Exception as e:
            log(f"[Analytics] Error loading analytics data: {e}")
            self.translation_stats = {
                'total_translations': 0,
                'successful_translations': 0,
                'failed_translations': 0,
                'cache_hits': 0,
                'cache_misses': 0,
                'language_stats': {},
                'provider_stats': {'google': 0, 'yandex': 0, 'deepl': 0, 'cache': 0},
                'daily_stats': {},
                'last_reset_date': time.strftime('%Y-%m-%d')
            }

    def _save_analytics_data(self):
        """Save analytics data to settings"""
        try:
            analytics_json = json.dumps(self.translation_stats)
            self.set_setting("translation_analytics", analytics_json)
            
            log(f"[Analytics] Saved stats - "
                f"Total: {self.translation_stats.get('total_translations', 0)}, "
                f"Success: {self.translation_stats.get('successful_translations', 0)}, "
                f"Cache Hits: {self.translation_stats.get('cache_hits', 0)}")
                
        except Exception as e:
            log(f"Error saving analytics data: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Failed to save analytics data"))

    def _track_translation(self, source_lang: str, target_lang: str, provider: str, success: bool, cache_hit: bool = False):
        """Track translation statistics"""
        try:
            if not self.get_setting("enable_analytics", True):
                return
                
            self.translation_stats['total_translations'] += 1
            
            if success:
                self.translation_stats['successful_translations'] += 1
            else:
                self.translation_stats['failed_translations'] += 1
                
            if cache_hit:
                self.translation_stats['cache_hits'] += 1
            else:
                self.translation_stats['cache_misses'] += 1
                
            lang_pair = f"{source_lang}→{target_lang}"
            if lang_pair not in self.translation_stats['language_stats']:
                self.translation_stats['language_stats'][lang_pair] = 0
            self.translation_stats['language_stats'][lang_pair] += 1
            
            if provider not in self.translation_stats['provider_stats']:
                self.translation_stats['provider_stats'][provider] = 0
            self.translation_stats['provider_stats'][provider] += 1
                
            current_date = time.strftime('%Y-%m-%d')
            if current_date not in self.translation_stats['daily_stats']:
                self.translation_stats['daily_stats'][current_date] = {
                    'translations': 0,
                    'successful': 0,
                    'failed': 0
                }
            self.translation_stats['daily_stats'][current_date]['translations'] += 1
            if success:
                self.translation_stats['daily_stats'][current_date]['successful'] += 1
            else:
                self.translation_stats['daily_stats'][current_date]['failed'] += 1
                
            if self.translation_stats['total_translations'] % 10 == 0:
                self._save_analytics_data()
                
        except Exception as e:
            log(f"Error tracking translation: {e}")

    def _reset_analytics(self):
        """Reset all analytics data"""
        try:
            self.translation_stats = {
                'total_translations': 0,
                'successful_translations': 0,
                'failed_translations': 0,
                'cache_hits': 0,
                'cache_misses': 0,
                'language_stats': {},
                'provider_stats': {'google': 0, 'yandex': 0, 'deepl': 0, 'cache': 0},
                'daily_stats': {},
                'last_reset_date': time.strftime('%Y-%m-%d')
            }
            self._save_analytics_data()
            run_on_ui_thread(lambda: BulletinHelper.show_success(locali.get_string("ANALYTICS_RESET_SUCCESS", "Analytics data reset successfully")))
        except Exception as e:
            log(f"Error resetting analytics: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Failed to reset analytics data"))

    # Removed _on_analytics_toggled and _create_settings_refresh_callback methods as they're no longer needed

    def _show_analytics_dialog(self, view=None):
        """Show analytics dialog with translation statistics"""
        try:
            fragment = get_last_fragment()
            if not fragment or not fragment.getParentActivity():
                return
                
            stats = self.translation_stats
            
            success_rate = 0
            if stats['total_translations'] > 0:
                success_rate = (stats['successful_translations'] / stats['total_translations']) * 100
                
            cache_hit_rate = 0
            total_cache_attempts = stats['cache_hits'] + stats['cache_misses']
            if total_cache_attempts > 0:
                cache_hit_rate = (stats['cache_hits'] / total_cache_attempts) * 100
                
            top_languages = sorted(stats['language_stats'].items(), key=lambda x: x[1], reverse=True)[:5]
            top_lang_text = "\n".join([f"• {pair}: {count}" for pair, count in top_languages]) if top_languages else "No data"
            
            provider_text = "\n".join([f"• {provider.title()}: {count}" for provider, count in stats['provider_stats'].items()])
            
            grammar_stats = {}
            for lang_pair, count in stats['language_stats'].items():
                if 'grammar' in lang_pair.lower() or 'correction' in lang_pair.lower():
                    grammar_stats[lang_pair] = count
            
            grammar_text = "\n".join([f"• {pair}: {count}" for pair, count in sorted(grammar_stats.items(), key=lambda x: x[1], reverse=True)[:3]]) if grammar_stats else "No grammar corrections yet"
            
            recent_days = sorted(stats['daily_stats'].items(), key=lambda x: x[0], reverse=True)[:7]
            daily_text = "\n".join([f"• {date}: {day_stats['translations']} translations ({day_stats['successful']} successful)" 
                                  for date, day_stats in recent_days]) if recent_days else "No data"
            
            analytics_text = f"""Translation Analytics

📊 Overall Statistics:
• Total Translations: {stats['total_translations']}
• Successful: {stats['successful_translations']}
• Failed: {stats['failed_translations']}
• Success Rate: {success_rate:.1f}%

💾 Cache Performance:
• Cache Hits: {stats['cache_hits']}
• Cache Misses: {stats['cache_misses']}
• Hit Rate: {cache_hit_rate:.1f}%

🌍 Top Language Pairs:
{top_lang_text}

🔧 Provider Usage:
{provider_text}

✏️ Grammar Check Activity:
{grammar_text}

📅 Recent Daily Activity:
{daily_text}

Last Reset: {stats['last_reset_date']}"""

            builder = AlertDialogBuilder(fragment.getParentActivity(), AlertDialogBuilder.ALERT_TYPE_MESSAGE)
            builder.set_title("Translation Analytics")
            builder.set_message(analytics_text)
            builder.set_positive_button("Reset Data", lambda d, w: self._reset_analytics())
            builder.set_negative_button("Close", None)
            run_on_ui_thread(lambda: builder.show())
            
        except Exception as e:
            log(f"Error showing analytics dialog: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Failed to load analytics"))



    def on_plugin_load (self ):
        print ("AutoTranslatePlugin loaded")
        log ("[AutoTranslate] Plugin loaded, starting initialization...")

        try :
            log ("[AutoTranslate] Adding message hook...")
            self.add_on_send_message_hook()
            log ("[AutoTranslate] Message hook added")

            # Load excluded chats
            log ("[AutoTranslate] Loading excluded chats...")
            try :
                raw = self.get_setting("excluded_chats","")
                if raw.strip():
                    self.excluded_chats = set(int(x) for x in raw.split(',') if x.strip())
                    self.all_chats_excluded_by_default = False 
                else:
                    self.excluded_chats = set()
                    self.all_chats_excluded_by_default = True 
                if self.excluded_chats:
                    log(f"[AutoTranslate] Loaded {len(self.excluded_chats)} excluded chats. Chat IDs: {', '.join(str(chat_id) for chat_id in self.excluded_chats)}")
                else:
                    log("[AutoTranslate] No chats are currently excluded")
            except Exception as e:
                log (f"[AutoTranslate] Failed to load excluded chats: {e}")
                self.excluded_chats = set()
                self.all_chats_excluded_by_default = True

            # Load enabled chats
            log ("[AutoTranslate] Loading enabled chats...")
            self._load_enabled()

            log ("[AutoTranslate] Plugin initialization completed")

        except Exception as e:
            log (f"[AutoTranslate] Error during plugin load: {e}")
            import traceback 
            log (f"[AutoTranslate] {traceback.format_exc()}")

        self._add_settings_menu_items()
        self._load_chat_languages()  # Ensure mapping is loaded on plugin load

    def _load_cache_from_storage(self):
        """Load the translation cache from persistent storage."""
        log("Starting to load translation cache from storage...")
        try:
            cached_data = self.get_setting("translation_cache", {})
            log(f"Raw cache data from storage: {type(cached_data)} (length: {len(cached_data) if hasattr(cached_data, '__len__') else 'N/A'})")
            
            if not isinstance(cached_data, dict):
                log(f"WARNING: Invalid cache data type: {type(cached_data)}, starting with empty cache")
                return {}
                
            # Filter out expired entries on load
            current_time = time.time()
            valid_entries = {}
            expired_count = 0
            total_entries = len(cached_data)
            
            log(f"Processing {total_entries} cache entries...")
            
            for key, value in cached_data.items():
                try:
                    if not isinstance(value, (list, tuple)) or len(value) != 2:
                        log(f"Skipping invalid cache entry (key: {key}): {value}")
                        continue
                        
                    translation, timestamp = value
                    if not isinstance(timestamp, (int, float)):
                        log(f"Skipping entry with invalid timestamp (key: {key}, timestamp: {timestamp})")
                        continue
                        
                    if current_time - timestamp <= self.cache_timeout:
                        valid_entries[key] = (translation, timestamp)
                    else:
                        expired_count += 1
                except Exception as e:
                    log(f"Error processing cache entry (key: {key}): {e}")
                    continue
                    
            log(f"Cache load complete. Total: {total_entries}, Valid: {len(valid_entries)}, Expired: {expired_count}")
            return valid_entries
            
        except Exception as e:
            log(f"ERROR in _load_cache_from_storage: {e}")
            return {}
            
        except Exception as e:
            log(f"Error loading cache from storage: {e}")
            return {}
            
    def _save_cache_to_storage(self):
        """Save the current translation cache to persistent storage."""
        try:
            self.set_setting("translation_cache", self.translation_cache)
            return True
        except Exception as e:
            log(f"Error saving cache to storage: {e}")
            return False

    def cleanup_cache(self, force=False):
        """Clean up expired cache entries and save changes to storage.
        
        Args:
            force: If True, force cleanup regardless of last cleanup time
        """
        current_time = time.time()
        
        # Only clean up once per hour unless forced
        if force or (current_time - self.last_cache_cleanup > 3600):
            expired_keys = []
            log(f"Running cache cleanup. Current cache size: {len(self.translation_cache)}")
            log("Cache timeout: 5 minutes")
            
            for key, (translation, timestamp) in list(self.translation_cache.items()):
                age = current_time - timestamp
                if age > self.cache_timeout:
                    expired_keys.append(key)
                    if len(expired_keys) <= 5:  # Only log first few for debugging
                        log(f"Expiring cache entry (age: {age:.1f}s > 300s): {key[:50]}...")
            
            if expired_keys:
                log(f"Cleaning up {len(expired_keys)} expired cache entries")
                for key in expired_keys:
                    if key in self.translation_cache:  # Check again in case it was already removed
                        del self.translation_cache[key]
                
                # Save changes to persistent storage
                if self._save_cache_to_storage():
                    log(f"Successfully saved cache after cleanup. New size: {len(self.translation_cache)}")
                else:
                    log("Failed to save cache after cleanup")
            
            self.last_cache_cleanup = current_time
            return len(expired_keys)
        return 0

    def get_cached_translation(self, text, target_lang):
        """Get a cached translation if it exists and hasn't expired."""
        cache_key = f"{text}:{target_lang}"
        current_time = time.time()
        
        if cache_key in self.translation_cache:
            translation, timestamp = self.translation_cache[cache_key]
            age = current_time - timestamp
            
            if age < self.cache_timeout:
                # Update last access time to keep frequently used items in cache
                self.translation_cache[cache_key] = (translation, current_time)
                if self.verbose_logging:
                    log(f"Cache HIT for '{text[:30]}...' (age: {age:.1f}s < 300s)")
                return translation
            else:
                if self.verbose_logging:
                    log(f"Cache MISS (expired) for '{text[:30]}...' (age: {age:.1f}s >= 300s)")
                # Remove expired entry
                del self.translation_cache[cache_key]
        
        if self.verbose_logging:
            log(f"Cache MISS for '{text[:30]}...' (not found)")
        return None

    def cache_translation(self, text, target_lang, translation):
        """Cache a translation and persist it to storage."""
        if not text or not target_lang or not translation:
            log("Warning: Attempted to cache empty text, language, or translation")
            return
            
        cache_key = f"{text}:{target_lang}"
        current_time = time.time()
        
        # Don't cache very long texts to prevent memory issues
        if len(text) > 10000:  # 10KB max
            log(f"Not caching very long text ({len(text)} chars)")
            return
            
        self.translation_cache[cache_key] = (translation, current_time)
        
        if self.verbose_logging:
            log(f"Cached translation for '{text[:30]}...' -> '{translation[:30]}...' (cache size: {len(self.translation_cache)})")
        
        # Save to persistent storage
        if not self._save_cache_to_storage():
            log("Warning: Failed to save cache after adding new translation")
        
        # Clean up old entries if needed (force cleanup if cache is getting large)
        if len(self.translation_cache) > 1000:  # If cache has more than 1000 entries
            self.cleanup_cache(force=True)
        else:
            self.cleanup_cache()

    def _encode_emojis_as_html (self ,text ):
        emoji_pattern =re .compile (
        r'(<emoji[^>]*?>.*?</emoji>)|'
        r'([\U0001F1E6-\U0001F1FF]|'
        r'[\U0001F300-\U0001F5FF]|'
        r'[\U0001F600-\U0001F64F]|'
        r'[\U0001F680-\U0001F6FF]|'
        r'[\U0001F700-\U0001F77F]|'
        r'[\U0001F780-\U0001F7FF]|'
        r'[\U0001F800-\U0001F8FF]|'
        r'[\U0001F900-\U0001F9FF]|'
        r'[\U0001FA70-\U0001FAFF]|'
        r'[\u2600-\u26FF]|'
        r'[\u2700-\u27BF]|'
        r'[\u200d\ufe0f])',
        re .UNICODE |re .IGNORECASE 
        )

        emoji_map ={}

        def replace_emoji (match ):
            emoji =match .group (0 )
            placeholder =f'<tg-emoji-{len (emoji_map )}>'
            emoji_map [placeholder ]=emoji 
            return placeholder 

        encoded_text =emoji_pattern .sub (replace_emoji ,text )

        return encoded_text ,emoji_map 

    def _decode_emojis_from_html (self ,text ,emoji_map ):
        if not emoji_map :
            return text 

        placeholders =sorted (emoji_map .keys (),key =len ,reverse =True )

        for placeholder in placeholders :
            if placeholder in text :
                text =text .replace (placeholder ,emoji_map [placeholder ])

        return text 

    def on_send_message_hook (self ,account :int ,params :Any )->HookResult :
        log (f"on_send_message_hook called with account: {account }, params: {params }")
        # Error test: always trigger if message text is '!errortest'
        try:
            message_text = params.get('message', '') if isinstance(params, dict) else str(params)
            if message_text.strip() == '!errortest':
                self.add_on_update_hook()
        except Exception as e:
            log(f"[ErrorTest] Caught exception: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(str(e)))
            return HookResult(strategy=HookStrategy.CANCEL)
        if self .is_sending_translated :
            log ("Ignoring message - is_sending_translated is True")
            self .is_sending_translated =False 
            return HookResult ()

        if not hasattr (params ,"message")or not isinstance (params .message ,str ):
            log ("No message in params or message is not a string")
            return HookResult ()

        original_text =params .message .strip ()
        lower_text = original_text.lower()
        parts =original_text .split ()
        command =parts [0 ].lower () if parts else ""
        # Bypass ALL dot commands (e.g. .command, .сейчас, .ahora, etc.)
        if original_text.startswith('.'):
            return HookResult()
        peer_obj = getattr(params, 'peer', None)
        peer_id = self._peer_id(peer_obj)
        log(f"Processing message: {original_text}")
        
        # Handle per-chat language command
        if command == "!tlchat" and len(parts) > 1:
            lang_code = parts[1].lower()
            if lang_code == "none":
                if str(peer_id) in self.chat_target_languages:
                    del self.chat_target_languages[str(peer_id)]
                    self._save_chat_languages()
                    run_on_ui_thread(lambda: BulletinHelper.show_info(locali.get_string("PER_CHAT_LANG_REMOVED")))
                else:
                    run_on_ui_thread(lambda: BulletinHelper.show_info(locali.get_string("NO_PER_CHAT_LANG")))
            elif lang_code in LANG_CODES:
                self.chat_target_languages[str(peer_id)] = lang_code
                self._save_chat_languages()
                run_on_ui_thread(lambda: BulletinHelper.show_success(locali.get_string("PER_CHAT_LANG_SET").format(lang_code.upper())))
            else:
                run_on_ui_thread(lambda: BulletinHelper.show_error(locali.get_string("INVALID_LANG_CODE")))
            return HookResult(strategy=HookStrategy.CANCEL)

        # Show suggestion bulletins only if 'Translate by default' is OFF
        if (not self.get_setting("translate_by_default", False)
            and self.get_setting("enable_translator", True)
            and peer_id not in self._status_bulletins_shown
            and command not in ("!on", "!off", "!ai")
            and peer_id not in self.enabled_chats
        ):
            # Get localized bulletin messages
            bulletin_msgs = self.localization_manager.get("BULLETIN_MSGS")
            chosen_msg = random.choice(bulletin_msgs)
            run_on_ui_thread(lambda: BulletinHelper.show_info(chosen_msg))
            self._status_bulletins_shown.add(peer_id)
            
            # Check if we should send the message anyway
            if self.get_setting("send_first_message", False):
                log("send_first_message is enabled, allowing message to be sent")
                return HookResult()
                
            log("send_first_message is disabled, blocking message")
            return HookResult(strategy=HookStrategy.CANCEL)

        if original_text .startswith ('/'):
            return HookResult()

        if original_text .startswith ('!') and command not in ('!on','!off','!google','!yandex','!deepl','!dry','!tl','!ex','!ai','!dev','!credits','!help','!commands','!analytics','!cache','!export','!meme','!lyrics','!now'):

            if original_text .startswith ('! '):
                stripped =original_text [2 :].strip ()
            else:
                stripped =original_text [1 :].strip ()
            try :
                params .message =stripped
            except :
                pass
            return HookResult()


        # Main translation enable logic
        translate_by_default = self.get_setting("translate_by_default", False)
        if command not in ("!on","!off"):
            if translate_by_default:
                # If ON, enable translation for all chats unless explicitly excluded
                if peer_id in self.excluded_chats:
                    log(f"Chat {peer_id} is excluded from default translation.")
                    return HookResult()
            else:
                # Default: only enabled if in enabled_chats
                if peer_id not in self.enabled_chats:
                    return HookResult()

        # --- TRANSLATION TRIGGER ---
        # Only trigger translation if not a command, not filtered out, and chat is enabled (by global or per-chat)
        if not original_text.startswith('!') and not original_text.startswith('/') and not original_text.startswith('.command'):
            if self._is_chat_enabled(peer_obj):
                run_on_ui_thread(lambda: self._show_loading())
                def do_translation():
                    self._perform_translation_and_send(
                        peer_obj,
                        original_text,
                        getattr(params, 'replyToMsg', None),
                        getattr(params, 'replyToTopMsg', None),
                        False
                    )
                run_on_queue(do_translation)
                return HookResult(strategy=HookStrategy.CANCEL)

        if command == '!on':
            self._include_chat(params.peer)
            return HookResult(strategy=HookStrategy.CANCEL)
            
        elif command == '!off':
            self._exclude_chat(params.peer)
            return HookResult(strategy=HookStrategy.CANCEL)

        elif command == '!analytics':
            self._show_analytics_dialog()
            return HookResult(strategy=HookStrategy.CANCEL)
            
        elif command == '!cache':
            self._show_cache_info()
            return HookResult(strategy=HookStrategy.CANCEL)
            
        elif command == '!clearcache':
            self._clear_cache()
            return HookResult(strategy=HookStrategy.CANCEL)

        elif command == '!google':
            self.set_setting("provider", 0)
            run_on_ui_thread(lambda: BulletinHelper.show_success(locali.get_string("SWITCHED_TO_GOOGLE")))
        elif command == '!yandex':
            self.set_setting("provider", 1)
            run_on_ui_thread(lambda: BulletinHelper.show_success(locali.get_string("SWITCHED_TO_YANDEX")))
        elif command == '!deepl':
            self.set_setting("provider", 2)
            run_on_ui_thread(lambda: BulletinHelper.show_success(locali.get_string("SWITCHED_TO_DEEPL")))
            return HookResult(strategy=HookStrategy.CANCEL)

        elif command =='!dry':
            current =self .get_setting ("dry_run_mode",False )
            self .set_setting ("dry_run_mode",not current )
            status ="enabled"if not current else "disabled"
            run_on_ui_thread (lambda :BulletinHelper .show_success (f"Dry run mode {status }"))
            return HookResult (strategy =HookStrategy .CANCEL )

        elif command == '!tl' and len(parts) > 1:
            lang_code = parts[1].lower()
            provider_idx = self.get_setting("provider", 0)
            try:
                provider_idx = int(provider_idx)
            except (TypeError, ValueError):
                provider_idx = 0
            # Use correct language code list for current provider
            if provider_idx == 2:
                code_list = DEEPL_LANG_CODES
                name_list = DEEPL_LANG_NAMES
            else:
                code_list = LANG_CODES
                name_list = LANG_NAMES

            if len(parts) > 2:
                target_lang = lang_code
                text_to_translate = ' '.join(parts[2:]).strip()
                if target_lang in code_list:
                    current_lang_idx = self.get_setting("target_language", 0)
                    target_idx = code_list.index(target_lang)
                    peer = getattr(params, "peer", None)
                    reply_obj = getattr(params, "replyToMsg", None)
                    reply_top_obj = getattr(params, "replyToTopMsg", None)
                    run_on_ui_thread(lambda: self._show_loading())
                    def _do_tl():
                        self.set_setting("target_language", target_idx)
                        # Try to refresh settings UI if open
                        try:
                            frag = get_last_fragment()
                            if frag and hasattr(frag, "reloadSettings"):
                                run_on_ui_thread(lambda: frag.reloadSettings())
                        except Exception as e:
                            log(f"[autoTranslate] Failed to refresh settings UI: {e}")
                        self._perform_translation_and_send(peer, text_to_translate, reply_obj, reply_top_obj, False)
                        self.set_setting("target_language", current_lang_idx)
                    run_on_queue(_do_tl)
                    return HookResult(strategy=HookStrategy.CANCEL)
                else:
                    run_on_ui_thread(lambda: BulletinHelper.show_info("Invalid language code"))
                    return HookResult(strategy=HookStrategy.CANCEL)
            else:
                if lang_code in code_list:
                    idx = code_list.index(lang_code)
                    current_idx = self.get_setting("target_language", 0)
                    if idx == current_idx:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(f"Target language is already {name_list[idx]}"))
                    else:
                        self.set_setting("target_language", idx)
                        # Try to refresh settings UI if open
                        try:
                            frag = get_last_fragment()
                            if frag and hasattr(frag, "reloadSettings"):
                                run_on_ui_thread(lambda: frag.reloadSettings())
                        except Exception as e:
                            log(f"[autoTranslate] Failed to refresh settings UI: {e}")
                        run_on_ui_thread(lambda: BulletinHelper.show_info(f"Target language set to {name_list[idx]}"))
                else:
                    run_on_ui_thread(lambda: BulletinHelper.show_info(
                        "Invalid language code. Use: !tl <code> [text]\n"
                        "Example: !tl es Hello\n"
                        "Or to set default: !tl es"
                    ))
                return HookResult(strategy=HookStrategy.CANCEL)

        elif command =='!ex':
            if len (parts )>1 and parts [1 ].lower ()=='none':
                self .set_setting ("exclude_languages","")
                run_on_ui_thread (lambda :BulletinHelper .show_info ("Cleared all language exclusions"))
            elif len (parts )>1 :
                self .set_setting ("exclude_languages",",".join (parts [1 :]))
                run_on_ui_thread (lambda :BulletinHelper .show_info ("Updated language exclusions"))
            return HookResult (strategy =HookStrategy .CANCEL )

        elif command =='!ai':
            peer =getattr (params ,"peer",None )
            reply_obj =getattr (params ,"replyToMsg",None )
            reply_top_obj =getattr (params ,"replyToTopMsg",None )

            if not self ._is_chat_enabled (peer ):
                return HookResult ()

            run_on_ui_thread (lambda :self ._show_loading ())

            run_on_queue (lambda :self ._handle_ai_command (peer ,original_text ,reply_obj ,reply_top_obj ))
            return HookResult (strategy =HookStrategy .CANCEL )

        elif command =='!dev':
            current =self .get_setting ("dev_mode_enabled",False )
            self .set_setting ("dev_mode_enabled",not current )
            status ="enabled"if not current else "disabled"
            run_on_ui_thread (lambda :BulletinHelper .show_info (f"Developer mode {status }"))
            return HookResult (strategy =HookStrategy .CANCEL )

        elif command == '!errortest':
            try:
                # Intentionally access a non-existent attribute to trigger AttributeError
                self.add_on_update_hook()
            except Exception as e:
                log(f"[ErrorTest] Caught exception: {e}")
                run_on_ui_thread(lambda: BulletinHelper.show_error(str(e)))
            return HookResult(strategy=HookStrategy.CANCEL)

        elif command == '!meme':
            # Unlock Meme Mode in settings
            self.set_setting("meme_mode_unlocked", True)
            # Toggle Meme Mode on/off
            current = self.get_setting("meme_mode", False)
            self.set_setting("meme_mode", not current)
            status = "enabled" if not current else "disabled"
            run_on_ui_thread(lambda: BulletinHelper.show_info(f"Meme Mode {status} and unlocked in settings!"))
            return HookResult(strategy=HookStrategy.CANCEL)

        elif command =='!credits':
            run_on_ui_thread (lambda :self ._show_dev_credits_dialog ())
            return HookResult (strategy =HookStrategy .CANCEL )

        elif command in ('!help','!commands'):
            run_on_ui_thread (lambda :self ._show_help_dialog ())
            return HookResult (strategy =HookStrategy .CANCEL )

        elif command == '!analytics':
            if self.get_setting("enable_analytics", True):
                run_on_ui_thread(lambda: self._show_analytics_dialog())
            else:
                run_on_ui_thread(lambda: BulletinHelper.show_info("Analytics is disabled. Enable it in Advanced Settings."))
            return HookResult(strategy=HookStrategy.CANCEL)

        elif command == '!cache':
            cache_info = f"Cache Status:\n• Cache Size: {len(self.translation_cache)}\n• Cache Timeout: {self.cache_timeout}s\n• Last Cleanup: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(self.last_cache_cleanup))}"
            run_on_ui_thread(lambda: BulletinHelper.show_info(cache_info))
            return HookResult(strategy=HookStrategy.CANCEL)

        elif command == '!export':
            run_on_ui_thread(lambda: self._show_export_dialog())
            return HookResult(strategy=HookStrategy.CANCEL)

        if re .match (r'^https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%\+.~#?&\/=]*)$',original_text ):
            return HookResult ()

        translate_by_default = self.get_setting("translate_by_default", False)
        if translate_by_default:
            # Only skip if chat is explicitly excluded
            if peer_id in self.excluded_chats:
                return HookResult()
        else:
            # Only skip if not enabled
            if not self.get_setting("enable_translator", True) or peer_id not in self.enabled_chats:
                return HookResult()

        # Translation trigger logic (always runs after the above checks)
        if not original_text.startswith('!') and not original_text.startswith('/') and not original_text.startswith('.command'):
            if self._is_chat_enabled(peer):
                self._perform_translation_and_send(
                    peer,
                    original_text,
                    getattr(params, 'replyToMsg', None),
                    getattr(params, 'replyToTopMsg', None),
                    False
                )
                return HookResult(strategy=HookStrategy.CANCEL)

        # Fallback: allow message if not handled
        return HookResult()

    def _open_channel_link(self):
        try:
            from android.content import Intent
            from android.net import Uri
            ctx = ApplicationLoader.applicationContext
            intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://t.me/luvztroyPlugins"))
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            ctx.startActivity(intent)
        except Exception as e:
            log(f"Failed to open channel link: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Unable to open channel link"))

        last_three_str =self .get_setting ("last_three_popup","")
        try :
            last_three =int (last_three_str )
        except :
            last_three =None 
        if last_three is None or current_day_count -last_three >=3 :
            self .set_setting ("last_three_popup",str (current_day_count ))
            try :
                run_on_ui_thread(lambda: BulletinHelper.show_with_button(
    "Join @luvztroyPlugins for updates and news",
    None,  # No icon
    "Join",
    lambda: self._open_channel_link()
))
            except Exception :
                BulletinHelper.show_with_button(
    "Join @luvztroyPlugins for updates and news",
    None,  # No icon
    "Join",
    lambda: self._open_channel_link()
)
        if self .get_setting ("dev_mode_enabled",False ):
            raw_patterns =self .get_setting ("skip_patterns","")
            if raw_patterns .strip ():
                for pat in [p .strip ()for p in raw_patterns .split (",")if p .strip ()]:
                    try :
                        if re .search (pat ,original_text ):
                            if self .verbose_logging :
                                log (f"[SkipRegex] Message skipped by pattern: {pat }")
                            return HookResult ()
                    except re .error :
                        pass 

        # Suggestion/switch bulletin suppression logic
        translate_by_default = self.get_setting("translate_by_default", False)
        peer_id = self._peer_id(peer) if peer else None
        if not translate_by_default:
            # Current behavior: Suggest turning on translation
            if peer_id is not None and peer_id not in self.enabled_chats:
                run_on_ui_thread(lambda: BulletinHelper.show_info(locali.get_string("TRANSLATION_OFF_USE_ON")))

        m_tl_set =re .match (r"^!tl\\s+([a-zA-Z\-]+)$",original_text )
        m_tl_send =re .match (r"^!tl\\s+([a-zA-Z\-]+)\\s+([\\s\\S]+)$",original_text )
        if m_tl_set or m_tl_send :
            code =(m_tl_set or m_tl_send ).group (1 ).lower ()
            if code not in LANG_CODES :
                BulletinHelper .show_info (locali.get_string("UNKNOWN_LANGUAGE_CODE"))
                return HookResult (strategy =HookStrategy .CANCEL )
            if m_tl_set and not m_tl_send :
                idx = LANG_CODES.index(code)
                current_idx = self.get_setting("target_language", 0)
                if code == "en" and idx == current_idx:
                    BulletinHelper .show_info (locali.get_string("TARGET_LANGUAGE_ALREADY_ENGLISH"))
                else:
                    self.set_setting("target_language", idx)
                    run_on_ui_thread(lambda: BulletinHelper.show_info(locali.get_string("TARGET_LANGUAGE_SET").format(LANG_NAMES[idx])))
                return HookResult (strategy =HookStrategy .CANCEL )
            text_to_translate =m_tl_send .group (2 ).strip ()
            if not text_to_translate :
                BulletinHelper .show_info (locali.get_string("NOTHING_TO_TRANSLATE"))
                return HookResult (strategy =HookStrategy .CANCEL )
            translated =self .translate_text (text_to_translate ,code )
            if self .get_setting ("dry_run_mode",False ):
                BulletinHelper .show_success (locali.get_string("TRANSLATION_RESULT").format(translated))
            else :
                peer =getattr (params ,"peer",None )
                reply_obj =getattr (params ,"replyToMsg",None )
                reply_top_obj =getattr (params ,"replyToTopMsg",None )
                self ._send_final_message (peer ,translated ,reply_obj ,reply_top_obj ,keep_in_composer =False )
            return HookResult (strategy =HookStrategy .CANCEL )

        if re .match (r"^!google$",original_text ,flags =re .I ):
            if self .get_setting ("provider",0 )==0 :
                BulletinHelper .show_info (locali.get_string("GOOGLE_ALREADY_ACTIVE"))
            else :
                self .set_setting ("provider",0 )
                BulletinHelper .show_info (locali.get_string("PROVIDER_SET_GOOGLE"))
            return HookResult (strategy =HookStrategy .CANCEL )

        if re .match (r"^!yandex$",original_text ,flags =re .I ):
            if self .get_setting ("provider",0 )==1 :
                BulletinHelper .show_info (locali.get_string("YANDEX_ALREADY_ACTIVE"))
            else :
                self .set_setting ("provider",1 )
                BulletinHelper .show_info (locali.get_string("PROVIDER_SET_YANDEX"))
            return HookResult (strategy =HookStrategy .CANCEL )

        if re .match (r"^!dry$",original_text ,flags =re .I ):
            current_state =self .get_setting ("dry_run_mode",False )
            new_state =not current_state 
            self .set_setting ("dry_run_mode",new_state )
            state_text ="enabled"if new_state else "disabled"
            BulletinHelper .show_success (locali.get_string("DRY_RUN_MODE").format(state_text))
            return HookResult (strategy =HookStrategy .CANCEL )

        if re .match (r"^!(credits|about)$",original_text ,flags =re .I ):
            run_on_ui_thread (lambda :self ._show_dev_credits_dialog ())
            return HookResult (strategy =HookStrategy .CANCEL )

        m_switch =re .match (r"^!switch(?:\s+(\d))?$",original_text ,flags =re .I )
        if m_switch :
            cur_idx =self .get_setting ("or_model_idx",0 )
            if m_switch .group (1 )is not None :
                new_idx =int (m_switch .group (1 ))
            else :
                new_idx =1 -int (cur_idx )
            if new_idx ==cur_idx :
                BulletinHelper .show_info (locali.get_string("MODEL_ALREADY_ACTIVE").format(['gemini-2.0-flash','gemini-2.5-flash'][new_idx]))
            else :
                self .set_setting ("or_model_idx",new_idx )
                BulletinHelper .show_info (locali.get_string("MODEL_SWITCHED").format(['gemini-2.0-flash','gemini-2.5-flash'][new_idx]))
            return HookResult (strategy =HookStrategy .CANCEL )

        if re .match (r"^!ping$",original_text ,flags =re .I ):
            def _ping ():
                try :
                    start_time =time .time ()
                    response =_http .get ("https://www.google.com",timeout =5 )
                    latency =int ((time .time ()-start_time )*1000 )
                    return f"Pong! Latency: {latency }ms"
                except Exception as e :
                    return f"Ping failed: {str (e )}"

            ping_result =_ping ()
            run_on_ui_thread (lambda :BulletinHelper .show_info (ping_result ))
            return HookResult (strategy =HookStrategy .CANCEL )

        if re .match (r"^!dev$",original_text ,flags =re .I ):
            dev =self .get_setting ("dev_mode_enabled",False )
            self .set_setting ("dev_mode_enabled",not dev )
            state_msg ="Developer mode enabled"if not dev else "Developer mode disabled"
            try :
                run_on_ui_thread (lambda :BulletinHelper .show_success (locali.get_string("DEVELOPER_MODE").format(state_msg)))
            except Exception :
                BulletinHelper .show_info (locali.get_string("DEVELOPER_MODE").format(state_msg))
            return HookResult (strategy =HookStrategy .CANCEL )

        keep_in_composer =False 

        if original_text .startswith ('!ai'):
            peer =getattr (params ,"peer",None )
            reply_obj =getattr (params ,"replyToMsg",None )
            reply_top_obj =getattr (params ,"replyToTopMsg",None )

            if not self ._is_chat_enabled (peer ):
                return HookResult ()

            run_on_ui_thread (lambda :self ._show_loading ())

            run_on_queue (lambda :self ._handle_ai_command (peer ,original_text ,reply_obj ,reply_top_obj ))
            return HookResult (strategy =HookStrategy .CANCEL )

        if bypass_commands and (original_text.startswith("/") or original_text.startswith("!") or original_text.startswith(".")):
            # Allow !tl, !ex, !on, !off, !google, !yandex as exceptions
            if original_text.startswith("!") and re.match(r"^!(tl|ex|on|off|google|yandex)\b", original_text, flags=re.I):
                pass
            else:
                # For all dot and slash commands, bypass translation entirely
                if original_text.startswith("/") or original_text.startswith("."):
                    return HookResult()

                # For ! commands not in the exception list, send as-is (without the !)
                cleaned_text = original_text[1:].lstrip()
                if not cleaned_text:
                    return HookResult()

                peer = getattr(params, "peer", None)
                reply_obj = getattr(params, "replyToMsg", None)
                reply_top_obj = getattr(params, "replyToTopMsg", None)

                def _send_bypass():
                    self.is_sending_translated = True
                    payload = {"peer": peer, "message": cleaned_text}
                    if reply_obj is not None:
                        payload["replyToMsg"] = reply_obj
                    if reply_top_obj is not None:
                        payload["replyToTopMsg"] = reply_top_obj
                    send_message(payload)

                run_on_queue(_send_bypass)
                return HookResult(strategy=HookStrategy.CANCEL)

        try :
            if not ApplicationLoader .isNetworkOnline ():
                BulletinHelper .show_error (locali.get_string("NO_INTERNET_CONNECTION"))
                return HookResult (strategy =HookStrategy .CANCEL )
        except Exception as e :
            log (f"network check error: {e }")

        peer =getattr (params ,"peer",None )
        if not self ._is_chat_enabled (peer ):
            return HookResult ()
        


        try :
            current_fragment =get_last_fragment ()
            if not current_fragment or not current_fragment .getParentActivity ():
                log ("autoTranslate: Could not get context to show dialog.")
                return HookResult (strategy =HookStrategy .CANCEL )

            if not keep_in_composer :
                if hasattr (self ,'progress_dialog')and self .progress_dialog :
                    self ._dismiss_spinner ()
                self .progress_dialog =AlertDialog (current_fragment .getParentActivity (),3 )
                self .progress_dialog .show ()

            # Only show spinner if grammar or meme mode is enabled
            show_spinner = False
            if self.get_setting("grammar_check", False) and self._is_chat_enabled(peer):
                show_spinner = True
            if self.get_setting("meme_mode", False) and self._is_chat_enabled(peer):
                show_spinner = True

            if show_spinner:
                self.progress_dialog = self._show_progress_dialog("Translating...")
            else:
                self.progress_dialog = None

            self.is_sending_translated = True

            reply_obj = getattr(params, "replyToMsg", None)
            reply_top_obj = getattr(params, "replyToTopMsg", None)
            run_on_queue(lambda: self._perform_translation_and_send(peer, original_text, reply_obj, reply_top_obj, keep_in_composer))

            return HookResult(strategy=HookStrategy.CANCEL)

        except Exception as e :
            log (f"autoTranslate plugin error: {str (e )}")
            if self .progress_dialog :
                run_on_ui_thread (lambda :self .progress_dialog .dismiss ())
                self .progress_dialog =None 
            return HookResult ()

    
    
    def _perform_translation_and_send(self, peer, original_text, reply_obj, reply_top_obj, keep_in_composer=False):
        # Only run meme mode if translation is enabled for this chat
        if self.get_setting("meme_mode", False):
            if not self._is_chat_enabled(peer):
                log("[MemeMode] Skipped: Translation is not enabled for this chat.")
                self._send_final_message(peer, original_text, reply_obj, reply_top_obj, keep_in_composer)
                return
            original_grammar_setting = self.get_setting("grammar_check", False)
            self.set_setting("grammar_check", False)
            try:
                translated_text = self._translate_to_meme(original_text)
                if not translated_text or translated_text == original_text:
                    translated_text = original_text
                self._send_final_message(peer, translated_text, reply_obj, reply_top_obj, keep_in_composer)
                return
            finally:
                self.set_setting("grammar_check", original_grammar_setting)

        # Grammar check logic: only run if enabled and meme_mode is off
        # Only run grammar check if translation is enabled for this chat
        if self._is_chat_enabled(peer):
            grammar_check_enabled = self.get_setting("grammar_check", False)
            if grammar_check_enabled:
                try:
                    corrected_text = self._grammar_check_text(original_text)
                    if corrected_text and corrected_text.strip() != original_text.strip():
                        log(f"[GrammarCheck] Correction applied: '{original_text}' -> '{corrected_text}'")
                        original_text = corrected_text
                    else:
                        log(f"[GrammarCheck] No correction applied or identical result.")
                except Exception as e:
                    log(f"[GrammarCheck] Error: {e}")
                    # fallback to original text
        else:
            log("[GrammarCheck] Skipped: Translation is not enabled for this chat.")

        # Per-chat language override
        peer_id = self._peer_id(peer)
        lang_code = self.chat_target_languages.get(str(peer_id))
        if lang_code:
            target_lang = lang_code
        else:
            lang_index = self.get_setting("target_language", 0)
            if not 0 <= lang_index < len(LANG_CODES):
                lang_index = 0
                self.set_setting("target_language", 0)
            target_lang = LANG_CODES[lang_index]

        raw_excl = self.get_setting("exclude_languages", "")
        exclude_list = [c for c in raw_excl.split(',') if c]
        if exclude_list:
            try:
                if any(self._should_skip_language(original_text, code) for code in exclude_list):
                    self._send_final_message(peer, original_text, reply_obj, reply_top_obj, keep_in_composer)
                    return
            except Exception as e:
                log(f"Error checking excluded language list: {str(e)}")

        masked_text, placeholders = self._mask_excluded_words(original_text)
        translated_text = self.translate_text(masked_text, target_lang)

        if not translated_text:
            translated_text = original_text

        if placeholders:
            translated_text = self._restore_excluded_words(translated_text, placeholders)

        translated_text = self._preserve_case_pattern(original_text, translated_text)

        orig_trim = original_text.rstrip()
        fin_trim = translated_text.rstrip()
        if orig_trim.endswith("...") and not fin_trim.endswith("..."):
            translated_text = translated_text + "..."
        elif orig_trim.endswith("…") and not fin_trim.endswith("…"):
            translated_text = translated_text + "…"

        self._send_final_message(peer, translated_text, reply_obj, reply_top_obj, keep_in_composer)

    def _send_final_message (self ,peer ,text ,reply_obj =None ,reply_top_obj =None ,keep_in_composer =False ):
        def _ui_task ():
            if self .progress_dialog :
                self .progress_dialog .dismiss ()
                self .progress_dialog =None 

            if text :
                self .is_sending_translated =True 
                try :
                    if self .get_setting ("dry_run_mode",False ):
                        self._show_copyable_bulletin(text)
                        self.is_sending_translated = False
                    else :
                        payload ={"peer":peer ,"message":text }
                        if reply_obj is not None :
                            payload ["replyToMsg"]=reply_obj 
                        if reply_top_obj is not None :
                            payload ["replyToTopMsg"]=reply_top_obj 

                        send_message (payload )
                finally :


                    if self.get_setting("dry_run_mode", False):
                        self.is_sending_translated = False
            else :
                error_dialog =AlertDialogBuilder ()
                error_dialog .set_title ("Error")
                error_dialog .set_message (locali .get_string ("TRANSLATION_ERROR"))
                error_dialog .set_positive_button ("OK",None )
                error_dialog .show ()

        run_on_ui_thread (_ui_task )

    def detect_language (self ,text ):
        try :
            params ={'client':'gtx','sl':'auto','tl':'en','dt':'t','q':text }
            response =_http .get (TRANSLATE_API_URL ,params =params ,timeout =5 )
            if response .status_code ==200 :
                return response .json ()[2 ]
        except Exception as e :
            log (f"Language detection failed: {str (e )}")
        return None 

    def _show_ai_status (self ,message ,is_error =False ):
        try :
            if is_error :
                run_on_ui_thread (lambda :BulletinHelper .show_error (message ))
            else :
                run_on_ui_thread (lambda :BulletinHelper .show_info (message ))
        except Exception as e :
            log (f"Failed to show AI status: {e }")

    def _is_chat_enabled(self, peer):
        if not peer:
            return False
        try:
            peer_id = self._peer_id(peer)
            if peer_id is None:
                return False
            if self.get_setting("translate_by_default", False):
                return peer_id not in self.excluded_chats
            else:
                return peer_id in self.enabled_chats
        except (ValueError, TypeError):
            return False

    def _grammar_check_text(self, text: str) -> str:
        """
        Run grammar correction on text using the selected AI provider and model (Gemini, then Phoenix fallback).
        Only runs if grammar_check is enabled, meme_mode is off, and text is not empty/too long.
        """
        if not text or not self.get_setting("grammar_check", False):
            log(f"[GrammarCheck] Skipped - text empty or grammar check disabled")
            return text
        if len(text) > 300:
            log(f"[GrammarCheck] Skipped - text too long ({len(text)} chars)")
            return text

        provider = self.get_setting("provider", 0)
        lang_idx = self.get_setting("target_language", 0)
        if provider == 2:  # DeepL
            lang_list = DEEPL_LANG_NAMES
        else:
            lang_list = LANG_NAMES
        target_lang_name = lang_list[lang_idx] if 0 <= lang_idx < len(lang_list) else lang_list[0]
        detected_lang = self.detect_language(text)
        source_lang_name = "Unknown"
        if detected_lang:
            try:
                source_lang_idx = LANG_CODES.index(detected_lang)
                source_lang_name = LANG_NAMES[source_lang_idx]
            except ValueError:
                source_lang_name = detected_lang.upper()

        # Try Gemini API first
        try:
            api_key = self.get_setting("or_gemini_api_key", "").strip()
            if api_key:
                model_idx = self.get_setting("or_model_idx", 0)
                model = GEMINI_MODELS[model_idx] if 0 <= model_idx < len(GEMINI_MODELS) else GEMINI_MODELS[0]
                headers = {"Content-Type": "application/json"}
                system_content = (
                    f"You are a grammar correction expert. Fix any grammar, spelling, punctuation, and capitalization errors in the given text.\n\n"
                    f"IMPORTANT: The text appears to be in {source_lang_name}, but you should ONLY fix grammar according to {target_lang_name} rules.\n\n"
                    f"Rules:\n"
                    f"- Fix incorrect verb tenses, subject-verb agreement, and sentence structure according to {target_lang_name} grammar\n"
                    f"- Correct spelling mistakes and typos for {target_lang_name}\n"
                    f"- Fix punctuation (commas, periods, apostrophes, etc.) according to {target_lang_name} standards\n"
                    f"- Properly capitalize sentences and proper nouns according to {target_lang_name} rules\n"
                    f"- Preserve all emojis, formatting, and the original meaning\n"
                    f"- Keep the same tone and style\n"
                    f"- Return ONLY the corrected text, no explanations\n"
                    f"- Don't add any additional commentary or anything\n"
                    f"- If the text has emoji don't remove them\n"
                    f"- If the message was just . or / don't add anything to that\n"
                    f"- DO NOT ADD ANY EMOJIS - only preserve existing ones\n"
                    f"- DO NOT ADD ANY DECORATIVE ELEMENTS\n"
                    f"- Return exactly the same text with only grammar/spelling corrections\n"
                    f"- Preserve @mentions and #hashtags exactly as they are\n"
                    f"- Do not modify usernames, links, or special formatting\n"
                    f"- DO NOT REMOVE '..' (double dots) if the text contains them\n"
                    f"- DO NOT apply {source_lang_name} grammar rules - only use {target_lang_name} grammar rules\n"
                    f"- DO NOT fix grammar if the text starts with a dot followed by text (e.g., .now, .message, .text, .command) - return the text exactly as is\n\n"
                    f"Target Language: {target_lang_name}\n"
                    f"Detected Source Language: {source_lang_name}"
                )
                payload = {
                    "contents": [
                        {"role": "user", "parts": [{"text": system_content + "\n\nText to correct: " + text}]}
                    ],
                    "generationConfig": {"temperature": 0.0, "maxOutputTokens": 200, "topP": 1.0, "topK": 0}
                }
                url = GEMINI_API_URL_TEMPLATE.format(model=model) + f"?key={api_key}"
                resp = _http.post(url, json=payload, headers=headers, timeout=5)
                resp.raise_for_status()
                data = resp.json()
                if "candidates" in data and data["candidates"]:
                    corrected = data["candidates"][0]["content"]["parts"][0]["text"]
                    if corrected and corrected.strip() != text.strip():
                        log(f"[GrammarCheck] Gemini Corrected: '{text}' -> '{corrected}'")
                        return corrected
                    else:
                        log(f"[GrammarCheck] Gemini no correction, will try Phoenix fallback.")
            else:
                log(f"[GrammarCheck] Skipped Gemini - no Gemini API key")
        except Exception as e:
            log(f"[GrammarCheck] Gemini error: {e}")

        # Phoenix fallback
        try:
            api_key = self.get_setting("phoenix_api_key", "").strip()
            if api_key:
                model_idx = self.get_setting("phoenix_model_idx", 0)
                model = PHOENIX_MODELS[model_idx] if 0 <= model_idx < len(PHOENIX_MODELS) else PHOENIX_MODELS[0]
                headers = {"Content-Type": "application/json", "Authorization": f"Bearer {api_key}"}
                system_content = (
                    f"You are a grammar correction expert. Fix any grammar, spelling, punctuation, and capitalization errors in the given text.\n\n"
                    f"IMPORTANT: The text appears to be in {source_lang_name}, but you should ONLY fix grammar according to {target_lang_name} rules.\n\n"
                    f"Rules:\n"
                    f"- Fix incorrect verb tenses, subject-verb agreement, and sentence structure according to {target_lang_name} grammar\n"
                    f"- Correct spelling mistakes and typos for {target_lang_name}\n"
                    f"- Fix punctuation (commas, periods, apostrophes, etc.) according to {target_lang_name} standards\n"
                    f"- Properly capitalize sentences and proper nouns according to {target_lang_name} rules\n"
                    f"- Preserve all emojis, formatting, and the original meaning\n"
                    f"- Keep the same tone and style\n"
                    f"- Return ONLY the corrected text, no explanations\n"
                    f"- Don't add any additional commentary or anything\n"
                    f"- If the text has emoji don't remove them\n"
                    f"- If the message was just . or / don't add anything to that\n"
                    f"- DO NOT ADD ANY EMOJIS - only preserve existing ones\n"
                    f"- DO NOT ADD ANY DECORATIVE ELEMENTS\n"
                    f"- Return exactly the same text with only grammar/spelling corrections\n"
                    f"- Preserve @mentions and #hashtags exactly as they are\n"
                    f"- Do not modify usernames, links, or special formatting\n"
                    f"- DO NOT REMOVE '..' (double dots) if the text contains them\n"
                    f"- DO NOT change case: if text is fully UPPERCASE keep it UPPERCASE, if text is lowercase keep it lowercase\n"
                    f"- DO NOT apply {source_lang_name} grammar rules - only use {target_lang_name} grammar rules\n"
                    f"- DO NOT fix grammar if the text starts with a dot followed by text (e.g., .now, .message, .text, .command) - return the text exactly as is\n\n"
                    f"Target Language: {target_lang_name}\n"
                    f"Detected Source Language: {source_lang_name}"
                )
                payload = {
                    "model": model,
                    "messages": [
                        {"role": "system", "content": system_content},
                        {"role": "user", "content": text}
                    ],
                    "temperature": 0.0,
                    "max_tokens": 200
                }
                resp = _http.post(PHOENIX_API_URL, json=payload, headers=headers, timeout=5)
                resp.raise_for_status()
                data = resp.json()
                if "choices" in data and data["choices"]:
                    corrected = data["choices"][0]["message"]["content"]
                    if corrected and corrected.strip() != text.strip():
                        log(f"[GrammarCheck] Phoenix Corrected: '{text}' -> '{corrected}'")
                        return corrected
                    else:
                        log(f"[GrammarCheck] Phoenix no correction.")
            else:
                log(f"[GrammarCheck] Skipped Phoenix - no Phoenix API key")
        except Exception as e:
            log(f"[GrammarCheck] Phoenix error: {e}")
        return text

    def _show_translator_status_bulletin (self ,peer ):
        try :
            log ("_show_translator_status_bulletin called")

            from org .telegram .messenger .AndroidUtilities import runOnUIThread 
            from org .telegram .ui .Components .Bulletin import Bulletin 
            from org .telegram .ui .Components .BulletinFactory import of as bulletinFactoryOf 

            def show_bulletin ():
                try :
                    current_fragment =get_last_fragment ()
                    if not current_fragment :
                        log ("No active fragment found")
                        return 

                    target_lang_index =self .get_setting ("target_language",0 )
                    target_lang =LANG_NAMES [target_lang_index ]if 0 <=target_lang_index <len (LANG_NAMES )else "English"

                    is_enabled =self ._is_chat_enabled (peer )
                    status_text =f"Auto-Translate: {'ON'if is_enabled else 'OFF'}\nTarget: {target_lang }"

                    factory =bulletinFactoryOf (current_fragment )
                    if factory :
                        bulletin =factory .createSimpleBulletin (
                        0 ,
                        status_text 
                        )
                        bulletin .show ()
                        log ("Bulletin shown successfully")
                    else :
                        log ("Failed to create bulletin factory")

                except Exception as e :
                    log (f"Error in show_bulletin: {e }")

            runOnUIThread (show_bulletin )

        except Exception as e :
            log (f"Error in _show_translator_status_bulletin: {e }")

    def _translate_plain_text (self ,plain_text ,target_lang ):
        encoded_text ,emoji_map =self ._encode_emojis_as_html (plain_text )

        if not re .search (r"\w",encoded_text ,flags =re .UNICODE ):
            return plain_text 

        cached =self .get_cached_translation (encoded_text ,target_lang )
        if cached :
            return self ._decode_emojis_from_html (cached ,emoji_map )

        translated =self ._perform_external_translation (encoded_text ,target_lang )
        if translated :
            self .cache_translation (encoded_text ,target_lang ,translated )
            return self ._decode_emojis_from_html (translated ,emoji_map )

        return self ._decode_emojis_from_html (encoded_text ,emoji_map )


    def _perform_external_translation (self ,text_to_translate ,target_lang ):
        plain_text =text_to_translate  

        provider_index =self .get_setting ("provider",0 )
        try:
            provider_index = int(provider_index)
        except (TypeError, ValueError):
            provider_index = 0
        providers = ["google", "yandex", "deepl"]
        provider = providers[provider_index] if provider_index in range(len(providers)) else "yandex"
        log(f"Using provider: {provider}")
        log(f"_perform_external_translation: text_to_translate='{plain_text}', target_lang='{target_lang}'")

        if target_lang == "hi-hinglish":
            return self._translate_to_hinglish_ai(plain_text)

        if provider == "yandex":
            return self.translate_with_yandex(plain_text, target_lang)
        elif provider == "deepl":
            return self._translate_with_deepl(plain_text, target_lang)

        else :
            try :

                encoded_text, emoji_map = self._encode_emojis_as_html(plain_text)
                params = {
                    'client': 'gtx',
                    'sl': 'auto',
                    'tl': target_lang,
                    'dt': 't',
                    'q': encoded_text
                }
                response = _http.get(TRANSLATE_API_URL, params=params, timeout=3)
                if response.status_code == 200:
                    result = response.json()
                    if result and isinstance(result, list) and result[0] and isinstance(result[0], list):
                        translation = "".join(seg[0] for seg in result[0] if isinstance(seg, list) and seg and isinstance(seg[0], str))
                        if translation.strip().lower() != plain_text.strip().lower():
                            return self._decode_emojis_from_html(translation, emoji_map)
                return None
            except Exception as e:
                log(f"_perform_external_translation: Google failed: {e}")
                return None

    def _translate_to_hinglish_ai(self, text):
        """Use AI to translate text to Hinglish (Hindi in Roman script)"""
        if not text or not text.strip():
            log("[HinglishAI] Empty text provided")
            return None
            
        # Check if text should be excluded from translation (e.g., commands starting with .)
        if text.lstrip().startswith('.'):
            log(f"[HinglishAI] Command detected, skipping translation: {text}")
            return None
            
        # Try Gemini first if API key is available
        gemini_result = self._try_gemini_translation(text)
        if gemini_result:
            return gemini_result
            
        # Fall back to Phoenix if Gemini fails or no API key
        phoenix_result = self._try_phoenix_translation(text)
        if phoenix_result:
            return phoenix_result
            
        log("[HinglishAI] All translation attempts failed")
        return None
        
    def _try_gemini_translation(self, text):
        """Attempt translation using Gemini API"""
        try:
            api_key = self.get_setting("or_gemini_api_key", "").strip()
            if not api_key:
                log("[HinglishAI] Gemini API key not found")
                return None
                
            model_idx = self.get_setting("or_model_idx", 0)
            model = GEMINI_MODELS[model_idx] if 0 <= model_idx < len(GEMINI_MODELS) else GEMINI_MODELS[0]
            
            system_content = (
                """
1. **MANDATORY FULL TRANSLATION TO HINGLISH (NO EXCEPTIONS):**
- Translate EVERY word into casual, conversational Hinglish (Hindi in Roman script).
- Use common Hinglish grammar, contractions, and idioms — NOT formal Hindi.
- DO NOT confuse Hinglish words like 'haan' (yes) with English words like 'have' — use contextual understanding.
- If a word isn't easily translatable, write it phonetically in Roman Hindi.
- English words are NOT allowed unless they're proper nouns, technical terms, or can't be translated naturally.

2. **STRICT PRESERVATION RULES — NEVER TOUCH THESE:**
- Emojis 😎, line breaks, spacing
- @mentions, #hashtags, and URLs
- Special characters (!, %, &, etc.), numbers (123)
- Text starting with a dot (e.g., .command)
- Proper nouns and names (e.g., John, Mumbai, Instagram)

3. **STYLE & FLAVOR REQUIREMENTS:**
- Keep tone casual, like everyday chat.
- Use familiar phrases like: 'kya scene h?', 'mast h', 'bhai', 'yaar', 'abey', 'kyun', etc.
- Always use short forms like 'h' for 'hai', 'k' for 'ki', 'nahi' for 'not', etc.
- Use 'main', 'tu/tum', 'mera/meri', 'ka/kya/kahan', etc. — not 'I', 'you', etc.

4. **TRANSLATION EXAMPLES — FOLLOW THESE FORMATS:**
"Are you free today?" → "Tu aaj free h?"
"I love this!" → "Mujhe ye bahut pasand h!"
"Where are you going?" → "Tu kahan ja raha h?"
"@rohan Let's play now!" → "@rohan abhi khelte h!"
"I don't know why" → "Mujhe nahi pata kyun"
"This phone is awesome 🔥" → "Ye phone mast h 🔥"
"John is calling me" → "John mujhe call kar raha h"

5. **OUTPUT RULES — FINAL FORMAT:**
- Output ONLY the final translated Hinglish text
- DO NOT explain anything
- DO NOT use any English word unless it's a proper noun or untranslatable term
- DO NOT alter the structure of preserved elements (like emojis, @, #, links, etc.)
                """
            )

            
            payload = {
                "contents": [
                    {"role": "user", "parts": [
                        {"text": system_content},
                        {"text": f"\n\nTranslate this ENTIRE text to Hinglish. DO NOT leave any part in English. Return ONLY the translation.\n\nText: {text}"}
                    ]}
                ],
                "generationConfig": {
                    "temperature": 0.3, 
                    "maxOutputTokens": 200, 
                    "topP": 0.95, 
                    "topK": 40
                },
                "safetySettings": [
                    {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
                    {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
                    {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
                    {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
                ]
            }
            
            url = GEMINI_API_URL_TEMPLATE.format(model=model) + f"?key={api_key}"
            resp = _http.post(url, json=payload, headers={"Content-Type": "application/json"}, timeout=10)
            resp.raise_for_status()
            data = resp.json()
            
            # Try different response formats
            if "candidates" in data and data["candidates"] and "content" in data["candidates"][0]:
                parts = data["candidates"][0]["content"].get("parts", [])
                if parts and "text" in parts[0]:
                    hinglish = parts[0]["text"].strip()
                    if hinglish:
                        log(f"[HinglishAI] Gemini: '{text}' -> '{hinglish}'")
                        return hinglish
            
            log(f"[HinglishAI] Gemini: Unexpected response format: {data}")
            return None
            
        except Exception as e:
            log(f"[HinglishAI] Gemini error: {str(e)}")
            return None
    
    def _try_phoenix_translation(self, text):
        """Fallback translation using Phoenix API"""
        try:
            api_key = self.get_setting("phoenix_api_key", "").strip()
            if not api_key:
                log("[HinglishAI] Phoenix API key not found")
                return None
                
            model_idx = self.get_setting("phoenix_model_idx", 0)
            model = PHOENIX_MODELS[model_idx] if 0 <= model_idx < len(PHOENIX_MODELS) else PHOENIX_MODELS[0]
            
            system_content = """You are a Hinglish translation expert. Convert the given text to Hinglish (Hindi written in Roman script).

Rules:
- Translate the text to Hindi first, then convert it to Roman script
- Use common Hinglish transliteration patterns
- Preserve the original meaning and tone
- Keep emojis and formatting intact
- Use natural Hinglish expressions that sound natural to Hindi speakers
- Return ONLY the Hinglish text, no explanations
- Don't add any additional commentary
- Preserve @mentions and #hashtags exactly as they are
- Do not modify usernames, links, or special formatting
- If the text starts with a dot followed by text (e.g., .now, .message), return the text exactly as is

Example conversions:
- "Hello, how are you?" → "Hello, kaise ho aap?"
- "I am going to the market" → "Main market ja raha hun"
- "This is very good" → "Ye bahut accha hai"
- "Thank you" → "Dhanyawad" or "Shukriya"

Target: Hinglish (Hindi in Roman script)"""
            
            payload = {
                "model": model,
                "messages": [
                    {"role": "system", "content": system_content},
                    {"role": "user", "content": text}
                ],
                "temperature": 0.3,
                "max_tokens": 200,
                "top_p": 0.95,
                "frequency_penalty": 0,
                "presence_penalty": 0
            }
            
            resp = _http.post(PHOENIX_API_URL, 
                           json=payload, 
                           headers={"Content-Type": "application/json", "Authorization": f"Bearer {api_key}"}, 
                           timeout=10)
            resp.raise_for_status()
            data = resp.json()
            
            # Try different response formats
            if "choices" in data and data["choices"]:
                message = data["choices"][0].get("message", {})
                if "content" in message:
                    hinglish = message["content"].strip()
                    if hinglish:
                        log(f"[HinglishAI] Phoenix: '{text}' -> '{hinglish}'")
                        return hinglish
            
            log(f"[HinglishAI] Phoenix: Unexpected response format: {data}")
            return None
            
        except Exception as e:
            log(f"[HinglishAI] Phoenix error: {str(e)}")
            return None

    def _should_skip_language (self ,text ,exclude_lang ):
        try :
            detected =self .detect_language (text )
            if detected ==exclude_lang :
                return True 
        except Exception :
            pass 
        script_ranges ={
        'ru':(0x0400 ,0x04FF ),
        'uk':(0x0400 ,0x04FF ),
        'bg':(0x0400 ,0x04FF ),
        'el':(0x0370 ,0x03FF ),
        'ar':(0x0600 ,0x06FF ),
        'he':(0x0590 ,0x05FF ),
        'hi':(0x0900 ,0x097F ),
        'ja':(0x3040 ,0x30FF ),
        'ko':(0xAC00 ,0xD7AF ),
        'zh':(0x4E00 ,0x9FFF ),
        }
        rng =script_ranges .get (exclude_lang )
        if rng :
            start ,end =rng 
            for ch in text :
                if start <=ord (ch )<=end :
                    return True 
        return False 

    def translate_with_yandex (self ,text ,target_lang ):
        import uuid 
        import urllib .parse 
        YA_URL ="https://translate.yandex.net/api/v1/tr.json/translate"
        session_uuid =str (uuid .uuid4 ()).replace ("-","")
        to_lang =target_lang .lower ()
        sanitized_text ,emojis =self ._encode_emojis_as_html (text )

        data =f"lang={to_lang }&text={urllib .parse .quote (sanitized_text )}"
        headers ={
        "User-Agent":"ru.yandex.translate/21.15.4.21402814 (Xiaomi Redmi K20 Pro; Android 11)",
        "Content-Type":"application/x-www-form-urlencoded"
        }
        url =f"{YA_URL }?id={session_uuid }-0-0&srv=android"
        try :
            response =_http .post (url ,data =data ,headers =headers ,timeout =3 )
            if response .status_code ==200 :
                obj =response .json ()
                if "text"in obj :
                    translated ="".join (obj ["text"])
                    translated =self ._decode_emojis_from_html (translated ,emojis )
                    return translated 
            return None 
        except Exception as e :
            log (f"Yandex translation failed: {str (e )}")
            return None 

    def _peer_id (self ,peer ):
        if peer is None :
            return None 
        if isinstance (peer ,int ):
            return peer 
        try :
            return int (peer .getId ())if hasattr (peer ,'getId')else int (peer .id )
        except Exception :
            try :
                return int (str (peer ))
            except Exception :
                return None 

    def _save_excluded (self ):
        try :
            raw =",".join (str (x )for x in self .excluded_chats )
            self.set_setting("excluded_chats", raw)
        except Exception as e :
            log (f"enable chat error: {e }")

    def _disable_chat (self ,peer ):
        try :
            peer_id =ChatUtils .getPeerId (peer )
            if peer_id not in self .enabled_chats :
                BulletinHelper .show_info ("Auto-translate is already disabled in this chat")
                return 
            self .enabled_chats .remove (peer_id )
            self ._save_enabled ()
            BulletinHelper .show_info ("Auto-translate disabled in this chat")
        except Exception as e :
            log (f"disable chat error: {e }")


    # _toggle_enabled and enable_translator logic removed. Use only global 'translate_by_default' toggle and per-chat methods.



    def _include_chat(self, peer):
        try:
            pid = self._peer_id(peer)
            if pid is None:
                return
            if pid in self.enabled_chats:
                run_on_ui_thread(lambda: BulletinHelper.show_success(locali.get_string("STATUS_ALREADY_ENABLED")))
                return
            self.enabled_chats.add(pid)
            # Remove from excluded_chats if present
            if pid in self.excluded_chats:
                self.excluded_chats.discard(pid)
                self._save_excluded()
            self._save_enabled()  # Persist immediately
            run_on_ui_thread(lambda: BulletinHelper.show_success(locali.get_string("STATUS_ENABLED")))
        except Exception as e:
            log(f"Include chat error: {e}")

    def _save_enabled(self):
        try:
            raw = ",".join(str(int(x)) for x in self.enabled_chats)
            self.set_setting("enabled_chats", raw)
        except Exception as e:
            log(f"Save enabled error: {e}")

    def _load_enabled(self):
        try:
            raw = self.get_setting("enabled_chats", "")
            if raw.strip():
                self.enabled_chats = set(int(x) for x in raw.split(',') if x.strip())
            else:
                self.enabled_chats = set()
            log(f"Loaded {len(self.enabled_chats)} enabled chats from settings")
        except Exception as e:
            log(f"Failed to load enabled chats: {e}")
            self.enabled_chats = set()

    def _load_excluded(self):
        try:
            raw = self.get_setting("excluded_chats", "")
            if raw.strip():
                self.excluded_chats = set(int(x) for x in raw.split(',') if x.strip())
            else:
                self.excluded_chats = set()
            log(f"Loaded {len(self.excluded_chats)} excluded chats from settings")
        except Exception as e:
            log(f"Failed to load excluded chats: {e}")
            self.excluded_chats = set()

 
            log(f"Loaded {len(self.enabled_chats)} enabled chats from settings")
        except Exception as e:
            log(f"Failed to load enabled chats: {e}")
            self.enabled_chats = set()

    def _exclude_chat(self, peer):
        try:
            pid = self._peer_id(peer)
            if pid is None:
                return
            # For translate_by_default, add to excluded_chats
            if self.get_setting("translate_by_default", False):
                if pid in self.excluded_chats:
                    run_on_ui_thread(lambda: BulletinHelper.show_info(locali.get_string("STATUS_ALREADY_DISABLED")))
                    return
                self.excluded_chats.add(pid)
                self._save_excluded()
                run_on_ui_thread(lambda: BulletinHelper.show_error(locali.get_string("STATUS_DISABLED_EXCLUDED")))
                return
            # Otherwise, remove from enabled_chats
            if pid not in self.enabled_chats:
                run_on_ui_thread(lambda: BulletinHelper.show_info(locali.get_string("STATUS_ALREADY_DISABLED")))
                return
            self.enabled_chats.discard(pid)
            self._save_enabled()  # Persist immediately
            run_on_ui_thread(lambda: BulletinHelper.show_error(locali.get_string("STATUS_DISABLED")))
        except Exception as e:
            log(f"Exclude chat error: {e}")

    def _show_cache_info(self, view=None):
        """Show information about the translation cache."""
        try:
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            
            # Count valid (non-expired) cache entries
            current_time = time.time()
            valid_entries = 0
            for _, (_, timestamp) in self.translation_cache.items():
                if current_time - timestamp < self.cache_timeout:
                    valid_entries += 1
            
            # Convert seconds to human-readable format
            cache_timeout_sec = self.cache_timeout
            if cache_timeout_sec < 60:
                timeout_str = f"{cache_timeout_sec} seconds"
            elif cache_timeout_sec < 3600:
                minutes = cache_timeout_sec // 60
                timeout_str = f"{minutes} minute{'s' if minutes != 1 else ''}"
            elif cache_timeout_sec < 86400:
                hours = cache_timeout_sec // 3600
                timeout_str = f"{hours} hour{'s' if hours != 1 else ''}"
            else:
                days = cache_timeout_sec // 86400
                if days == 7:
                    timeout_str = "1 week"
                elif days < 7:
                    timeout_str = f"{days} day{'s' if days != 1 else ''}"
                else:
                    weeks = days // 7
                    timeout_str = f"{weeks} week{'s' if weeks != 1 else ''}"
            
            cache_info = (
                f"🔄 Translation Cache Info\n\n"
                f"• Total entries: {len(self.translation_cache)}\n"
                f"• Valid entries: {valid_entries}\n"
                f"• Cache timeout: {timeout_str} ({self.cache_timeout} seconds)\n"
                f"• Last cleaned: {time.ctime(self.last_cache_cleanup)}\n\n"
                "Use !clearcache to clear all cached translations."
            )
            
            builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
            builder.set_title("Translation Cache")
            builder.set_message(cache_info)
            builder.set_positive_button("Clear Cache", lambda d, w: self._clear_cache())
            builder.set_negative_button("Close", None)
            builder.show()
            
        except Exception as e:
            log(f"Error showing cache info: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Failed to show cache info"))
    
    def _clear_cache(self):
        """Clear all cached translations."""
        try:
            cache_size = len(self.translation_cache)
            self.translation_cache = {}
            self._save_cache_to_storage()
            run_on_ui_thread(lambda: BulletinHelper.show_info(f"Cleared {cache_size} cached translations"))
        except Exception as e:
            log(f"Error clearing cache: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Failed to clear cache"))
    
    def _show_help_dialog(self, view=None):
        try:
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext

            builder =AlertDialogBuilder (ctx ,AlertDialogBuilder .ALERT_TYPE_MESSAGE )

            help_text =(
            "Auto Translate Plugin — Commands\n\n"
            "BASIC\n\n"
            "!on — Enable translation for this chat\n"
            "!off — Disable translation for this chat\n"
            "\nPROVIDER\n\n"
            "!google — Switch to Google Translate\n"
            "!yandex — Switch to Yandex Translate\n"
            "!deepl — Switch to DeepL Translate\n"
            "!dry — Toggle dry run mode (shows translation as popup only)\n"
            "\nLANGUAGE & CHAT\n\n"
            "!tl <lang_code> <text> — Translate <text> to <lang_code> (e.g. !tl es Hello)\n"
            "!tl hi-hinglish <text> — Translate <text> to Hinglish (Roman Hindi)\n"
            "!tlchat <lang_code> — Set per-chat default language\n"
            "!tlchat none — Remove per-chat language\n"
            "!ex <codes> — Exclude languages from translation (e.g. !ex en,es,fr)\n"
            "!ex none — Clear all exclusions\n"
            "\nAI & MEME\n\n"
            "!ai <text> — Chat with AI (Gemini/Phoenix)\n"
            "!meme — Toggle meme translation mode\n"
            "\nANALYTICS & EXPORT\n\n"
            "!analytics — Show translation stats\n"
            "!cache — Show/clear translation cache\n"
            "!export — Export all settings & analytics\n"
            "!exportbasic — Export only settings\n"
            "!exportanalytics — Export only analytics\n"
            "\nDEV\n\n"
            "!dev — Toggle developer mode\n"
            "!credits, !about — Show developer credits\n"
            "\nINFO\n\n"
            "!help, !commands — Show this help dialog\n"
            "\nSPECIAL\n\n"
            "! (at start of message) — Bypass translation for that message\n"
            "\nNotes:\n- All commands must be at the start of the message.\n- Language codes: en, es, fr, de, hi, etc. (see settings for full list)\n- Use !on in a chat to enable translation.\n"
            "\n\nDeepL Supported Languages:\n"
            "  • Bulgarian (bg)\n"
            "  • Czech (cs)\n"
            "  • Danish (da)\n"
            "  • German (de)\n"
            "  • Greek (el)\n"
            "  • English (en)\n"
            "  • Spanish (es)\n"
            "  • Estonian (et)\n"
            "  • Finnish (fi)\n"
            "  • French (fr)\n"
            "  • Hungarian (hu)\n"
            "  • Indonesian (id)\n"
            "  • Italian (it)\n"
            "  • Japanese (ja)\n"
            "  • Korean (ko)\n"
            "  • Lithuanian (lt)\n"
            "  • Latvian (lv)\n"
            "  • Norwegian (Bokmål) (nb)\n"
            "  • Dutch (nl)\n"
            "  • Polish (pl)\n"
            "  • Portuguese (pt)\n"
            "  • Romanian (ro)\n"
            "  • Russian (ru)\n"
            "  • Slovak (sk)\n"
            "  • Slovenian (sl)\n"
            "  • Swedish (sv)\n"
            "  • Turkish (tr)\n"
            "  • Ukrainian (uk)\n"
            "  • Chinese (simplified) (zh)\n"
            )

            builder.set_title(locali.get_string("HELP_DIALOG_TITLE"))
            builder.set_message(locali.get_string("HELP_DIALOG_TEXT"))
            builder.set_positive_button("OK", None)
            run_on_ui_thread(lambda: builder.show())
        except Exception as e :
            log (f"Help dialog error: {e }")

    def _show_dev_credits_dialog (self ):
        try :
            fragment =get_last_fragment ()
            if not fragment or not fragment .getParentActivity ():
                return 
            builder =AlertDialogBuilder (fragment .getParentActivity (),AlertDialogBuilder .ALERT_TYPE_MESSAGE )
            builder .set_title ("Developer Credits")
            builder .set_message ("Auto Translate plugin\nDeveloped by @luvztroy\nSpecial thanks to @iamzainnnn and the community 💙")
            builder .set_positive_button ("OK",None )
            run_on_ui_thread (lambda :builder .show ())
        except Exception as e :
            log (f"Credits dialog error: {e }")

    def _create_advanced_settings_page(self):
        """Create and return the advanced settings page fragment"""
        from ui.settings import Switch, Input, Header, Text, Divider
        
        settings = [
            Header(locali.get_string("ADVANCED_SETTINGS")),
            
            # Translation Settings
            Divider(text=locali.get_string("TRANSLATION_SETTINGS")),
            Switch(
                key="bypass_commands",
                text=locali.get_string("BYPASS_COMMANDS"),
                default=self.get_setting("bypass_commands", False),
                subtext=locali.get_string("BYPASS_COMMANDS_SUB"),
                icon="msg_photo_curve_solar"
            ),
            Switch(
                key="dry_run_mode",
                text=locali.get_string("DRY_RUN_MODE"),
                default=self.get_setting("dry_run_mode", False),
                subtext=locali.get_string("DRY_RUN_MODE_SUB"),
                icon="msg_viewreplies_solar"
            ),
            Switch(
                key="send_first_message",
                text=locali.get_string("ALLOW_FIRST_MESSAGE"),
                default=self.get_setting("send_first_message", False),
                subtext=locali.get_string("ALLOW_FIRST_MESSAGE_SUB"),
                icon="msg_send_solar"
            ),
            
            # AI & Processing
            Divider(text=locali.get_string("AI_PROCESSING")),
            Switch(
                key="grammar_check",
                text=locali.get_string("GRAMMAR_CHECK"),
                default=self.get_setting("grammar_check", False),
                subtext=locali.get_string("GRAMMAR_CHECK_SUB"),
                icon="input_keyboard_solar",
                on_change=lambda value: self._on_grammar_check_changed(value)
            ),
            Switch(
                key="meme_mode",
                text=locali.get_string("MEME_MODE"),
                default=self.get_setting("meme_mode", False),
                subtext=locali.get_string("MEME_MODE_SUB"),
                icon="msg_sticker_solar",
                on_change=lambda value: self._on_meme_mode_changed(value)
            ) if self.get_setting("meme_mode_unlocked", False) else None,
            
            # Analytics Section
            Divider(text=locali.get_string("ANALYTICS")),
            Text(
                text=locali.get_string("VIEW_ANALYTICS"),
                icon="msg_stats_solar",
                accent=True,
                on_click=lambda view: self._show_analytics_dialog()
            )
        ]
        
        # Filter out None values (for conditional settings)
        return [s for s in settings if s is not None]

    def _show_changelog_dialog(self, view=None):
        try:
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext

            changelog_text = (
            "[2.0.0] - 2025-06-30\n\n"
            "• Added new personas\n\n"
            "• Added custom input field\n\n"
            "• Added DeepL Support\n\n"
            "• Formality Option for DeepL\n\n"
            "• UI Improvements\n\n"
            "[1.0.9] - 2025-06-29\n\n"
            "• Updated icon for plugin\n\n"
            "• New toggle for translating messages by default\n\n"
            "• Added a copy button in dry run mode\n\n"
            "• Now meme mode supports other languages as well\n\n"
            "\n[1.0.8] - Previous Version\n\n"
            "• Made AI Chat settings always visible (no dev mode needed)\n\n"
            "• Improved settings organization\n\n"
            "• Added per-chat language settings functionality\n\n"
            "• Added save/load of target languages per chat\n\n"
            "• Various bug fixes and stability improvements\n\n"
            "\n[1.0.7] - Older Version\n\n"
            "• Added a toggle for sending the first message without clearing from the composer\n\n"
            "• Added translation analytics\n\n"
            "• Improved Hindi language translation with AI\n\n"
            "• Added settings export/import feature"
            )

            builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
            builder.set_title(locali.get_string("CHANGELOG_DIALOG_TITLE"))
            builder.set_message(locali.get_string("CHANGELOG_DIALOG_TEXT"))
            builder.set_positive_button("OK", None)
            run_on_ui_thread(lambda: builder.show())

        except Exception as e :
            log (f"Error in show_changelog_dialog: {e }")


    def _on_grammar_check_changed(self, value):
        """
        Handler for grammar_check switch. If enabling grammar_check, disable meme_mode.
        """
        self.set_setting("grammar_check", value)
        if value:
            if self.get_setting("meme_mode", False):
                self.set_setting("meme_mode", False)
                run_on_ui_thread(lambda: BulletinHelper.show_info("Meme Mode disabled because Grammar Check is enabled."))

    def _on_meme_mode_changed(self, value):
        """
        Handler for meme_mode switch. If enabling meme_mode, disable grammar_check.
        """
        self.set_setting("meme_mode", value)
        if value:
            if self.get_setting("grammar_check", False):
                self.set_setting("grammar_check", False)
                run_on_ui_thread(lambda: BulletinHelper.show_info("Grammar Check disabled because Meme Mode is enabled."))

    def create_settings (self ):
        return [
        Header (locali.get_string("SETTINGS_TITLE")),
        Switch(
            key="translate_by_default",
            text=locali.get_string("TRANSLATE_BY_DEFAULT"),
            default=self.get_setting("translate_by_default", False),
            subtext=locali.get_string("TRANSLATE_BY_DEFAULT_SUB"),
            icon="msg_translate_solar"
        ),
        Divider (text =locali.get_string("TRANSLATION_SETTINGS")),
        Selector (
            key ="provider",
            text =locali.get_string("PROVIDER"),
            default =0 ,
            items =["Google","Yandex","DeepL"],
            icon ="msg_translate_solar"
        ),
        Input(
            key="deepl_api_key",
            text=locali.get_string("DEEPL_API_KEY"),
            default=self.get_setting("deepl_api_key", ""),
            icon="msg_pin_code",
            subtext=locali.get_string("DEEPL_API_KEY_SUB"),
        ) if self.get_setting("provider", 0) == 2 else None,
        Selector (
            key ="target_language",
            text =locali.get_string("TARGET_LANGUAGE"),
            default =0,
            items =LANG_NAMES,
            icon ="menu_premium_chatbot"
        ) if self.get_setting("provider", 0) != 2 else None,
        Selector (
            key ="target_language",
            text =locali.get_string("TARGET_LANGUAGE"),
            default =0,
            items =DEEPL_LANG_NAMES,
            icon ="menu_premium_chatbot"
        ) if self.get_setting("provider", 0) == 2 else None,
        Selector(
            key="deepl_formality",
            text=locali.get_string("FORMALITY"),
            default=0,
            items=[locali.get_string("FORMALITY_DEFAULT"), locali.get_string("FORMALITY_FORMAL"), locali.get_string("FORMALITY_CASUAL")],
            icon="msg_translate_solar"
        ) if self.get_setting("provider", 0) == 2 else None,
        # Moved to Advanced Settings page
        
        Divider(text=locali.get_string("AI_CHAT_SETTINGS")),
        Switch (
            key ="or_ai_enabled",
            text =locali.get_string("ENABLE_AI_CHAT"),
            default =self.get_setting("or_ai_enabled", False),
            subtext =locali.get_string("ENABLE_AI_CHAT_SUB"),
            icon ="ai_chat_solar"
        ),
        Selector (
            key ="ai_provider",
            text =locali.get_string("AI_PROVIDER"),
            default =self.get_setting("ai_provider", 0),
            items =["Gemini","Phoenix"],
            icon ="msg2_language"
        ) if self.get_setting("or_ai_enabled", False) else None,
        Selector (
            key ="ai_persona",
            text =locali.get_string("AI_PERSONA"),
            default =self.get_setting("ai_persona", 0),
            items =AI_ROLE_NAMES,
            icon ="msg_allowspeak_solar"
        ) if self.get_setting("or_ai_enabled", False) else None,
        Input(
            key="custom_persona_prompt",
            text=locali.get_string("CUSTOM_PERSONA_PROMPT"),
            default=self.get_setting("custom_persona_prompt", ""),
            icon="msg_allowspeak_solar",
            subtext=locali.get_string("CUSTOM_PERSONA_PROMPT_SUB"),
        ) if (self.get_setting("or_ai_enabled", False) and self.get_setting("ai_persona", 0) == (AI_ROLE_NAMES.index("Custom") if "Custom" in AI_ROLE_NAMES else -1)) else None,
        Input (
            key ="or_gemini_api_key",
            text =locali.get_string("GEMINI_API_KEY"),
            default =self.get_setting("or_gemini_api_key", ""),
            icon ="msg_pin_code",
            subtext =locali.get_string("GEMINI_API_KEY_SUB")
        ) if (self.get_setting("or_ai_enabled", False) and self.get_setting("ai_provider", 0) == 0) else None,
        Selector (
            key ="or_model_idx",
            text =locali.get_string("GEMINI_MODEL"),
            default =self.get_setting("or_model_idx", 0),
            items =["gemini-2.0-flash","gemini-2.5-flash"],
            icon ="ai_chat_solar"
        ) if (self.get_setting("or_ai_enabled", False) and self.get_setting("ai_provider", 0) == 0) else None,

        Input (
            key="phoenix_api_key",
            text=locali.get_string("PHOENIX_API_KEY"),
            default =self.get_setting("phoenix_api_key", ""),
            icon ="msg_pin_code"
        ) if (self.get_setting("or_ai_enabled", False) and self.get_setting("ai_provider", 0) == 1) else None,
        Selector (
            key ="phoenix_model_idx",
            text =locali.get_string("PHOENIX_MODEL"),
            default =self.get_setting("phoenix_model_idx", 0),
            items =PHOENIX_MODELS,
            icon ="ai_chat_solar"
        ) if (self.get_setting("or_ai_enabled", False) and self.get_setting("ai_provider", 0) == 1) else None,

        Divider(text=locali.get_string("ADVANCED_SETTINGS")),
        Text(
            text=locali.get_string("EXCLUDED_LANGUAGES"),
            icon="msg_viewreplies_solar",
            create_sub_fragment=self._create_excluded_languages_settings
        ),
        Text(
            text=locali.get_string("ADVANCED_SETTINGS"),
            icon="msg_settings_solar",
            create_sub_fragment=self._create_advanced_settings_page
        ),
        # Advanced settings moved to _create_advanced_settings_page

        Divider(text=locali.get_string("ABOUT")),
        Text (
            text =locali.get_string("HELP_USAGE"),
            icon ="msg_psa",
            accent =True ,
            on_click =lambda view :self ._show_help_dialog ()
        ),
        Text (
            text =locali.get_string("CHANGELOG"),
            icon ="msg_channel_solar",
            accent =True ,
            on_click =lambda view :self ._show_changelog_dialog ()
        ),
        Divider(
            text=locali.get_string("THANK_YOU")
        )

        ]

    def translate_text(self, text: str, target_lang: str) -> str:
        """Translate text using the selected provider (Google or Yandex)."""
        provider_idx = self.get_setting("provider", 0)
        try:
            provider_idx = int(provider_idx)
        except (TypeError, ValueError):
            provider_idx = 0
            
        source_lang = "unknown"
        try:
            detected = self.detect_language(text)
            if detected:
                source_lang = detected
        except Exception:
            pass
            
        providers = ["google", "yandex", "deepl"]
        provider = providers[provider_idx] if provider_idx in range(len(providers)) else "google"
        
        cached_result = self.get_cached_translation(text, target_lang)
        if cached_result:
            log(f"[translate_text] Cache hit for text: '{text[:50]}...'")
            self._track_translation(source_lang, target_lang, "cache", True, cache_hit=True)
            return cached_result
            
        log(f"[translate_text] Cache miss for text: '{text[:50]}...'")
        self._track_translation(source_lang, target_lang, "cache", False, cache_hit=False)
        
        try:
            if provider_idx == 0:
                result = self._translate_google(text, target_lang)
                success = result is not None and result != text
                self._track_translation(source_lang, target_lang, provider, success)
                if success and result:
                    self.cache_translation(text, target_lang, result)
                return result if result else text
            elif provider_idx == 1:
                log(f"[translate_text] calling translate_with_yandex for text: '{text}'")
                result = self.translate_with_yandex(text, target_lang)
                success = result is not None and result != text
                self._track_translation(source_lang, target_lang, provider, success)
                if success and result:
                    self.cache_translation(text, target_lang, result)
                return result if result else text
            elif provider_idx == 2:
                # Map selector index to DeepL code
                lang_index = self.get_setting("target_language", 0)
                if 0 <= lang_index < len(DEEPL_LANG_CODES):
                    deepl_code = DEEPL_LANG_CODES[lang_index]
                else:
                    deepl_code = "en"  # fallback to English
                result = self._translate_with_deepl(text, deepl_code)
                # Always treat a non-None DeepL result as success, even if identical to input
                success = result is not None
                self._track_translation(source_lang, deepl_code, provider, success)
                if success and result:
                    self.cache_translation(text, deepl_code, result)
                # Fallback to Google only if DeepL failed (returned None)
                if result is None:
                    result = self._translate_google(text, deepl_code)
                    success = result is not None and result != text
                    self._track_translation(source_lang, deepl_code, "google", success)
                    if success and result:
                        self.cache_translation(text, deepl_code, result)
                return result if result else text
            else:
                result = self._translate_google(text, target_lang)
                success = result is not None and result != text
                self._track_translation(source_lang, target_lang, "google", success)
                if success and result:
                    self.cache_translation(text, target_lang, result)
                return result if result else text
                
        except Exception as e:
            log(f"[translate_text] Exception: {e}")
            self.last_exception = str(e)
            self._track_translation(source_lang, target_lang, provider, False)
            return text

    def _mask_excluded_words(self, text):
        placeholders = []
        masked_text = text

        def tag_replacer(match):
            placeholders.append(match.group(0))
            return f"[[{len(placeholders)-1}]]"
            
        masked_text = re.sub(r"(#\w+|@\w+)", tag_replacer, masked_text)

        if self.get_setting("advanced_settings", False):
            raw = self.get_setting("excluded_words", "")
            words =[w .strip ()for w in raw .split (",")if w .strip ()]
            for word in words :
                pattern =re .compile (re .escape (word ),flags =re .I )
                def repl (m ):
                    placeholders .append (m .group (0 ))
                    return f"[[{len (placeholders )-1 }]]"
                masked_text =pattern .sub (repl ,masked_text )

        return masked_text ,placeholders 

    def _restore_excluded_words (self ,text ,placeholders ):
        restored =text 
        for idx ,original in enumerate (placeholders ):
            pattern =re .compile (rf"\[\[{idx }\]\]",flags =re .I )
            restored =pattern .sub (original ,restored )
        return restored 

    def _create_excluded_languages_settings (self ,view =None ):
        """Return settings rows for multi-select excluded languages (Switch only)."""
        items = [
            Header (locali.get_string("SELECT_LANGUAGES_TO_BYPASS_TRANSLATION")),
            Divider(text=locali.get_string("SELECT_LANGUAGES_TO_BYPASS_TRANSLATION_SUB"))
        ]

        current_raw = self.get_setting("exclude_languages", "")
        current_set = set(code for code in current_raw.split(',') if code)

        def _make_on_change(lang_code: str):
            def _handler(enabled: bool):
                raw = self.get_setting("exclude_languages", "")
                s = set(c for c in raw.split(',') if c)
                if enabled:
                    s.add(lang_code)
                else:
                    s.discard(lang_code)
                self.set_setting("exclude_languages", ",".join(sorted(s)))
            return _handler

        for code, name in zip(LANG_CODES, LANG_NAMES):
            items.append(
                Switch(
                    key=f"ex_lang_{code}",
                    text=f"{name} ({code})",
                    default=(code in current_set),
                    on_change=_make_on_change(code)
                )
            )
        return items

    def _translate_google (self ,text :str ,target_lang :str )->str :
        try :
            params ={
            'client':'gtx',
            'sl':'auto',
            'tl':target_lang ,
            'dt':'t',
            'q':text 
            }
            resp =requests .get ("https://translate.googleapis.com/translate_a/single",params =params ,timeout =10 )
            resp .raise_for_status ()
            data =resp .json ()
            return ''.join (part [0 ]for part in data [0 ])
        except Exception as e :
            raise e 


        except Exception as e :
            log (f"[GrammarDo] {e }")
        finally :

            self .is_sending_translated =False 



    def has_settings (self ):
        return True 

    def _open_plugin_settings (self ,java_plugin ):
        try :
            get_last_fragment ().presentFragment (PluginSettingsActivity (java_plugin ))
        except Exception as e :
            log (f"[{__id__ }] open settings error: {e }")


    def _add_settings_menu_items (self ):
        try :
            # Only add the chat action menu item, drawer menu item has been removed
            self ._chat_settings_item =self .add_menu_item (MenuItemData (
            menu_type =MenuItemType .CHAT_ACTION_MENU ,
            text ="Auto Translate Settings",
            icon ="msg_saved_14_solar",
            priority =5 ,
            on_click =lambda ctx :run_on_ui_thread (lambda :self ._open_plugin_settings (PluginsController .getInstance ().plugins .get (self .id )))
            ))
        except Exception as e :
            log (f"[{__id__ }] add menu items error: {e }")

    def _toggle_settings_buttons (self ,enabled :bool ):
        def _apply ():
            try :
                if enabled :
                    if not self ._drawer_settings_item or not self ._chat_settings_item :
                        self ._add_settings_menu_items ()
                else :
                    if self ._drawer_settings_item :
                        self .remove_menu_item (self ._drawer_settings_item )
                        self ._drawer_settings_item =None 
                    if self ._chat_settings_item :
                        self .remove_menu_item (self ._chat_settings_item )
                        self ._chat_settings_item =None 
            except Exception as e :
                log (f"[{__id__ }] toggle button error: {e }")
        run_on_ui_thread (_apply )

    def _encode_premium_tags (self ,text :str ):
        return self .PREMIUM_EMO_TAG_RE .sub (lambda m :html .escape (m .group (0 )),text )

    def _decode_premium_tags (self ,text :str ):
        return text .replace ('&lt;','<').replace ('&gt;','>')

    def _copy_to_clipboard (self ,label ,text ):
        fragment =get_last_fragment ()
        ctx =fragment .getContext ()if fragment else ApplicationLoader .applicationContext 
        clipboard =ctx .getSystemService (Context .CLIPBOARD_SERVICE )
        clip =ClipData .newPlainText (label ,text )
        clipboard .setPrimaryClip (clip )
        BulletinHelper .show_info (f"Copied {label } to clipboard")

    def _show_copyable_bulletin (self ,message :str ):
        fragment =get_last_fragment ()
        ctx =fragment .getContext ()if fragment else ApplicationLoader .applicationContext 

        def _copy ():
            self ._copy_to_clipboard ("Message",message )

        BulletinHelper .show_with_button (
        message ,
        R_tg .raw .info ,
        "Copy",
        _copy ,
        fragment ,
        duration =BulletinHelper .DURATION_LONG 
        )

    def _perform_ai_chat_and_send (self ,peer ,question ,reply_obj ,reply_top_obj ):

        self .is_sending_translated =True 
        run_on_queue (lambda :self ._perform_ai_chat_and_send_async (peer ,question ,reply_obj ,reply_top_obj ))
        return HookResult (strategy =HookStrategy .CANCEL )

    def _show_loading (self ):
        """Show loading spinner immediately on the UI thread"""
        try :
            current_fragment =get_last_fragment ()
            if current_fragment and current_fragment .getParentActivity ():

                if hasattr (self ,'progress_dialog')and self .progress_dialog :
                    self ._dismiss_spinner ()

                self .progress_dialog =AlertDialog (current_fragment .getParentActivity (),3 )
                self .progress_dialog .show ()
        except Exception as e :
            log (f"Error showing loading spinner: {e }")

    def _dismiss_spinner (self ):
        if not hasattr (self ,'progress_dialog')or not self .progress_dialog :
            return 

        dialog =self .progress_dialog 
        self .progress_dialog =None 

        def dismiss ():
            try :
                if dialog is not None and hasattr (dialog ,'dismiss'):
                    try :
                        dialog .dismiss ()
                    except Exception as e :
                        log (f"Error in dialog.dismiss(): {e }")
            except Exception as e :
                log (f"Error in dismiss(): {e }")

        run_on_ui_thread (dismiss )
        time .sleep (0.1 )

    def _perform_ai_chat_and_send_async (self ,peer ,question ,reply_obj ,reply_top_obj ):
        try :
            max_attempts =2 
            attempt =0 

            while attempt <max_attempts :
                attempt +=1 
                try :

                    api_key =self .get_setting ("or_gemini_api_key","")
                    if not api_key :
                        self ._show_copyable_bulletin ("Gemini API key not set in plugin settings")
                        return 


                    model_idx =self .get_setting ("or_model_idx",0 )
                    model_idx =model_idx if model_idx in (0 ,1 )else 0 
                    model =GEMINI_MODELS [model_idx ]


                    system_prompt_user =self .get_setting ("or_ai_prompt","").strip ()
                    prompt =question 


                    persona_idx =self .get_setting ("ai_persona",0 )
                    persona =AI_ROLE_NAMES [persona_idx ]if 0 <=persona_idx <len (AI_ROLE_NAMES )else AI_ROLE_NAMES [0 ]

                    if persona =="None":
                        system_text =AI_BASE_PROMPT 
                    else:
                        persona_prompt = AI_PERSONA_PROMPTS.get(persona)
                        if persona_prompt:
                            system_text = persona_prompt
                        else:
                            system_text = f"You are a {persona}. {AI_BASE_PROMPT}"


                    headers ={"Content-Type":"application/json"}
                    url =GEMINI_API_URL_TEMPLATE .format (model =model )+f"?key={api_key }"

                    system_instruction ={
                    "role":"model",
                    "parts":[{"text":system_text }]
                    }

                    if system_prompt_user :
                        system_instruction ["parts"][0 ]["text"]+=f"\n\nUser Instructions: {system_prompt_user }"

                    payload ={
                    "contents":[{"role":"user","parts":[{"text":prompt }]}],
                    "system_instruction":system_instruction ,
                    "generationConfig":{
                    "temperature":0.7 ,
                    "maxOutputTokens":2000 ,
                    "topP":0.8 ,
                    "topK":40 
                    }
                    }


                    resp =_http .post (url ,json =payload ,headers =headers ,timeout =5 )


                    if resp .status_code ==429 :
                        if attempt <max_attempts :
                            retry_after =int (resp .headers .get ("Retry-After","3"))
                            time .sleep (min (retry_after ,10 ))
                            continue 
                        msg ="Gemini rate-limit hit. Please wait a moment and try again."
                        retry_after =int (resp .headers .get ("Retry-After","0"))
                        if retry_after >0 :
                            msg +=f" (retry after {retry_after }s)"
                        self ._show_copyable_bulletin (msg )
                        return 

                    resp .raise_for_status ()
                    data =resp .json ()
                    log (f"Gemini API response received, status: {resp .status_code }")


                    improved =self ._extract_ai_response_text (data )
                    if improved :
                        self ._send_ai_response_async (peer ,improved ,reply_obj ,reply_top_obj )
                        return 
                    else :
                        log (f"Gemini returned unexpected response format: {data }")
                        self ._show_copyable_bulletin ("Gemini returned an unexpected response format")
                        return 

                except Exception as e :
                    log (f"Gemini AI chat error (attempt {attempt }/{max_attempts }): {e }")
                    if attempt >=max_attempts :
                        self ._show_copyable_bulletin (f"Gemini request failed: {e }")
                    continue 

        except Exception as e :
            log (f"Unexpected error in AI chat: {e }")
            self ._show_copyable_bulletin (f"An unexpected error occurred: {e }")

        finally :
            log ("Gemini AI chat completed, cleaning up...")
            self .is_sending_translated =False 
            self ._dismiss_spinner ()

    def _translate_to_meme(self, text: str) -> str:
        """
        Translate text to cursed meme speak using Phoenix API.
        Only works for English text.
        """
        if not text or not text.strip():
            return text
            

            
        # Try Phoenix first
        try:
            api_key = self.get_setting("phoenix_api_key", "").strip()
            model_idx = self.get_setting("phoenix_model_idx", 0)
            model = PHOENIX_MODELS[model_idx] if 0 <= model_idx < len(PHOENIX_MODELS) else PHOENIX_MODELS[0]
            
            if not api_key:
                log("[MemeMode] No Phoenix API key available")
                raise Exception("No Phoenix API key")
            
            system_prompt = (
                "You are now the Meme Translator Supreme™ — your job is to take any boring or normal text and convert it into peak meme speak.\n"
                "\n⚡️ What You Do:\n"
                "Translate plain text into short, dank, cursed, or chaotic meme language.\n"
                "\nAdd maximum emoji sauce 💀🔥🫡😩✨\n"
                "\nUse internet slang and Gen Z vibes — from 'henlo' to 'it do be like that tho.'\n"
                "\nChannel the sybaU energy — if the text feels dramatic or intense, say it like you're yelling it in all caps with ✨feeling✨.\n"
                "\nNo explanations. No context. Just raw meme energy.\n"
                "\n📏 Rules:\n"
                "1 line only — keep it snappy.\n"
                "\nUse emojis for extra drama 🧍‍♂️👉🚪\n"
                "\nNo lowercase rules — go wild with caps, misspellings, or anything for ✨aesthetic✨.\n"
                "\nCapture the tone of the original message but memeify it.\n"
                "\n💀 Examples:\n"
                "'Hello' → 'henlo 😳'\n"
                "'I'm tired' → 'dead 💀'\n"
                "'Let's go' → 'lessgooo 🚀'"
            )
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {api_key}"
            }
            payload = {
                "model": model,
                "messages": [
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": f"Translate this to meme speak: {text}"}
                ],
                "temperature": 0.7,
                "max_tokens": 100
            }
            response = _http.post(PHOENIX_API_URL, headers=headers, json=payload, timeout=15)
            response.raise_for_status()
            result = response.json()
            try:
                translated_text = result['choices'][0]['message']['content']
                translated_text = translated_text.strip('"\'').replace('Translation:', '').strip()
                log(f"[MemeMode] Translated: {text} -> {translated_text}")
                return translated_text
            except (KeyError, IndexError) as e:
                log(f"[MemeMode] Error parsing Phoenix response: {e}")
                # Fallback to Gemini
                pass
        except Exception as e:
            log(f"[MemeMode] Phoenix failed, trying Gemini fallback: {e}")
        # Gemini fallback
        try:
            api_key = self.get_setting("or_gemini_api_key", "").strip()
            if not api_key:
                log("[MemeMode] Gemini API key not found for fallback")
                return text
            model_idx = self.get_setting("or_model_idx", 0)
            model = GEMINI_MODELS[model_idx] if 0 <= model_idx < len(GEMINI_MODELS) else GEMINI_MODELS[0]
            meme_prompt = (
                "You are a meme language generator. Take any input and rewrite it as a short, dank, cursed, or chaotic meme message. "
                "Use maximum emoji sauce, Gen Z slang, and internet meme language. Capture the tone but make it meme. "
                "One line only. No explanations, just the meme text. "
                "Examples: 'Hello'→'henlo 😳', 'I'm tired'→'dead 💀', 'Let's go'→'lessgooo 🚀'"
            )

            payload = {
                "contents": [
                    {"role": "user", "parts": [
                        {"text": meme_prompt},
                        {"text": f"\n\nMemeify this: {text}"}
                    ]}
                ],
                "generationConfig": {
                    "temperature": 0.7,
                    "maxOutputTokens": 100,
                    "topP": 0.95,
                    "topK": 40
                },
                "safetySettings": [
                    {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
                    {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
                    {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
                    {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
                ]
            }
            url = GEMINI_API_URL_TEMPLATE.format(model=model) + f"?key={api_key}"
            resp = _http.post(url, json=payload, headers={"Content-Type": "application/json"}, timeout=10)
            resp.raise_for_status()
            data = resp.json()
            # Try to extract meme text from Gemini response
            meme_text = self._extract_ai_response_text(data)
            if meme_text:
                log(f"[MemeMode] Gemini fallback: '{text}' -> '{meme_text}'")
                return meme_text
            log(f"[MemeMode] Gemini fallback: Unexpected response format: {data}")
            return text
        except Exception as e:
            log(f"[MemeMode] Gemini fallback failed: {e}")
            return text
            
            response = _http.post(url, headers=headers, json=payload, timeout=15)
            response.raise_for_status()
            result = response.json()
            
            # Extract the translated text from Phoenix response
            try:
                translated_text = result['choices'][0]['message']['content']
                # Clean up any extra text
                translated_text = translated_text.strip('\"\'').replace('Translation:', '').strip()
                log(f"[MemeMode] Translated: {text} -> {translated_text}")
                return translated_text
            except (KeyError, IndexError) as e:
                log(f"[MemeMode] Error parsing Phoenix response: {e}")
                return text
                
        except Exception as e:
            log(f"[MemeMode] Error in Phoenix meme translation: {e}")
            return text

    def _extract_ai_response_text (self ,response_data ):
        """Helper function to extract text from various response formats."""
        try :
            if not response_data :
                return None 


            if ("candidates"in response_data and 
            isinstance (response_data ["candidates"],list )and 
            response_data ["candidates"]):

                candidate =response_data ["candidates"][0 ]
                if not candidate .get ("content"):
                    return None 

                parts =candidate ["content"].get ("parts",[])
                if parts and isinstance (parts ,list ):
                    text_parts =[]
                    for part in parts :
                        if isinstance (part ,dict )and "text"in part :
                            text_parts .append (part ["text"])
                    if text_parts :
                        return "\n".join (text_parts )

                if "text"in candidate ["content"]:
                    return candidate ["content"]["text"]


            if "text"in response_data :
                return response_data ["text"]


            import json 
            response_str =json .dumps (response_data )
            if '"text":'in response_str :
                import re 
                text_matches =re .findall (r'"text":"(.*?)(?<!\\)"',response_str )
                if text_matches :
                    return "\n".join ([m .encode ().decode ('unicode_escape')for m in text_matches ])

        except Exception as e :
            log (f"Error extracting text from response: {e }")

        return None 

    def _send_ai_response_async (self ,peer ,response_text ,reply_obj ,reply_top_obj ):
        """Send the AI response asynchronously."""
        try :
            if not response_text :
                log ("No response text to send")
                return 

            response_text =response_text .strip ()
            if response_text .startswith ('"')and response_text .endswith ('"'):
                response_text =response_text [1 :-1 ]

            log (f"Sending AI response: {response_text }")


            payload ={
            "peer":peer ,
            "message":response_text 
            }

            if reply_obj is not None :
                payload ["replyToMsg"]=reply_obj 
            if reply_top_obj is not None :
                payload ["replyToTopMsg"]=reply_top_obj 


            def send_message_safely ():
                try :
                    log (f"Sending payload: {payload }")
                    result =send_message (payload )
                    log (f"Message sent, result: {result }")
                    return result 
                except Exception as e :
                    log (f"Error in send_message_safely: {e }")
                    raise 
                finally :
                    self .is_sending_translated =False 
                    self ._dismiss_spinner ()

            run_on_ui_thread (send_message_safely )

        except Exception as e :
            log (f"Error sending AI response: {e }")
            self ._show_copyable_bulletin (f"Failed to send AI response: {e }")
            self .is_sending_translated =False 
            self ._dismiss_spinner ()

    def _handle_ai_command (self ,peer ,command_text ,reply_obj ,reply_top_obj ):
        """Handle AI command in background thread"""
        try :

            question =""

            m_ai_query =re .match (r"^!ai(?:\s+(.*))?$",command_text ,flags =re .S |re .I )
            if m_ai_query :
                question =(m_ai_query .group (1 )or "").strip ()
                log (f"Parsed AI command. Question: '{question }'")


            if not self .get_setting ("or_ai_enabled",False ):
                run_on_ui_thread (lambda :self ._show_copyable_bulletin (
                "AI chat is disabled. Please enable it in settings."))
                run_on_ui_thread (self ._dismiss_spinner )
                self .is_sending_translated =False 
                return 


            provider_idx =self .get_setting ("ai_provider",0 )
            log (f"Using AI provider index: {provider_idx }")

            if provider_idx ==0 :
                api_key =self .get_setting ("or_gemini_api_key","")
                if not api_key :
                    run_on_ui_thread (lambda :self ._show_copyable_bulletin (
                    "Gemini API key is not set. Please set it in the settings."))
                    run_on_ui_thread (self ._dismiss_spinner )
                    self .is_sending_translated =False 
                    return 
                self ._prepare_ai_request (peer ,question ,reply_obj ,reply_top_obj ,"gemini")

            elif provider_idx ==1 :
                api_key =self .get_setting ("phoenix_api_key","")
                if not api_key :
                    run_on_ui_thread (lambda :self ._show_copyable_bulletin (
                    "Phoenix API key is not set. Please set it in the settings."))
                    run_on_ui_thread (self ._dismiss_spinner )
                    self .is_sending_translated =False 
                    return 
                self ._prepare_ai_request (peer ,question ,reply_obj ,reply_top_obj ,"phoenix")

            else :
                run_on_ui_thread (lambda :self ._show_copyable_bulletin (
                "Invalid AI provider selected. Please check your settings."))
                run_on_ui_thread (self ._dismiss_spinner )
                self .is_sending_translated =False 

        except Exception as e :
            log (f"Error in AI command handling: {e }")
            run_on_ui_thread (lambda :self ._show_copyable_bulletin (f"Error: {str (e )}"))
            run_on_ui_thread (self ._dismiss_spinner )
            self .is_sending_translated =False 

    def _prepare_ai_request (self ,peer ,question ,reply_obj ,reply_top_obj ,provider ):
        """Prepare the AI request by getting the message text if needed"""
        try :

            if not question and reply_obj is not None :
                try :
                    question =self ._extract_message_text (reply_obj ,peer )
                    log (f"Extracted question from reply: {question }")
                except Exception as e :
                    log (f"Error extracting message text: {e }")


            if question is None :
                question =""


            if provider =="phoenix":
                self ._perform_phoenix_ai_chat (peer ,question ,reply_obj ,reply_top_obj )
            else :
                self ._perform_ai_chat_and_send (peer ,question ,reply_obj ,reply_top_obj )

        except Exception as e :
            log (f"Error in AI request preparation: {e }")
            run_on_ui_thread (lambda :self ._show_copyable_bulletin (f"Error: {str (e )}"))
            run_on_ui_thread (self ._dismiss_spinner )
            self .is_sending_translated =False 

    def _extract_message_text (self ,reply_obj ,peer ):
        """Extract text from a message object"""
        question =""


        if hasattr (reply_obj ,'messageOwner')and hasattr (reply_obj .messageOwner ,'message'):
            question =reply_obj .messageOwner .message 
            log (f"Got text from reply_obj.messageOwner.message: {question }")
        elif hasattr (reply_obj ,'message'):
            question =reply_obj .message 
            log (f"Got text from reply_obj.message: {question }")
        elif hasattr (reply_obj ,'text'):
            question =reply_obj .text 
            log (f"Got text from reply_obj.text: {question }")


        if not question :
            log ("Trying alternative method to get message text")
            current_fragment =get_last_fragment ()
            if current_fragment and hasattr (current_fragment ,'getParentActivity'):
                parent_activity =current_fragment .getParentActivity ()
                if parent_activity :
                    messages_controller =parent_activity .getMessagesController ()
                    if messages_controller :
                        chat_id =self ._get_chat_id (peer )
                        if chat_id is not None :
                            question =self ._get_message_text (messages_controller ,chat_id ,reply_obj .id )

        return question 

    def _get_chat_id (self ,peer ):
        """Extract chat ID from peer object"""
        if hasattr (peer ,'channel_id')and peer .channel_id !=0 :
            return -peer .channel_id 
        elif hasattr (peer ,'chat_id')and peer .chat_id !=0 :
            return -peer .chat_id 
        elif hasattr (peer ,'user_id')and peer .user_id !=0 :
            return peer .user_id 
        return None 

    def _get_message_text (self ,messages_controller ,chat_id ,message_id ):
        """Get message text from messages controller"""
        log (f"Getting message with chat_id={chat_id }, message_id={message_id }")
        message =messages_controller .getMessage (chat_id ,message_id )

        if message is None :
            log ("Message object is None")
            return ""

        log (f"Message object type: {type (message )}")

    def _perform_phoenix_ai_chat (self ,peer ,question ,reply_obj ,reply_top_obj ):
        """Perform AI chat using Phoenix provider."""
        self .is_sending_translated =True 
        try :
            api_key =self .get_setting ("phoenix_api_key","" ).strip ()
            if not api_key :
                run_on_ui_thread (lambda :self ._show_copyable_bulletin (
                    "Phoenix API key is not set. Please set it in the settings."))
                return
            model_idx =self .get_setting ("phoenix_model_idx",0 )
            model =PHOENIX_MODELS [model_idx ] if 0 <=model_idx <len (PHOENIX_MODELS ) else PHOENIX_MODELS [0 ]
            headers ={ "Content-Type":"application/json","Authorization":f"Bearer {api_key }" }

            persona_idx = self.get_setting("ai_persona", 0)
            persona = AI_ROLE_NAMES[persona_idx] if 0 <= persona_idx < len(AI_ROLE_NAMES) else AI_ROLE_NAMES[0]
            if persona == "None":
                system_text = AI_BASE_PROMPT
            elif persona == "Custom":
                system_text = self.get_setting("custom_persona_prompt", AI_BASE_PROMPT)
            else:
                persona_prompt = AI_PERSONA_PROMPTS.get(persona)
                if persona_prompt:
                    system_text = persona_prompt
                else:
                    system_text = f"You are a {persona}. {AI_BASE_PROMPT}"

            payload ={
                "model":model ,
                "messages":[{"role":"system","content":system_text},{"role":"user","content":question }],
                "temperature":0.7 ,
                "max_tokens":2000
            }
            resp =_http .post (PHOENIX_API_URL ,json =payload ,headers =headers ,timeout =5 )
            resp .raise_for_status ()
            data =resp .json ()
            if "choices" in data and data ["choices"]:
                choice =data ["choices"][0]
                content = choice .get ("message",{}).get ("content","" )
                if content :

                    self ._send_ai_response_async (peer ,content ,reply_obj ,reply_top_obj )
                    return
            run_on_ui_thread (lambda :self ._show_copyable_bulletin (
                "Phoenix returned an unexpected response format."))
        except Exception as e :
            log (f"Phoenix AI chat error: {e }")
            run_on_ui_thread (lambda :self ._show_copyable_bulletin (f"Phoenix request failed: {e }"))
        finally :

            self .is_sending_translated =False 
            self ._dismiss_spinner ()

    def _save_enabled(self):
        try:
            raw = ",".join(str(x) for x in self.enabled_chats)
            self.set_setting("enabled_chats", raw)
        except Exception as e:
            log(f"Save enabled error: {e}")

    def _load_enabled(self):
        try:
            raw = self.get_setting("enabled_chats", "")
            if raw.strip():
                self.enabled_chats = set(int(x) for x in raw.split(',') if x.strip())
            else:
                self.enabled_chats = set()
            log(f"Loaded {len(self.enabled_chats)} enabled chats from settings")
        except Exception as e:
            log(f"Failed to load enabled chats: {e}")
            self.enabled_chats = set()

    def _save_excluded (self ):
        try :
            raw =",".join (str (x )for x in self .excluded_chats )
            self.set_setting("excluded_chats", raw)
        except Exception as e :
            log (f"Save excluded error: {e }")

    def _preserve_case_pattern(self, original_text: str, translated_text: str) -> str:
        """
        Preserve the original case pattern of the text.
        Handles mixed case scenarios like "Hello World", "hELLO wORLD", etc.
        """
        if not original_text or not translated_text:
            return translated_text
            
        if original_text.isupper():
            return translated_text.upper()
        elif original_text.islower():
            return translated_text.lower()
            
        original_chars = list(original_text)
        translated_chars = list(translated_text)
        
        case_map = []
        for char in original_chars:
            if char.isalpha():
                case_map.append(char.isupper())
            else:
                case_map.append(None)
                
        result = []
        case_idx = 0
        
        for char in translated_chars:
            if char.isalpha() and case_idx < len(case_map):
                while case_idx < len(case_map) and case_map[case_idx] is None:
                    case_idx += 1
                    
                if case_idx < len(case_map):
                    if case_map[case_idx]:
                        result.append(char.upper())
                    else:
                        result.append(char.lower())
                    case_idx += 1
                else:
                    result.append(char)
            else:
                result.append(char)
                
        return ''.join(result)

    def _clear_cache(self):
        """Clear the translation cache"""
        try:
            old_size = len(self.translation_cache)
            self.translation_cache.clear()
            self.last_cache_cleanup = time.time()
            run_on_ui_thread(lambda: BulletinHelper.show_success(f"Cache cleared! Removed {old_size} entries"))
        except Exception as e:
            log(f"Error clearing cache: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Failed to clear cache"))

    def _export_settings(self, export_type="full"):
        """Export plugin settings and data"""
        try:
            lines = []
            lines.append("AUTO TRANSLATE PLUGIN EXPORT")
            lines.append("")
            lines.append(f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}")
            lines.append(f"Export Type: {export_type.upper()}")
            lines.append("")

            # SYSTEM INFORMATION
            lines.append("SYSTEM INFORMATION")
            lines.append("• Android: {0} (SDK {1})".format(Build.VERSION.RELEASE, Build.VERSION.SDK_INT))
            lines.append("• Device: {0}".format(Build.MODEL))
            lines.append("• App Version: 11.9.0")
            # Telegram version
            tg_version = None
            try:
                from org.telegram.messenger import BuildVars
                tg_version = getattr(BuildVars, 'BUILD_VERSION_STRING', None)
            except Exception:
                pass
            if not tg_version:
                try:
                    tg_version = ApplicationLoader.getVersion()
                except Exception:
                    tg_version = None
            if tg_version:
                lines.append(f"• Telegram Version: {tg_version}")
            else:
                lines.append("• Telegram Version: [Unknown]")
            # Locale
            try:
                lines.append(f"• Locale: {Locale.getDefault().toString()}")
            except Exception:
                pass
            lines.append("")

            if export_type in ["full", "settings"]:
                lines.append("PLUGIN SETTINGS")
                settings_keys = {
                    "enable_translator": "Auto Translator",
                    "provider": "Provider",
                    "target_language": "Target Language", 
                    "bypass_commands": "Bypass Commands",
                    "grammar_check": "Grammar Check",
                    "advanced_settings": "Advanced Settings",
                    "dry_run_mode": "Dry Run Mode",
                    "skip_patterns": "Skip Patterns",
                    "or_ai_enabled": "AI Chat Enabled",
                    "ai_provider": "AI Provider",
                    "ai_persona": "AI Persona",
                    "or_gemini_api_key": "Gemini API Key",
                    "or_model_idx": "Gemini Model",
                    "phoenix_api_key": "Phoenix API Key", 
                    "phoenix_model_idx": "Phoenix Model",
                    "enable_analytics": "Analytics Enabled",
                    "send_first_message": "Send First Message"
                }
                
                for key, label in settings_keys.items():
                    value = self.get_setting(key, None)
                    if value is not None:
                        if "api_key" in key and value:
                            lines.append("• {0}: [SET]".format(label))
                        else:
                            lines.append("• {0}: {1}".format(label, value))
                
                lines.append("")
                lines.append("CHAT SETTINGS")
                lines.append("• Enabled Chats: {0}".format(len(self.enabled_chats)))
                lines.append("• Excluded Chats: {0}".format(len(self.excluded_chats)))
                lines.append("• Status Bulletins Shown: {0}".format(len(self._status_bulletins_shown)))
                lines.append("")

            if export_type in ["full", "analytics"]:
                lines.append("TRANSLATION ANALYTICS")
                lines.append("• Total Translations: {0:,}".format(self.translation_stats.get('total_translations', 0)))
                lines.append("• Successful: {0:,}".format(self.translation_stats.get('successful_translations', 0)))
                lines.append("• Failed: {0:,}".format(self.translation_stats.get('failed_translations', 0)))
                lines.append("• Cache Hits: {0:,}".format(self.translation_stats.get('cache_hits', 0)))
                lines.append("• Cache Misses: {0:,}".format(self.translation_stats.get('cache_misses', 0)))
                
                if self.translation_stats.get('language_stats'):
                    lines.append("")
                    lines.append("LANGUAGE PAIRS")
                    for pair, count in sorted(self.translation_stats['language_stats'].items(), key=lambda x: x[1], reverse=True):
                        lines.append("• {0}: {1:,}".format(pair, count))
                    
                if self.translation_stats.get('provider_stats'):
                    lines.append("")
                    lines.append("PROVIDER USAGE")
                    for provider, count in sorted(self.translation_stats['provider_stats'].items(), key=lambda x: x[1], reverse=True):
                        lines.append("• {0}: {1:,}".format(provider, count))
                
                lines.append("")

            if export_type in ["full", "analytics"]:
                lines.append("CACHE INFORMATION")
                lines.append("• Cache Size: {0:,} entries".format(len(self.translation_cache)))
                lines.append("• Cache Timeout: {0} seconds".format(self.cache_timeout))
                if self.last_cache_cleanup:
                    lines.append("• Last Cleanup: {0}".format(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(self.last_cache_cleanup))))
                lines.append("")

            if export_type in ["full", "debug"]:
                lines.append("DEBUG INFORMATION")
                lines.append("• Verbose Logging: {0}".format("Yes" if self.verbose_logging else "No"))
                lines.append("• Sending Translated: {0}".format("Yes" if self.is_sending_translated else "No"))
                lines.append("• Progress Dialog Active: {0}".format("Yes" if self.progress_dialog is not None else "No"))
                if self.last_exception:
                    lines.append("")
                    lines.append("LAST EXCEPTION")
                    lines.append(str(self.last_exception))
                lines.append("")
            
            export_text = "\n".join(lines)

            # Split and send as multiple messages if too long
            MAX_MSG_LEN = 4000
            peer = None
            try:
                current_fragment = get_last_fragment()
                if current_fragment and hasattr(current_fragment, 'getCurrentDialogPeer'):
                    peer = current_fragment.getCurrentDialogPeer()
            except Exception:
                pass
            if not peer:
                try:
                    peer = self.last_export_peer
                except Exception:
                    peer = None

            if peer:
                chunks = [export_text[i:i+MAX_MSG_LEN] for i in range(0, len(export_text), MAX_MSG_LEN)]
                for idx, chunk in enumerate(chunks):
                    prefix = f"[AutoTranslate Export Part {idx+1}/{len(chunks)}]\n" if len(chunks) > 1 else ""
                    send_message({'peer': peer, 'message': prefix + chunk})

            # Still copy to clipboard for compatibility
            self._copy_to_clipboard("Auto Translate Settings", export_text)

            run_on_ui_thread(lambda: BulletinHelper.show_success(
                f"Settings exported ({export_type})! Sent as message{'s' if len(export_text) > MAX_MSG_LEN else ''} and copied to clipboard."
            ))

            return export_text
            
        except Exception as e:
            log(f"Error exporting settings: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Failed to export settings"))
            return None

    def _show_export_dialog(self):
        """Show export options dialog"""
        try:
            fragment = get_last_fragment()
            if not fragment or not fragment.getParentActivity():
                return
                
            export_text = f"""{locali.get_string("EXPORT_DIALOG_TITLE")}

{locali.get_string("EXPORT_DIALOG_DESC")}

{locali.get_string("EXPORT_OPTION_FULL")}
{locali.get_string("EXPORT_OPTION_SETTINGS")}
{locali.get_string("EXPORT_OPTION_ANALYTICS")}
{locali.get_string("EXPORT_OPTION_DEBUG")}

{locali.get_string("EXPORT_CLIPBOARD_NOTE")}"""

            def export_full(dialog, which):
                self._export_settings("full")
                
            def export_settings(dialog, which):
                self._export_settings("settings")
                
            def export_analytics(dialog, which):
                self._export_settings("analytics")

            builder = AlertDialogBuilder(fragment.getParentActivity(), AlertDialogBuilder.ALERT_TYPE_MESSAGE)
            builder.set_title(locali.get_string("EXPORT_DIALOG_TITLE"))
            builder.set_message(export_text)
            builder.set_positive_button(locali.get_string("BUTTON_FULL_EXPORT"), export_full)
            builder.set_neutral_button(locali.get_string("BUTTON_SETTINGS"), export_settings)
            builder.set_negative_button(locali.get_string("BUTTON_CANCEL"), None)
            run_on_ui_thread(lambda: builder.show())
            
        except Exception as e:
            log(f"Error showing export dialog: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Failed to show export dialog"))



    def on_setting_changed(self, key: str, value):
        """Handle setting changes"""
        if key == "enable_analytics":
            if not value:
                run_on_ui_thread(lambda: BulletinHelper.show_info("Analytics disabled. Use !analytics to view existing data."))



