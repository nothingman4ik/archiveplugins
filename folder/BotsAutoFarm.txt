import traceback
import time
import json
from typing import Optional, Any, Dict
from java.util import Locale, ArrayList
from java.lang import Integer, Long
from org.telegram.tgnet import TLRPC
from org.telegram.messenger import R, ChatObject
from org.telegram.ui import ChatActivity, DialogsActivity, LaunchActivity
from android.os import Bundle
from java import dynamic_proxy
from com.exteragram.messenger.utils import ChatUtils
from org.telegram.messenger import UserConfig

from base_plugin import BasePlugin, HookResult, HookStrategy
from android_utils import log as _log, run_on_ui_thread
from client_utils import send_message, run_on_queue, get_messages_controller, get_user_config, get_last_fragment
from ui.bulletin import BulletinHelper
from ui.settings import Header, Input, Selector, Switch, Divider, Text
from ui.alert import AlertDialogBuilder

__name__ = "Bots AutoFarm"
__description__ = "Автофарминг для различных фарм-ботов (Например Iris или BFG)"
__icon__ = "UtyaDuckFull/93"
__id__ = "botsautofarm"
__version__ = "2.1"
__author__ = "@AyugramTop, @Podyshka2, @bleizix"
__min_version__ = "11.9.1"

class Locales:
    default = {
        "settings_header": "Settings",
        "message_label": "Message to send",
        "interval_label": "Send interval",
        "enabled_label": "Enable auto-sending",
        "usage_text": "Configure the message, interval and target chat in settings, then enable auto-sending.",
        "select_chat_text": "Select target chat",
        "no_chat_selected": "No chat selected",
        "error_sending": "Error sending message",
        "invalid_interval": "Invalid interval format",
        "start_sending": "Auto-sending started",
        "stop_sending": "Auto-sending stopped",
        "empty_message_error": "Message field cannot be empty!",
        "active_form": "Active",
        "add_form": "Add form",
        "remove_form": "Remove form",
        "form_header": "Form",
        "examples_header": "Examples",
        "example_message": "Example: Farm, Rob the treasury.",
        "example_interval": "Example: 1s, 2m, 3h, 4d.",
        "current_chat": "Current chat",
        "chat_not_selected": "Not selected"
    }
    ru = {
        "settings_header": "Настройки",
        "message_label": "Сообщение для отправки",
        "interval_label": "Интервал отправки",
        "enabled_label": "Включить автоотправку",
        "usage_text": "Настройте сообщение, интервал и целевой чат в настройках, затем включите автоотправку.",
        "select_chat_text": "Выбрать целевой чат",
        "no_chat_selected": "Чат не выбран",
        "error_sending": "Ошибка отправки сообщения",
        "invalid_interval": "Неверный формат интервала",
        "start_sending": "Автоотправка запущена",
        "stop_sending": "Автоотправка остановлена",
        "empty_message_error": "Поле сообщения не может быть пустым!",
        "active_form": "Активна",
        "add_form": "Добавить форму",
        "remove_form": "Удалить форму",
        "form_header": "Форма",
        "examples_header": "Примеры",
        "example_message": "Пример: Фармить, Ограбить казну.",
        "example_interval": "Пример: 1s, 2m, 3h, 4d.",
        "current_chat": "Текущий чат",
        "chat_not_selected": "Не выбран"
    }
    uk = {
        "settings_header": "Налаштування",
        "message_label": "Повідомлення для відправки",
        "interval_label": "Інтервал відправки",
        "enabled_label": "Увімкнути автоотправку",
        "usage_text": "Налаштуйте повідомлення, інтервал та цільовий чат в налаштуваннях, потім увімкніть автоотправку.",
        "select_chat_text": "Вибрати цільовий чат",
        "no_chat_selected": "Чат не вибрано",
        "error_sending": "Помилка відправки повідомлення",
        "invalid_interval": "Невірний формат інтервалу",
        "start_sending": "Автоотправку запущено",
        "stop_sending": "Автоотправку зупинено",
        "empty_message_error": "Поле повідомлення не може бути порожнім!",
        "active_form": "Активна",
        "add_form": "Додати форму",
        "remove_form": "Видалити форму",
        "form_header": "Форма",
        "examples_header": "Приклади",
        "example_message": "Приклад: Фармити, Пограбувати скарбницю.",
        "example_interval": "Приклад: 1s, 2m, 3h, 4d.",
        "current_chat": "Поточний чат",
        "chat_not_selected": "Не вибрано"
    }
    en = default

def localise(key: str) -> str:
    locale = Locale.getDefault().getLanguage()
    locale_dict = getattr(Locales, locale, Locales.default)
    return locale_dict.get(key, key)

def normalize_chat_id(chat_id: str) -> Optional[int]:
    """Normalize chat ID to proper Telegram API format"""
    try:
        _chat_id = str(chat_id).strip()
        if not _chat_id.lstrip("-").isdigit():
            return None

        if _chat_id.startswith("-100"):
            return int(_chat_id[4:])
        elif _chat_id.startswith("-"):
            return int(_chat_id)
        else:
            return int(_chat_id)
    except (ValueError, AttributeError):
        return None

def log(obj):
    _log(f"{__name__}: " + str(obj))

class DialogsDelegate(dynamic_proxy(DialogsActivity.DialogsActivityDelegate)):
    def __init__(self, fn: callable):
        super().__init__()
        self._fn = fn
    def didSelectDialogs(self, fragment, dids, message, param, notify: bool, scheduleDate: int, topicsFragment):
        try:
            self._fn(fragment, dids, message, param, notify, scheduleDate, topicsFragment)
        except Exception as e:
            BulletinHelper.show_error(f"Ошибка выбора чата: {e}")

class AutoMessagePlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.sending_task = None
        self.is_sending = False
        self.selected_chat_id = None
        self.selected_chat_title = None

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        
        saved_chat_id = self.get_setting("selected_chat_id", "")
        saved_chat_title = self.get_setting("selected_chat_title", "")
        if saved_chat_id:
            try:
                self.selected_chat_id = int(saved_chat_id)
                self.selected_chat_title = saved_chat_title
                log(f"Loaded saved chat: {self.selected_chat_id} - {self.selected_chat_title}")
            except ValueError:
                self.selected_chat_id = None
                self.selected_chat_title = None
                log("Failed to load saved chat ID")
        log("Loaded")

    def on_plugin_unload(self):
        self.stop_all_auto_sending()
        log("Unloaded")

    def get_farms(self):
        farms_json = self.get_setting("multi_farms", "[]")
        try:
            farms = json.loads(farms_json)
            if not isinstance(farms, list):
                return []
            return farms
        except Exception:
            return []

    def set_farms(self, farms):
        self.set_setting("multi_farms", json.dumps(farms))

    def add_farm(self):
        farms = self.get_farms()
        farms.append({
            "message": "",
            "interval": "",
            "chat_id": "",
            "chat_title": localise("chat_not_selected"),
            "enabled": False,
            "is_sending": False,
            "sending_task": None,
            "collapsed": False
        })
        self.set_farms(farms)
        self.create_settings()

    def remove_farm(self, idx):
        farms = self.get_farms()
        if len(farms) > 1:
            farms.pop(idx)
            self.set_farms(farms)
            self.create_settings()

    def showDialogsActivity(self, idx):
        args = Bundle()
        args.putBoolean("onlySelect", True)
        args.putBoolean("checkCanWrite", True)
        args.putInt("dialogsType", 0)
        args.putBoolean("allowGlobalSearch", True)

        activity = DialogsActivity(args)
        delegate = DialogsDelegate(
            lambda fragment, dids, message, param, notify, scheduleDate, topicsFragment:
            self.processDialogs(idx, activity, fragment, dids, message, param, notify, scheduleDate, topicsFragment)
        )
        activity.setDelegate(delegate)

        last_fragment = LaunchActivity.getLastFragment()
        if last_fragment:
            last_fragment.presentFragment(activity)

    def processDialogs(self, idx, activity, fragment, dids, message, param, notify, scheduleDate, topicsFragment):
        activity.finishFragment()
        if dids.isEmpty():
            return
        selected_id = dids.get(0).dialogId
        peer_id = str(selected_id)
        chatUtils = ChatUtils.getInstance(UserConfig.selectedAccount)
        current_target_name = chatUtils.getName(selected_id)
        
        farms = self.get_farms()
        if idx < len(farms):
            farms[idx]["chat_id"] = peer_id
            farms[idx]["chat_title"] = current_target_name
            self.set_farms(farms)
        
        BulletinHelper.show_success(f"{localise('select_chat_text')}: {current_target_name}")
        self.create_settings()

    def create_settings(self):
        farms = self.get_farms()
        if not farms:
            self.add_farm()
            return

        settings = [Header(text=localise("settings_header"))]
        settings.append(Text(
            text=localise("add_form"),
            icon="msg_addbot",
            on_click=lambda view: self.add_farm()
        ))
        settings.append(Divider())

        def make_on_change(field, i):
            return lambda value: self.update_farm_field(i, field, value)
        def make_on_click_dialog(i):
            return lambda view: self.showDialogsActivity(i)
        def make_on_enabled(i):
            return lambda enabled: self._on_enabled_change(enabled, i)
        def make_on_remove(i):
            return lambda view: self.remove_farm(i)
        def make_on_toggle_collapse(i):
            def toggle(view):
                farms = self.get_farms()
                if i < len(farms):
                    farms[i]['collapsed'] = not farms[i].get('collapsed', False)
                    self.set_farms(farms)
                    self.create_settings()
            return toggle

        for idx, farm in enumerate(farms):
            is_active = farm.get("enabled", False)
            is_collapsed = farm.get("collapsed", False)
            
            header_text = f"{localise('form_header')} #{idx+1}"
            if is_active:
                header_text += f" ({localise('active_form')})"
            
            collapse_icon = "msg_go_up" if not is_collapsed else "arrow_more_solar"
            settings.append(Text(
                text=header_text,
                icon=collapse_icon,
                accent=is_active,
                on_click=make_on_toggle_collapse(idx)
            ))

            if not is_collapsed:
                if len(farms) > 1:
                    settings.append(Text(
                        text=localise("remove_form"),
                        icon="msg_filled_blocked_solar",
                        accent=False,
                        red=True,
                        on_click=make_on_remove(idx)
                    ))
                settings.extend([
                    Switch(
                        key=f"enabled_{idx}",
                        text=localise("enabled_label"),
                        default=farm["enabled"],
                        icon="attach_send_solar",
                        on_change=make_on_enabled(idx)
                    ),
                    Input(
                        key=f"message_{idx}",
                        text=localise("message_label"),
                        default=farm["message"],
                        icon="fab_compose_small_solar",
                        on_change=make_on_change("message", idx)
                    ),
                    Input(
                        key=f"interval_{idx}",
                        text=localise("interval_label"),
                        default=farm["interval"],
                        icon="input_schedule_solar",
                        on_change=make_on_change("interval", idx)
                    ),
                    Text(
                        text=f"{localise('current_chat')}: " + farm["chat_title"],
                        icon="ic_chatlist_add_2_solar",
                        on_click=make_on_click_dialog(idx)
                    )
                ])
            settings.append(Divider())
        if settings and isinstance(settings[-1], Divider):
            settings.pop()
        settings.append(Divider(text=localise("usage_text")))
        settings.append(Header(text=localise("examples_header")))
        settings.append(Text(text=localise("example_message"), icon="fab_compose_small_solar"))
        settings.append(Text(text=localise("example_interval"), icon="input_schedule_solar"))
        
        return [s for s in settings if s is not None]

    def update_farm_field(self, idx, field, value):
        farms = self.get_farms()
        if idx < len(farms):
            farms[idx][field] = value.strip() if isinstance(value, str) else value
            self.set_farms(farms)

    def _on_enabled_change(self, enabled: bool, idx: int):
        farms = self.get_farms()
        if idx >= len(farms):
            return
            
        farm = farms[idx]

        if not enabled:
            farm['enabled'] = False
            self.set_farms(farms)
            self.stop_auto_sending(idx)
            return

        error_key = None
        if not farm.get("message", "").strip():
            error_key = "empty_message_error"
        elif not farm.get("chat_id", "").strip() or farm.get("chat_title") == localise("chat_not_selected"):
            error_key = "no_chat_selected"
        elif self._parse_interval(farm.get("interval", "").strip()) <= 0:
            error_key = "invalid_interval"

        if error_key:
            BulletinHelper.show_error(localise(error_key))
            farm['enabled'] = False
            self.set_farms(farms)
            fragment = get_last_fragment()
            if fragment and hasattr(fragment, "rebuildAllItems"):
                fragment.rebuildAllItems()
            
            return

        farm['enabled'] = True
        self.set_farms(farms)
        self.start_auto_sending(idx)

    def start_auto_sending(self, idx):
        farms = self.get_farms()
        if idx >= len(farms):
            return
        
        farm = farms[idx]
        
        if not farm.get("enabled"):
             return

        message = farm["message"].strip()
        interval_str = farm["interval"].strip()
        interval_seconds = self._parse_interval(interval_str)
        
        farm["is_sending"] = True
        self.set_farms(farms)
        self._schedule_next_send(idx, message, interval_seconds)
        BulletinHelper.show_success(localise("start_sending"))

    def stop_auto_sending(self, idx):
        farms = self.get_farms()
        if idx >= len(farms):
            return
        farm = farms[idx]
        if not farm.get("is_sending"):
            return
        farm["is_sending"] = False
        if farm.get("sending_task"):
            farm["sending_task"] = None
        self.set_farms(farms)
        BulletinHelper.show_info(localise("stop_sending"))

    def _parse_interval(self, interval_str: str) -> int:
        try:
            interval_str = interval_str.strip().lower()
            if interval_str.endswith('s'):
                return int(interval_str[:-1])
            elif interval_str.endswith('m'):
                return int(interval_str[:-1]) * 60
            elif interval_str.endswith('h'):
                return int(interval_str[:-1]) * 3600
            elif interval_str.endswith('d'):
                return int(interval_str[:-1]) * 86400
            else:
                return int(interval_str) * 60
        except (ValueError, AttributeError):
            return 0

    def _schedule_next_send(self, idx, message: str, interval_seconds: int):
        farms = self.get_farms()
        if idx >= len(farms):
            return
        farm = farms[idx]
        if not farm.get("is_sending"):
            return
        def send_and_schedule():
            farms = self.get_farms()
            if idx >= len(farms):
                return
            farm = farms[idx]
            if not farm.get("is_sending"):
                return
            try:
                self._send_message(farm["chat_id"], message)
                if farm.get("is_sending"):
                    self._schedule_next_send(idx, message, interval_seconds)
            except Exception as e:
                log(f"Error in send_and_schedule: {e}")
                farm["is_sending"] = False
                self.set_farms(farms)
        farm["sending_task"] = run_on_queue(
            send_and_schedule,
            delay=interval_seconds * 1000  # Convert to milliseconds
        )
        self.set_farms(farms)

    def _send_message(self, chat_id, message: str):
        try:
            if not chat_id:
                log("No chat selected for sending message")
                return
            peer_id = int(chat_id)
            log(f"Attempting to send message to chat ID: {peer_id}")
            params = {
                "peer": peer_id,
                "message": message
            }
            send_message(params)
            log(f"Successfully sent message to chat {peer_id}")
        except Exception as e:
            log(f"Error in _send_message: {e}")
            BulletinHelper.show_error(localise("error_sending"))

    def on_send_message_hook(self, account, params):
        return HookResult()

    def stop_all_auto_sending(self):
        farms = self.get_farms()
        for idx in range(len(farms)):
            self.stop_auto_sending(idx) 