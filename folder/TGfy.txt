__id__ = "tgfy"
__name__ = "TGfy"
__author__ = "@MorePlugins, @RooniPlugin"
__version__ = "3.5.1"
__description__ = """Показывает играющую песню в виде стильной карточки.

Множество других эффектов (тени, обводки) настраиваются в меню плагина. 

Команда: .tgplay"""

import requests
import traceback
import os
import uuid
import time
import threading
import math
from io import BytesIO
from typing import Any, Callable

__min_version__ = "11.12.0"
__icon__ = "SpottyAnimated/30"

try:
    from PIL import Image, ImageDraw, ImageFont, ImageFilter, ImageEnhance
except ImportError:
    raise ImportError("Требуется библиотека Pillow. Убедитесь, что она установлена в вашем окружении.")

from base_plugin import BasePlugin, HookResult, HookStrategy, MenuItemData, MenuItemType
from client_utils import (
    get_last_fragment,
    get_send_messages_helper,
    run_on_queue,
    send_message
)
from android_utils import run_on_ui_thread, log
from ui.settings import Header, Input, Switch, Divider, Text, Selector
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper

from org.telegram.messenger import (
    ApplicationLoader,
    FileLoader,
    UserConfig,
    MediaController,
    SendMessagesHelper
)
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity

TEMP_DIR_NAME = "now_playing_cards_enhanced_pi"

class NowPlayingCardEnhancedPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.progress_dialog = None
        self.temp_dir = None
        self.overlay_image = None
        self.overlay_url = "https://raw.githubusercontent.com/Igroshka/-/87bf3aaf764fa81bcd190c9ebff1de3bb213edcc/img/mega_overlay.png"
        self.drawer_menu_item_id = None
        self.font_path = None
        self.FONTS = {
            "VAG Rounded M Bold": "https://github.com/Bern0va/fonts/raw/refs/heads/main/18VAG%20Rounded%20M%20Bold.ttf",
            "NeutraDemiSC": "https://github.com/Bern0va/fonts/raw/refs/heads/main/NeutraDemiSC.ttf",
            "Oswald-Regular": "https://github.com/Bern0va/fonts/raw/refs/heads/main/Oswald-Regular.ttf",
            "WDXLLubrifontSC-Regular": "https://github.com/Bern0va/fonts/raw/refs/heads/main/WDXLLubrifontSC-Regular.ttf",
        }

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self._get_temp_dir()
        self._toggle_drawer_menu_item(self.get_setting("show_in_drawer", False))

    def on_plugin_unload(self):
        if self.drawer_menu_item_id:
            self.remove_menu_item(self.drawer_menu_item_id)

    def _get_and_prepare_font(self):
        font_choice_index_pi = self.get_setting("font_choice", 0)
        font_names = list(self.FONTS.keys())
        font_url = ""
        font_filename = ""

        if font_choice_index_pi < len(font_names):
            font_name = font_names[font_choice_index_pi]
            font_url = self.FONTS[font_name]
            font_filename = os.path.basename(requests.utils.unquote(font_url))
        elif font_choice_index_pi == len(font_names):
            font_url = self.get_setting("custom_font_url", "").strip()
            if not font_url.lower().endswith((".ttf", ".otf")):
                self.font_path = None
                return
            font_filename = "custom_font.ttf"
        
        if not font_url or not self.temp_dir:
            self.font_path = None
            return

        target_path = os.path.join(self.temp_dir, font_filename)
        self.font_path = target_path

        if not os.path.exists(target_path):
            try:
                response = requests.get(font_url, timeout=30)
                response.raise_for_status()
                with open(target_path, "wb") as f:
                    f.write(response.content)
            except Exception as e:
                self.font_path = None
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка загрузки шрифта"))

    def _open_plugin_settings(self, context):
        def action():
            try:
                java_plugin = PluginsController.getInstance().plugins.get(self.id)
                if java_plugin:
                    last_fragment = get_last_fragment()
                    if last_fragment:
                        last_fragment.presentFragment(PluginSettingsActivity(java_plugin))
            except Exception as e:
                log(f"[{self.id}] Ошибка при открытии настроек: {e}")
        run_on_ui_thread(action)

    def _toggle_drawer_menu_item(self, enabled):
        try:
            if enabled and not self.drawer_menu_item_id:
                menu_item = MenuItemData(
                    menu_type=MenuItemType.DRAWER_MENU,
                    text="TGfy Настройки",
                    icon="msg_settings_art",
                    on_click=self._open_plugin_settings
                )
                self.drawer_menu_item_id = self.add_menu_item(menu_item)
            elif not enabled and self.drawer_menu_item_id:
                self.remove_menu_item(self.drawer_menu_item_id)
                self.drawer_menu_item_id = None
        except Exception as e:
            log(f"[{self.id}] Ошибка при переключении пункта меню: {e}")

    def _get_temp_dir(self):
        if self.temp_dir: return self.temp_dir
        try:
            from java.io import File
            base_dir = ApplicationLoader.getFilesDirFixed()
            if not base_dir: return None
            temp_dir_pi = File(base_dir, TEMP_DIR_NAME)
            if not temp_dir_pi.exists(): temp_dir_pi.mkdirs()
            self.temp_dir = temp_dir_pi.getAbsolutePath()
            return self.temp_dir
        except Exception as e:
            log(f"[{self.id}] Ошибка при создании временного каталога: {e}")
            return None

    def create_settings(self):
        custom_font_url_input = None
        if self.get_setting("font_choice", 0) == len(self.FONTS):
            custom_font_url_input = Input(key="custom_font_url", text="URL своего .ttf шрифта", default="", icon="msg_link")

        background_color_input = None
        if self.get_setting("background_type", 0) == 1:
            background_color_input = Input(key="background_color", text="Цвет фона (HEX)", default="#181818", icon="msg_colors")
            
        settings = [
            Header(text="Главные настройки"),
            Selector(key="card_orientation", text="Ориентация карточки", default=0, items=["Горизонтальная", "Вертикальная"], icon="msg_stories_add"),
            Switch(key="show_in_drawer", text="Настройки в боковом меню", subtext="Показывать 'TGfy Настройки' в левом боковом меню", default=False, icon="msg_plugins", on_change=self._toggle_drawer_menu_item),
            Divider(),
            Header(text="Отправка контента"),
            Switch(key="send_card", text="Отправлять карточку", default=True, icon="msg_media"),
            Switch(key="send_audio", text="Отправлять аудиофайл", default=True, icon="msg_music"),
            Switch(key="show_caption", text="Добавлять подпись", default=True, icon="msg_text"),
            Input(key="custom_caption", text="Текст подписи", default="Сейчас играет в Telegram", icon="msg_edit"),
            Divider(),
            Header(text="Внешний вид карточки"),
            Switch(key="show_tgfy_logo", text="Показывать 'TGfy'", default=True, icon="msg_sticker"),
            Switch(key="show_username", text="Показывать @username", default=False, icon="msg_openprofile"),
            Selector(key="progress_bar_style", text="Стиль индикатора", default=1, items=["Стандартный", "Волнистый", "Змеевидный"], icon="msg_stats"),
            Input(key="card_corner_radius", text="Скругление углов", default="20", icon="msg_round_file_s"),
            Divider(),
            Header(text="Размеры (ширина x высота)"),
            Input(key="horizontal_card_size", text="Горизонтальная", default="720,240", icon="msg_photo_crop"),
            Input(key="vertical_card_size", text="Вертикальная", default="480,720", icon="msg_photo_crop"),
            Divider(),
            Header(text="Настройки фона"),
            Selector(key="background_type", text="Тип фона", default=0, items=["Размытая обложка", "Сплошной цвет"], icon="msg_background", on_change=lambda val: self.rebuild_settings()),
            background_color_input,
            Switch(key="bg_overlay_enabled", text="Затемнение фона", default=True, icon="msg_photo_expose"),
            Input(key="bg_blur_radius", text="Радиус размытия", default="20", icon="msg_photo_blur"),
            Input(key="bg_brightness", text="Яркость", default="0.8", subtext=">1 светлее, <1 темнее", icon="msg_brightness_high"),
            Input(key="bg_saturation", text="Насыщенность", default="1.1", subtext=">1 более насыщенный", icon="msg_palette"),
            Divider(),
            Header(text="Эффекты обложки альбома"),
            Switch(key="art_shadow_enabled", text="Тень обложки", default=True, icon="msg_shadow"),
            Input(key="art_shadow_color", text="Цвет тени", default="#00000099", icon="msg_colors"),
            Input(key="art_shadow_offset", text="Смещение (X,Y)", default="6,6", icon="msg_select_between"),
            Input(key="art_shadow_blur", text="Размытие тени", default="15", icon="msg_photo_blur"),
            Switch(key="art_stroke_enabled", text="Обводка", default=True, icon="msg_photo_crop"),
            Input(key="art_stroke_color", text="Цвет обводки", default="#FFFFFF40", icon="msg_colors"),
            Input(key="art_stroke_width", text="Ширина обводки", default="2", icon="msg_photo_expose"),
            Divider(),
            Header(text="Эффекты текста"),
            Selector(key="font_choice", text="Шрифт", default=0, items=list(self.FONTS.keys()) + ["Свой"], icon="msg_photo_text2", on_change=lambda val: self.rebuild_settings()),
            custom_font_url_input,
            Switch(key="text_shadow_enabled", text="Тень у текста", default=True, subtext="Применяет тень ко всему тексту на карточке", icon="msg_shadow"),
            Input(key="text_shadow_color", text="Цвет тени", default="#000000A0", icon="msg_colors"),
            Input(key="text_shadow_offset", text="Смещение (X,Y)", default="2,2", icon="msg_select_between"),
        ]
        return [s for s in settings if s]
    
    def rebuild_settings(self):
        fragment = get_last_fragment()
        if fragment and hasattr(fragment, "rebuildAllItems"):
            fragment.rebuildAllItems()
    
    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        if not isinstance(params.message, str) or params.message.strip().lower() != ".tgplay":
            return HookResult()
        try:
            media_controller = MediaController.getInstance()
            playing_song = media_controller.getPlayingMessageObject()

            if playing_song is None or not playing_song.isMusic():
                run_on_ui_thread(lambda: BulletinHelper.show_info("В Telegram не воспроизводится музыка."))
                return HookResult(strategy=HookStrategy.CANCEL)

            self._show_loading_dialog()
            run_on_queue(lambda: self._generate_and_send(playing_song, params))
        except Exception as e:
            log(f"[{self.id}] Ошибка в хуке: {traceback.format_exc()}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка: {e}"))

        return HookResult(strategy=HookStrategy.CANCEL)
        
    def _parse_color(self, color_str, default_color):
        color_str = color_str.strip()
        if not color_str.startswith('#'): return default_color
        hex_val = color_str[1:]
        try:
            if len(hex_val) == 8: return tuple(int(hex_val[i:i+2], 16) for i in (0, 2, 4, 6))
            if len(hex_val) == 6: return tuple(int(hex_val[i:i+2], 16) for i in (0, 2, 4)) + (255,)
        except (ValueError, TypeError): pass
        return default_color

    def _parse_tuple(self, tuple_str, default_tuple):
        try:
            parts = [int(p.strip()) for p in tuple_str.split(',')]
            if len(parts) == 2: return tuple(parts)
        except (ValueError, AttributeError): pass
        return default_tuple
        
    def _parse_int(self, value_str, default_value):
        try: return int(value_str)
        except (ValueError, TypeError): return default_value

    def _parse_float(self, value_str, default_value):
        try: return float(value_str)
        except (ValueError, TypeError): return default_value

    def _generate_and_send(self, song_object, params):
        try:
            send_card_enabled = self.get_setting("send_card", True)
            send_audio_enabled = self.get_setting("send_audio", True)

            if not send_card_enabled and not send_audio_enabled:
                run_on_ui_thread(self._dismiss_loading_dialog)
                return

            image_path_pi = None
            if send_card_enabled:
                full_title = song_object.getMusicTitle()
                full_artist = song_object.getMusicAuthor()
                duration = song_object.getDuration()
                progress = MediaController.getInstance().getPlayingMessageObject().audioProgressSec

                album_art_image = self._fetch_album_art(full_artist, full_title)
                image_path_pi = self._create_card_image(album_art_image, full_title, full_artist, progress, duration)
                if not image_path_pi:
                    run_on_ui_thread(lambda: BulletinHelper.show_error("Не удалось создать карточку."))

            run_on_ui_thread(lambda: self._send_results(image_path_pi, song_object, params))

        except Exception as e:
            log(f"[{self.id}] Ошибка в фоновой задаче: {traceback.format_exc()}")
            run_on_ui_thread(self._dismiss_loading_dialog)
        finally:
            run_on_ui_thread(self._dismiss_loading_dialog)

    def _fetch_album_art(self, artist, title):
        try:
            search_term = f"{artist} {title}"
            response = requests.get("https://itunes.apple.com/search", params={"term": search_term, "entity": "song", "limit": 1}, timeout=10)
            response.raise_for_status()
            data = response.json()
            if data['resultCount'] > 0:
                artwork_url = data['results'][0]['artworkUrl100'].replace('100x100', '800x800')
                art_response = requests.get(artwork_url, timeout=10)
                art_response.raise_for_status()
                return Image.open(BytesIO(art_response.content)).convert("RGBA")
        except Exception as e:
            log(f"[{self.id}] Не удалось получить обложку альбома: {e}")
        return None

    def _get_font(self, size):
        try:
            if self.font_path and os.path.exists(self.font_path):
                return ImageFont.truetype(self.font_path, size)
        except Exception as e:
            log(f"[{self.id}] Ошибка при загрузке шрифта, используется стандартный: {e}")
        return ImageFont.load_default()

    def _get_adaptive_font(self, text, max_width, initial_size, min_size=16):
        font_size = initial_size
        font = self._get_font(font_size)
        if not text: return font
        while self._get_text_width(text, font) > max_width and font_size > min_size:
            font_size -= 1
            font = self._get_font(font_size)
        return font

    def _get_text_width(self, text, font):
        if hasattr(font, 'getbbox'): return font.getbbox(text)[2]
        return font.getsize(text)[0]

    def _get_text_height(self, text, font):
        if hasattr(font, 'getbbox'): return font.getbbox(text)[3] - font.getbbox(text)[1]
        return font.getsize(text)[1]

    def _truncate_text(self, text, max_len):
        if len(text) > max_len:
            return text[:max_len-3] + "..."
        return text

    def _draw_text_with_shadow(self, draw, xy, text, font, fill, shadow_enabled, shadow_fill, shadow_offset):
        if shadow_enabled: draw.text((xy[0] + shadow_offset[0], xy[1] + shadow_offset[1]), text, font=font, fill=shadow_fill)
        draw.text(xy, text, font=font, fill=fill)

    def _draw_progress_bar(self, draw: ImageDraw, style: int, x, y, width, height, progress_ratio: float, filled_color, unfilled_color):
        if style == 0:
            bar_height = 8
            y_pos = y + (height - bar_height) / 2
            draw.rounded_rectangle((x, y_pos, x + width, y_pos + bar_height), radius=int(bar_height/2), fill=unfilled_color)
            if progress_ratio > 0:
                draw.rounded_rectangle((x, y_pos, x + (width * progress_ratio), y_pos + bar_height), radius=int(bar_height/2), fill=filled_color)
        elif style == 1:
            num_bars, bar_width, bar_spacing = 60, width / 90, width / 180
            for i in range(int(num_bars)):
                bar_x = x + i * (bar_width + bar_spacing)
                wave = (math.sin(i * 0.4 + time.time() * 2) + 1) / 2
                bar_h = height * 0.2 + height * 0.8 * wave
                bar_y_top = y + (height - bar_h) / 2
                color = filled_color if (i / num_bars) < progress_ratio else unfilled_color
                draw.line([(bar_x, bar_y_top), (bar_x, bar_y_top + bar_h)], fill=color, width=int(bar_width))
        elif style == 2:
            points, amp, y_center = 200, height / 2.5, y + height / 2
            path_filled, path_unfilled = [], []
            split_point = int(points * progress_ratio)
            for i in range(points + 1):
                px = x + (i / points) * width
                py = y_center + math.sin(i * math.pi / 25) * amp
                if i <= split_point: path_filled.append((int(px), int(py)))
                if i >= split_point: path_unfilled.append((int(px), int(py)))
            if len(path_filled) > 1: draw.line(path_filled, fill=filled_color, width=4, joint="curve")
            if len(path_unfilled) > 1: draw.line(path_unfilled, fill=unfilled_color, width=4, joint="curve")

    def _format_time(self, seconds):
        if not isinstance(seconds, (int, float)) or seconds < 0: return "0:00"
        return f"{int(seconds // 60)}:{int(seconds % 60):02d}"

    def _create_card_image(self, album_art, full_title, full_artist, progress, duration):
        self._get_and_prepare_font()
        
        try:
            is_vertical = self.get_setting("card_orientation", 0) == 1
            h_size = self._parse_tuple(self.get_setting("horizontal_card_size", "720,240"), (720,240))
            v_size = self._parse_tuple(self.get_setting("vertical_card_size", "480,720"), (480,720))
            width, height = v_size if is_vertical else h_size
            
            bg_type_pi = self.get_setting("background_type", 0)
            bg_overlay_enabled_pi = self.get_setting("bg_overlay_enabled", True)
            bg_blur = self._parse_float(self.get_setting("bg_blur_radius", "20"), 20.0)
            bg_brightness = self._parse_float(self.get_setting("bg_brightness", "0.8"), 0.8)
            bg_saturation = self._parse_float(self.get_setting("bg_saturation", "1.1"), 1.1)
            
            text_shadow_enabled = self.get_setting("text_shadow_enabled", True)
            text_shadow_color = self._parse_color(self.get_setting("text_shadow_color", "#000000A0"), (0,0,0,160))
            text_shadow_offset = self._parse_tuple(self.get_setting("text_shadow_offset", "2,2"), (2,2))
            
            title_color = (255,255,255,255)
            artist_color = (179,179,179,255)
            time_color = (179,179,179,255)
            
            art_shadow_enabled = self.get_setting("art_shadow_enabled", True)
            art_shadow_color = self._parse_color(self.get_setting("art_shadow_color", "#00000099"), (0,0,0,153))
            art_shadow_offset = self._parse_tuple(self.get_setting("art_shadow_offset", "6,6"), (6,6))
            art_shadow_blur = self._parse_float(self.get_setting("art_shadow_blur", "15"), 15.0)
            art_stroke_enabled = self.get_setting("art_stroke_enabled", True)
            art_stroke_color = self._parse_color(self.get_setting("art_stroke_color", "#FFFFFF40"), (255,255,255,64))
            art_stroke_width = self._parse_int(self.get_setting("art_stroke_width", "2"), 2)
            corner_radius = self._parse_int(self.get_setting("card_corner_radius", "20"), 20)
            
            bar_style = self.get_setting("progress_bar_style", 1)
            bar_filled_color = (255,255,255,255)
            bar_unfilled_color = (110,110,110,255)
            
            title_size_h = 30
            artist_size_h = 22
            title_size_v = 36
            artist_size_v = 28
            
        except Exception as e:
            log(f"[{self.id}] Ошибка разбора настроек: {e}")
            return None

        bg_image = None
        if bg_type_pi == 0:
            bg_image = album_art.resize((width, height), Image.Resampling.LANCZOS) if album_art else Image.new("RGBA", (width, height), "#181818")
            if bg_blur > 0: bg_image = bg_image.filter(ImageFilter.GaussianBlur(radius=bg_blur))
            enhancer = ImageEnhance.Brightness(bg_image); bg_image = enhancer.enhance(bg_brightness)
            enhancer = ImageEnhance.Color(bg_image); bg_image = enhancer.enhance(bg_saturation)
        else:
            bg_color_str = self.get_setting("background_color", "#181818")
            solid_color = self._parse_color(bg_color_str, (24, 24, 24, 255))
            bg_image = Image.new("RGBA", (width, height), solid_color)

        if bg_overlay_enabled_pi:
            overlay = Image.new("RGBA", (width, height), (0, 0, 0, 120))
            pi_card = Image.alpha_composite(bg_image.convert("RGBA"), overlay).convert("RGB")
        else:
            pi_card = bg_image.convert("RGB")
            
        draw = ImageDraw.Draw(pi_card, "RGBA")
        
        padding = 30
        if is_vertical:
            art_size = width - padding * 2
            art_pos = (padding, padding)
            text_x, text_y = padding, art_pos[1] + art_size + 30
            max_text_width = width - padding * 2
        else:
            art_size = height - padding * 2
            art_pos = (padding, padding)
            text_x, text_y = art_pos[0] + art_size + padding, padding
            max_text_width = width - text_x - padding

        art_to_draw = album_art.resize((art_size, art_size), Image.Resampling.LANCZOS) if album_art else Image.new("RGBA", (art_size, art_size), "#505050")
        if art_shadow_enabled and art_shadow_blur > 0:
            shadow_img = Image.new('RGBA', pi_card.size, (0,0,0,0))
            shadow_draw = ImageDraw.Draw(shadow_img)
            shadow_rect = (art_pos[0]+art_shadow_offset[0], art_pos[1]+art_shadow_offset[1], art_pos[0]+art_size+art_shadow_offset[0], art_pos[1]+art_size+art_shadow_offset[1])
            shadow_draw.rounded_rectangle(shadow_rect, radius=corner_radius, fill=art_shadow_color)
            pi_card.paste(shadow_img.filter(ImageFilter.GaussianBlur(radius=art_shadow_blur)), (0, 0), shadow_img)
        if art_stroke_enabled and art_stroke_width > 0:
            draw.rounded_rectangle((art_pos[0]-art_stroke_width, art_pos[1]-art_stroke_width, art_pos[0]+art_size+art_stroke_width, art_pos[1]+art_size+art_stroke_width), radius=corner_radius+art_stroke_width, fill=art_stroke_color)
        mask = Image.new('L', (art_size, art_size), 0); ImageDraw.Draw(mask).rounded_rectangle((0, 0, art_size, art_size), radius=corner_radius, fill=255)
        pi_card.paste(art_to_draw, art_pos, mask)

        title = self._truncate_text(full_title, 20)
        artist = self._truncate_text(full_artist, 25)

        title_font = self._get_adaptive_font(title, max_text_width, title_size_v if is_vertical else title_size_h)
        self._draw_text_with_shadow(draw, (text_x, text_y), title, title_font, title_color, text_shadow_enabled, text_shadow_color, text_shadow_offset)
        text_y += self._get_text_height(title, title_font) + 4
        
        artist_font = self._get_adaptive_font(artist, max_text_width, artist_size_v if is_vertical else artist_size_h)
        text_y += 5
        self._draw_text_with_shadow(draw, (text_x, text_y), artist, artist_font, artist_color, text_shadow_enabled, text_shadow_color, text_shadow_offset)
        text_y += self._get_text_height(artist, artist_font)

        pi_user, username = UserConfig.getInstance(UserConfig.selectedAccount).getCurrentUser(), None
        if pi_user: username = pi_user.username
        logo_text = " • ".join(filter(None, ["TGfy" if self.get_setting("show_tgfy_logo", True) else None, f"@{username}" if self.get_setting("show_username", False) and username else None]))
        if logo_text:
            text_y += 6
            logo_font = self._get_font(20)
            self._draw_text_with_shadow(draw, (text_x, text_y), logo_text, logo_font, artist_color, text_shadow_enabled, text_shadow_color, text_shadow_offset)
            text_y += self._get_text_height(logo_text, logo_font)

        text_y += 15

        progress_ratio = progress / duration if duration > 0 else 0
        time_font = self._get_font(16)
        
        if is_vertical:
            bar_y, bar_width, bar_height = height - 90, width - padding*2, 20
            self._draw_progress_bar(draw, bar_style, text_x, bar_y, bar_width, bar_height, progress_ratio, bar_filled_color, bar_unfilled_color)
        else:
            bar_y, bar_width, bar_height = height - padding - 25, width - text_x - padding, 20
            self._draw_progress_bar(draw, bar_style, text_x, bar_y, bar_width, bar_height, progress_ratio, bar_filled_color, bar_unfilled_color)
            
            if bar_style == 0:
                progress_str, duration_str = self._format_time(progress), self._format_time(duration)
                time_y = bar_y - self._get_text_height('0', time_font) - 8
                self._draw_text_with_shadow(draw, (text_x, time_y), progress_str, time_font, time_color, text_shadow_enabled, text_shadow_color, text_shadow_offset)
                duration_width = self._get_text_width(duration_str, time_font)
                self._draw_text_with_shadow(draw, (text_x + bar_width - duration_width, time_y), duration_str, time_font, time_color, text_shadow_enabled, text_shadow_color, text_shadow_offset)

        output_path = os.path.join(self._get_temp_dir(), f"np_{uuid.uuid4()}.png")
        pi_card.save(output_path)
        return output_path
        
    def _send_results(self, image_path: str, song_object, params: Any):
        peer_id = params.peer
        send_card, send_audio = self.get_setting("send_card", True), self.get_setting("send_audio", True)
        
        if send_card and image_path:
            try:
                photo = get_send_messages_helper().generatePhotoSizes(image_path, None)
                if photo:
                    caption = self.get_setting("custom_caption", "Сейчас играет в Telegram") if self.get_setting("show_caption", True) else None
                    send_message({"peer": peer_id, "photo": photo, "path": image_path, "caption": caption, "replyToMsg": getattr(params, 'replyToMsg', None)})
                threading.Timer(15, lambda: os.remove(image_path) if os.path.exists(image_path) else None).start()
            except Exception as e:
                log(f"[{self.id}] Ошибка при отправке карточки: {e}")

        if send_audio:
            try:
                audio_file = FileLoader.getInstance(UserConfig.selectedAccount).getPathToMessage(song_object.messageOwner)
                if audio_file and audio_file.exists():
                    SendMessagesHelper.prepareSendingDocument(UserConfig.selectedAccount, audio_file.getAbsolutePath(), audio_file.getAbsolutePath(), None, song_object.getMimeType(), peer_id, getattr(params, 'replyToMsg', None), None, None, None, None, False, 0, None, 0, False, False)
            except Exception as e:
                log(f"[{self.id}] Ошибка при отправке аудио: {e}")

    def _show_loading_dialog(self):
        last_fragment = get_last_fragment()
        if last_fragment and last_fragment.getParentActivity():
            builder = AlertDialogBuilder(last_fragment.getParentActivity(), AlertDialogBuilder.ALERT_TYPE_SPINNER)
            builder.set_title("Создание карточки...")
            builder.set_cancelable(False)
            self.progress_dialog = builder.show()

    def _dismiss_loading_dialog(self):
        if self.progress_dialog:
            try: self.progress_dialog.dismiss()
            except Exception: pass
            self.progress_dialog = None