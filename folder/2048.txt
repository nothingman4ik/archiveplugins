__id__ = "game_2048_new"
__name__ = "2048 Game"
__description__ = """🇷🇺[RU]\nИгра 2048, разработчик: @SaturnFake, канал разработчика: @DevPluginsEUG\n\n🇬🇧[EN]\n2048 Game, developer: @SaturnFake, developer channel: @DevPluginsEUG"""
__author__ = "@SaturnFake"
__icon__ = "Plugins_Test/7"
__min_version__ = "11.12.1"
__version__ = "1.0.0"

from client_utils import get_last_fragment
from ui.alert import AlertDialogBuilder
from java import jint
from typing import Any
from base_plugin import BasePlugin, HookResult, HookStrategy, MenuItemData, MenuItemType, AppEvent
from android_utils import run_on_ui_thread, log
from ui.alert import AlertDialogBuilder
from android.widget import GridLayout, TextView, Button, LinearLayout, FrameLayout
from android.view import View, ViewGroup, MotionEvent, Gravity
from android.graphics import Color, Typeface
from android.graphics.drawable import GradientDrawable, StateListDrawable
from org.telegram.messenger import LocaleController, AndroidUtilities
from java import dynamic_proxy
import random

TILE_COLORS = {
    0: "#cdc1b4",
    2: "#eee4da",
    4: "#ede0c8",
    8: "#f2b179",
    16: "#f59563",
    32: "#f67c5f",
    64: "#f65e3b",
    128: "#edcf72",
    256: "#edcc61",
    512: "#edc850",
    1024: "#edc53f",
    2048: "#edc22e"
}

TEXT_COLORS = {
    2: "#776e65",
    4: "#776e65",
    8: "#f9f6f2",
    16: "#f9f6f2",
    32: "#f9f6f2",
    64: "#f9f6f2",
    128: "#f9f6f2",
    256: "#f9f6f2",
    512: "#f9f6f2",
    1024: "#f9f6f2",
    2048: "#f9f6f2"
}

STATE_PRESSED = [1]
GRID_PADDING = 1
TILE_MARGIN = 1

def t(key, **kwargs):
    lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
    ru = {
        "game_title": "2048",
        "score": "Счет",
        "best": "Лучший",
        "restart": "Новая игра",
        "game_over": "Игра окончена!",
        "game_over_text": "Попробуйте еще раз нажав на Новая игра",
        "win": "Победа!",
        "win_text": "Вы достигли 2048!",
        "instructions": "📱 Используйте свайпы для перемещения плиток\n🎯 Цель: объединяйте плитки с одинаковыми числами, чтобы получить 2048!",
        "menu_title": "2048",
        "command_help": "Используйте команду '.2048' или меню для запуска игры"
    }
    en = {
        "game_title": "2048",
        "score": "Score",
        "best": "Best",
        "restart": "New Game",
        "game_over": "Game Over!",
        "game_over_text": "Try again by clicking New Game",
        "win": "You Win!",
        "win_text": "You reached 2048!",
        "instructions": "📱 Swipe to move tiles\n🎯 Goal: Combine tiles with the same numbers to get 2048!",
        "menu_title": "2048",
        "command_help": "Use '.2048' command or menu to start the game"
    }
    d = ru if lang.startswith("ru") else en
    val = d.get(key, key)
    if kwargs:
        return val.format(**kwargs)
    return val

def create_button(context, text, bg_color, text_size=10, corner_radius=3):
    button = Button(context)
    button.setText(text)
    button.setTextColor(Color.WHITE)
    button.setTypeface(None, Typeface.BOLD)
    button.setTextSize(text_size)
    button.setShadowLayer(0, 0, 0, 0)
    
    state_list = StateListDrawable()
    normal_drawable = GradientDrawable()
    normal_drawable.setColor(Color.parseColor(bg_color))
    normal_drawable.setCornerRadius(AndroidUtilities.dp(corner_radius))
    
    pressed_drawable = GradientDrawable()
    pressed_drawable.setColor(Color.parseColor(bg_color))
    pressed_drawable.setCornerRadius(AndroidUtilities.dp(corner_radius))
    pressed_drawable.setAlpha(180)
    
    state_list.addState([], normal_drawable)
    state_list.addState(STATE_PRESSED, pressed_drawable)
    button.setBackground(state_list)
    button.setElevation(AndroidUtilities.dp(0.5))
    
    return button

def create_tile_view(context, value, size):
    tile = TextView(context)
    tile.setGravity(Gravity.CENTER)
    
    text_size = 10
    if value >= 1024:
        text_size = 7
    elif value >= 128:
        text_size = 8
    elif value >= 16:
        text_size = 9
    
    tile.setTextSize(text_size)
    tile.setTypeface(None, Typeface.BOLD)
    
    bg = GradientDrawable()
    bg.setCornerRadius(AndroidUtilities.dp(1.5))
    
    if value > 0:
        tile.setText(str(value))
        bg.setColor(Color.parseColor(TILE_COLORS.get(value, "#3c3a32")))
        tile.setTextColor(Color.parseColor(TEXT_COLORS.get(value, "#f9f6f2")))
    else:
        bg.setColor(Color.parseColor(TILE_COLORS[0]))
    
    tile.setBackground(bg)
    return tile

class Game2048:
    def __init__(self):
        self.size = 4
        self.grid = [[0 for _ in range(self.size)] for _ in range(self.size)]
        self.score = 0
        self.best_score = 0
        self.game_over = False
        self.win = False
        self.add_random_tile()
        self.add_random_tile()
    
    def add_random_tile(self):
        empty_cells = []
        for i in range(self.size):
            for j in range(self.size):
                if self.grid[i][j] == 0:
                    empty_cells.append((i, j))
        
        if empty_cells:
            i, j = random.choice(empty_cells)
            self.grid[i][j] = 2 if random.random() < 0.9 else 4
            return True
        return False
    
    def move(self, direction):
        if self.game_over:
            return False
        
        moved = False
        grid_before = [row[:] for row in self.grid]
        
        if direction == 0:
            moved = self.move_up()
        elif direction == 1:
            moved = self.move_right()
        elif direction == 2:
            moved = self.move_down()
        elif direction == 3:
            moved = self.move_left()
        
        if moved:
            self.add_random_tile()
            self.check_game_state()
        
        return moved
    
    def move_left(self):
        moved = False
        for i in range(self.size):
            row = [x for x in self.grid[i] if x != 0]
            new_row = []
            skip = False
            
            for j in range(len(row)):
                if skip:
                    skip = False
                    continue
                
                if j < len(row) - 1 and row[j] == row[j+1]:
                    new_row.append(row[j] * 2)
                    self.score += row[j] * 2
                    skip = True
                    moved = True
                else:
                    new_row.append(row[j])
            
            new_row += [0] * (self.size - len(new_row))
            if self.grid[i] != new_row:
                moved = True
            self.grid[i] = new_row
        
        return moved
    
    def move_right(self):
        moved = False
        for i in range(self.size):
            row = [x for x in self.grid[i] if x != 0]
            new_row = []
            skip = False
            
            for j in range(len(row)-1, -1, -1):
                if skip:
                    skip = False
                    continue
                
                if j > 0 and row[j] == row[j-1]:
                    new_row.insert(0, row[j] * 2)
                    self.score += row[j] * 2
                    skip = True
                    moved = True
                else:
                    new_row.insert(0, row[j])
            
            new_row = [0] * (self.size - len(new_row)) + new_row
            if self.grid[i] != new_row:
                moved = True
            self.grid[i] = new_row
        
        return moved
    
    def move_up(self):
        moved = False
        for j in range(self.size):
            col = [self.grid[i][j] for i in range(self.size) if self.grid[i][j] != 0]
            new_col = []
            skip = False
            
            for i in range(len(col)):
                if skip:
                    skip = False
                    continue
                
                if i < len(col) - 1 and col[i] == col[i+1]:
                    new_col.append(col[i] * 2)
                    self.score += col[i] * 2
                    skip = True
                    moved = True
                else:
                    new_col.append(col[i])
            
            new_col += [0] * (self.size - len(new_col))
            for i in range(self.size):
                if self.grid[i][j] != new_col[i]:
                    moved = True
                self.grid[i][j] = new_col[i]
        
        return moved
    
    def move_down(self):
        moved = False
        for j in range(self.size):
            col = [self.grid[i][j] for i in range(self.size) if self.grid[i][j] != 0]
            new_col = []
            skip = False
            
            for i in range(len(col)-1, -1, -1):
                if skip:
                    skip = False
                    continue
                
                if i > 0 and col[i] == col[i-1]:
                    new_col.insert(0, col[i] * 2)
                    self.score += col[i] * 2
                    skip = True
                    moved = True
                else:
                    new_col.insert(0, col[i])
            
            new_col = [0] * (self.size - len(new_col)) + new_col
            for i in range(self.size):
                if self.grid[i][j] != new_col[i]:
                    moved = True
                self.grid[i][j] = new_col[i]
        
        return moved
    
    def check_game_state(self):
        for i in range(self.size):
            for j in range(self.size):
                if self.grid[i][j] == 2048:
                    self.win = True
                    return
        
        for i in range(self.size):
            for j in range(self.size):
                if self.grid[i][j] == 0:
                    return
                
                if i < self.size - 1 and self.grid[i][j] == self.grid[i+1][j]:
                    return
                
                if j < self.size - 1 and self.grid[i][j] == self.grid[i][j+1]:
                    return
        
        self.game_over = True
    
    def reset(self):
        self.grid = [[0 for _ in range(self.size)] for _ in range(self.size)]
        self.score = 0
        self.game_over = False
        self.win = False
        self.add_random_tile()
        self.add_random_tile()

class Game2048Plugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.game = Game2048()
        self.dialog = None
        self.activity = None
        self.grid_layout = None
        self.score_view = None
        self.best_view = None
        self.game_over_view = None
        self.win_view = None
        self.tile_size = 0
        self.start_x = 0
        self.start_y = 0
        self.min_swipe = AndroidUtilities.dp(40)
        self.best_score = 0

    def on_plugin_load(self):
        self.best_score = self.get_setting("2048_best", 0)
        self.game.best_score = self.best_score
        self.add_on_send_message_hook()
        self.add_menu_item(MenuItemData(
            menu_type=MenuItemType.CHAT_ACTION_MENU,
            text=t("menu_title"),
            icon="msg_media",
            on_click=self.show_game_dialog
        ))

    def on_plugin_unload(self):
        self.close_game()

    def on_send_message_hook(self, account: int, params) -> HookResult:
        if isinstance(params.message, str) and params.message.strip().lower() in [".2048", ".game2048"]:
            try:
                self.show_game_dialog()
                return HookResult(strategy=HookStrategy.CANCEL)
            except Exception as e:
                log(f"2048 error: {str(e)}")
                params.message = f"🚫 {t('command_help')}"
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
        return HookResult()

    def show_game_dialog(self, context=None):           
        current_fragment = get_last_fragment()
        if not current_fragment:
            return
            
        self.activity = current_fragment.getParentActivity()
        if not self.activity:
            return
            
        run_on_ui_thread(self.create_game_dialog)
        
    def create_game_dialog(self):
        builder = AlertDialogBuilder(self.activity)
        builder.set_title(t("game_title"))
        main_container = LinearLayout(self.activity)
        main_container.setOrientation(LinearLayout.VERTICAL)
        padding = AndroidUtilities.dp(2)
        main_container.setPadding(padding, padding, padding, padding)
        bg_drawable = GradientDrawable()
        bg_drawable.setColors([Color.parseColor("#667eea"), Color.parseColor("#764ba2")])
        bg_drawable.setCornerRadius(AndroidUtilities.dp(6))
        main_container.setBackground(bg_drawable)
        inner_container = LinearLayout(self.activity)
        inner_container.setOrientation(LinearLayout.VERTICAL)
        inner_container.setPadding(padding, padding, padding, padding)
        inner_container.setBackgroundColor(Color.parseColor("#faf8ef"))
        inner_container.setElevation(AndroidUtilities.dp(1))
        score_container = LinearLayout(self.activity)
        score_container.setOrientation(LinearLayout.HORIZONTAL)
        score_container.setGravity(Gravity.CENTER_HORIZONTAL)
        score_container.setLayoutParams(LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT
        ))
        score_container.setPadding(0, 0, 0, AndroidUtilities.dp(5))
        score_block = LinearLayout(self.activity)
        score_block.setOrientation(LinearLayout.VERTICAL)
        score_block.setBackgroundColor(Color.parseColor("#bbada0"))
        score_block.setGravity(Gravity.CENTER)
        score_block.setPadding(
            AndroidUtilities.dp(5),
            AndroidUtilities.dp(5),
            AndroidUtilities.dp(5),
            AndroidUtilities.dp(5)
        )
        layout_params = LinearLayout.LayoutParams(
            0,
            ViewGroup.LayoutParams.WRAP_CONTENT,
            1
        )
        layout_params.setMargins(0, 0, AndroidUtilities.dp(5), 0)
        score_block.setLayoutParams(layout_params)
        
        score_label = TextView(self.activity)
        score_label.setText(t("score"))
        score_label.setTextColor(Color.parseColor("#eee4da"))
        score_label.setTextSize(9)
        score_label.setTypeface(None, Typeface.BOLD)
        score_block.addView(score_label)
        
        self.score_view = TextView(self.activity)
        self.score_view.setText("0")
        self.score_view.setTextColor(Color.WHITE)
        self.score_view.setTextSize(12)
        self.score_view.setTypeface(None, Typeface.BOLD)
        score_block.addView(self.score_view)
        best_block = LinearLayout(self.activity)
        best_block.setOrientation(LinearLayout.VERTICAL)
        best_block.setBackgroundColor(Color.parseColor("#bbada0"))
        best_block.setGravity(Gravity.CENTER)
        best_block.setPadding(
            AndroidUtilities.dp(5),
            AndroidUtilities.dp(5),
            AndroidUtilities.dp(5),
            AndroidUtilities.dp(5)
        )
        best_block.setLayoutParams(LinearLayout.LayoutParams(
            0,
            ViewGroup.LayoutParams.WRAP_CONTENT,
            1
        ))
        
        best_label = TextView(self.activity)
        best_label.setText(t("best"))
        best_label.setTextColor(Color.parseColor("#eee4da"))
        best_label.setTextSize(9)
        best_block.addView(best_label)
        
        self.best_view = TextView(self.activity)
        self.best_view.setText(str(self.best_score))
        self.best_view.setTextColor(Color.WHITE)
        self.best_view.setTextSize(12)
        self.best_view.setTypeface(None, Typeface.BOLD)
        best_block.addView(self.best_view)
        score_container.addView(score_block)
        score_container.addView(best_block)
        inner_container.addView(score_container)
        grid_container = FrameLayout(self.activity)
        grid_container.setBackgroundColor(Color.parseColor("#bbada0"))
        grid_container.setPadding(
            AndroidUtilities.dp(GRID_PADDING),
            AndroidUtilities.dp(GRID_PADDING),
            AndroidUtilities.dp(GRID_PADDING),
            AndroidUtilities.dp(GRID_PADDING)
        )
        
        self.grid_layout = GridLayout(self.activity)
        self.grid_layout.setRowCount(4)
        self.grid_layout.setColumnCount(4)
        grid_params = FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.WRAP_CONTENT,
            ViewGroup.LayoutParams.WRAP_CONTENT,
            Gravity.CENTER
        )
        self.grid_layout.setLayoutParams(grid_params)
        
        self.game_over_view = LinearLayout(self.activity)
        self.game_over_view.setOrientation(LinearLayout.VERTICAL)
        self.game_over_view.setGravity(Gravity.CENTER)
        self.game_over_view.setBackgroundColor(Color.parseColor("#FFFFFFDD"))
        self.game_over_view.setVisibility(View.GONE)
        
        game_over_text = TextView(self.activity)
        game_over_text.setText(t("game_over"))
        game_over_text.setTextColor(Color.BLACK)
        game_over_text.setTextSize(10)
        game_over_text.setTypeface(None, Typeface.BOLD)
        self.game_over_view.addView(game_over_text)
        
        game_over_sub = TextView(self.activity)
        game_over_sub.setText(t("game_over_text"))
        game_over_sub.setTextColor(Color.BLACK)
        game_over_sub.setTextSize(8)
        self.game_over_view.addView(game_over_sub)
        
        self.win_view = LinearLayout(self.activity)
        self.win_view.setOrientation(LinearLayout.VERTICAL)
        self.win_view.setGravity(Gravity.CENTER)
        self.win_view.setBackgroundColor(Color.parseColor("#EDC22EDD"))
        self.win_view.setVisibility(View.GONE)
        
        win_text = TextView(self.activity)
        win_text.setText(t("win"))
        win_text.setTextColor(Color.WHITE)
        win_text.setTextSize(10)
        win_text.setTypeface(None, Typeface.BOLD)
        self.win_view.addView(win_text)
        
        win_sub = TextView(self.activity)
        win_sub.setText(t("win_text"))
        win_sub.setTextColor(Color.WHITE)
        win_sub.setTextSize(8)
        self.win_view.addView(win_sub)
        
        grid_container.addView(self.grid_layout)
        grid_container.addView(self.game_over_view)
        grid_container.addView(self.win_view)
        inner_container.addView(grid_container)
        
        instructions = TextView(self.activity)
        instructions.setText(t("instructions"))
        instructions.setTextColor(Color.parseColor("#776e65"))
        instructions.setTextSize(8)
        instructions.setPadding(0, AndroidUtilities.dp(5), 0, AndroidUtilities.dp(5))
        inner_container.addView(instructions)
        
        restart_btn = create_button(self.activity, t("restart"), "#8f7a66", 9, 2)
        restart_btn.setOnClickListener(self.RestartClickListener(self))
        inner_container.addView(restart_btn)
        
        main_container.addView(inner_container)
        
        grid_container.setOnTouchListener(self.GameTouchListener(self))
        
        builder.set_view(main_container)
        builder.set_cancelable(True)
        self.dialog = builder.create()
        self.dialog.show()
        
        self.update_grid()
    
    def update_grid(self):
        if not self.grid_layout or not self.activity:
            return
            
        self.grid_layout.removeAllViews()
        self.score_view.setText(str(self.game.score))
        self.best_view.setText(str(self.game.best_score))
        
        screen_width = self.activity.getResources().getDisplayMetrics().widthPixels
        available_width = screen_width - AndroidUtilities.dp(50)
        
        tile_total_size = min(available_width // 4, AndroidUtilities.dp(70))
        self.tile_size = tile_total_size - AndroidUtilities.dp(TILE_MARGIN * 2)
        
        grid_size = tile_total_size * 4
        
        grid_params = FrameLayout.LayoutParams(
            grid_size,
            grid_size,
            Gravity.CENTER
        )
        self.grid_layout.setLayoutParams(grid_params)
        
        for i in range(4):
            for j in range(4):
                value = self.game.grid[i][j]
                tile = create_tile_view(self.activity, value, self.tile_size)
                
                params = GridLayout.LayoutParams()
                params.width = self.tile_size
                params.height = self.tile_size
                params.setMargins(
                    AndroidUtilities.dp(TILE_MARGIN),
                    AndroidUtilities.dp(TILE_MARGIN),
                    AndroidUtilities.dp(TILE_MARGIN),
                    AndroidUtilities.dp(TILE_MARGIN)
                )
                params.rowSpec = GridLayout.spec(i)
                params.columnSpec = GridLayout.spec(j)
                
                tile.setLayoutParams(params)
                self.grid_layout.addView(tile)
        
        if self.game.game_over:
            self.game_over_view.setVisibility(View.VISIBLE)
        else:
            self.game_over_view.setVisibility(View.GONE)
        
        if self.game.win:
            self.win_view.setVisibility(View.VISIBLE)
        else:
            self.win_view.setVisibility(View.GONE)
        
        if self.game.score > self.best_score:
            self.best_score = self.game.score
            self.game.best_score = self.best_score
            self.set_setting("2048_best", self.best_score)
    
    def close_game(self):
        if self.dialog:
            self.dialog.dismiss()
            self.dialog = None
    
    def handle_swipe(self, dx, dy):
        if abs(dx) > abs(dy):
            if dx > self.min_swipe:
                self.game.move(1)
            elif dx < -self.min_swipe:
                self.game.move(3)
        else:
            if dy > self.min_swipe:
                self.game.move(2)
            elif dy < -self.min_swipe:
                self.game.move(0)
        
        self.update_grid()
    
    class RestartClickListener(dynamic_proxy(View.OnClickListener)):
        def __init__(self, plugin):
            super().__init__()
            self.plugin = plugin
        
        def onClick(self, v):
            self.plugin.game.reset()
            self.plugin.update_grid()
    
    class GameTouchListener(dynamic_proxy(View.OnTouchListener)):
        def __init__(self, plugin):
            super().__init__()
            self.plugin = plugin
            
        def onTouch(self, v, event):
            action = event.getAction()
            
            if action == MotionEvent.ACTION_DOWN:
                self.plugin.start_x = event.getX()
                self.plugin.start_y = event.getY()
                return True
            
            elif action == MotionEvent.ACTION_UP:
                end_x = event.getX()
                end_y = event.getY()
                dx = end_x - self.plugin.start_x
                dy = end_y - self.plugin.start_y
                self.plugin.handle_swipe(dx, dy)
                return True
            
            return False