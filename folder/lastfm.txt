import io
import requests
import os
import uuid
import time
import math
from PIL import Image, ImageDraw, ImageFont, ImageFilter, ImageEnhance
from java.io import File
from java.util import Locale
from org.telegram.messenger import ApplicationLoader
from org.telegram.tgnet.tl import TL_account
from ui.settings import Header, Input, Switch, Divider, Selector, Text
from client_utils import send_message, get_send_messages_helper, get_last_fragment, get_messages_controller, get_user_config, send_request
from base_plugin import BasePlugin, HookResult, HookStrategy
from org.telegram.ui.ActionBar import AlertDialog
from android_utils import log
import threading
from typing import Optional, Any
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder

__id__ = "lastfm"
__name__ = "LastFM"
__version__ = "1.6.6"
__description__ = "–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∞–∫—Ç—É–∞–ª—å–Ω—É—é –ø–µ—Å–Ω—é LastFM. [.np]"
__author__ = "@ArThirtyFour | @KangelPlugins"
__min_version__ = "11.9.0"
__icon__ = "OMGKAWAIIANGELGOD/0"

API_KEY = "460cda35be2fbf4f28e8ea7a38580730"
TEMP_DIR_NAME = "temp_lastfm_covers"
DEFAULT_STREAM_STRING = "üéµ {title} ‚Äî {artist}"
DEFAULT_STREAM_TEXT = "Hi, I use exteraGram"

FONTS = {
    "NotoSansJP": "https://github.com/itsNightly/font_link/raw/refs/heads/main/NotoSansJP-Regular.ttf",
    "TimesNewRoman": "https://github.com/Ar-ThirtyFour/Fonts_For_Exteragram/raw/refs/heads/main/timesnewromanpsmt.ttf",
    "Impact": "https://github.com/Ar-ThirtyFour/Fonts_For_Exteragram/raw/refs/heads/main/Impact.ttf"
}

FONT_DISPLAY_NAMES = {
    "NotoSansJP": "Noto Sans JP",
    "TimesNewRoman": "Times New Roman", 
    "Impact": "Impact"
}

progress_dialog = None

class AlertManager:
    def __init__(self):
        self.alert_builder_instance: Optional[AlertDialogBuilder] = None

    def show_info_alert(self, title: str, message: str, positive_button: str):
        last_fragment = get_last_fragment()
        if not last_fragment or not last_fragment.getParentActivity(): return
        context = last_fragment.getParentActivity()
        builder = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        self.alert_builder_instance = builder
        builder.set_title(title)
        builder.set_message(message)
        builder.set_positive_button(positive_button, lambda d, w: self.dismiss_dialog())
        builder.set_cancelable(True)
        builder.set_canceled_on_touch_outside(True)
        builder.show()

    def dismiss_dialog(self):
        if self.alert_builder_instance and self.alert_builder_instance.get_dialog() and self.alert_builder_instance.get_dialog().isShowing():
            self.alert_builder_instance.dismiss()
            self.alert_builder_instance = None

class LocalizationManager:
    strings = {
        "ru": {
            "FONT_FAQ_TITLE": "üé® –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã",
            "FONT_FAQ_TEXT": (
                "üìù –ö–∞–∫ –¥–æ–±–∞–≤–∏—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç?\n\n"
                "1Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ '–ö–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç' –≤ —Å–µ–ª–µ–∫—Ç–æ—Ä–µ —à—Ä–∏—Ñ—Ç–æ–≤\n\n"
                "2Ô∏è‚É£ –í –ø–æ–ª–µ '–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç' –≤—Å—Ç–∞–≤—å—Ç–µ –ø—Ä—è–º—É—é —Å—Å—ã–ª–∫—É –Ω–∞ .ttf —Ñ–∞–π–ª\n\n"
                "üîó –ü—Ä–∏–º–µ—Ä—ã —Å—Å—ã–ª–æ–∫:\n"
                "‚Ä¢ https://example.com/font.ttf\n"
                "‚Ä¢ https://fonts.gstatic.com/s/roboto/v30/font.ttf\n\n"
                "üí° –ò –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –¢–ê–ú –î–û–õ–ñ–ï–ù –ë–´–¢–¨ –í –ö–û–ù–¶–ï .ttf\n\n"
                "3Ô∏è‚É£ –°–æ–∑–¥–∞–π—Ç–µ –∫–∞—Ä—Ç–æ—á–∫—É –∫–æ–º–∞–Ω–¥–æ–π .np\n\n"
                "‚ö° –ü–ª–∞–≥–∏–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–∫–∞—á–∞–µ—Ç —à—Ä–∏—Ñ—Ç –∏ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ!\n\n"
                "üö® –í–ê–ñ–ù–û! –ü–†–ò –ü–ï–†–í–û–ú –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ò/–°–ú–ï–ù–ï –®–†–ò–§–¢–ê –ë–£–î–ï–¢ –î–û–õ–¨–®–ï –°–û–ó–î–ê–í–ê–¢–¨–°–Ø –ß–ï–ú –û–ë–´–ß–ù–û\n\n"
                "üíª –ê–≤—Ç–æ—Ä —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç –∑–∞–≥—Ä—É–∂–∞—Ç—å —à—Ä–∏—Ñ—Ç—ã –Ω–∞ Github\n\n"
                "üåê –°–∞–π—Ç—ã –≥–¥–µ –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ —à—Ä–∏—Ñ—Ç—ã (—Å –ø—Ä—è–º—ã–º–∏ —Å—Å—ã–ª–∫–∞–º–∏):\n"
                "‚Ä¢ https://fontsaddict.com\n\n"
                "‚Ä¢ https://en.bestfonts.pro\n\n"
            ),
            "ALERT_CLOSE_BUTTON": "‚úÖ –ü–æ–Ω—è–ª"
        },
        "en": {
            "FONT_FAQ_TITLE": "üé® How to use custom fonts",
            "FONT_FAQ_TEXT": (
                "üìù How to add a custom font?\n\n"
                "1Ô∏è‚É£ Select 'Custom font' in the font selector\n\n"
                "2Ô∏è‚É£ In the 'Custom font link' field, paste a direct link to the .ttf file\n\n"
                "üîó Example links:\n"
                "‚Ä¢ https://example.com/font.ttf\n"
                "‚Ä¢ https://fonts.gstatic.com/s/roboto/v30/font.ttf\n\n"
                "üí° AND THERE MUST BE .ttf AT THE END\n\n"
                "3Ô∏è‚É£ Create a card with .np command\n\n"
                "‚ö° The plugin will automatically download the font and use it!\n\n"
                "üö® IMPORTANT! ON FIRST USE/FONT CHANGE, IT WILL TAKE LONGER TO CREATE THAN USUAL\n\n"
                "üíª The author recommends uploading fonts to Github\n\n"
                "üåê Sites where you can find fonts (with direct links):\n"
                "‚Ä¢ https://fontsaddict.com\n\n"
                "‚Ä¢ https://en.bestfonts.pro\n\n"
            ),
            "ALERT_CLOSE_BUTTON": "‚úÖ Got it"
        }
    }

    def __init__(self):
        self.language = Locale.getDefault().getLanguage()
        self.language = self.language if self.language in self.strings else "en"

    def get_string(self, key: str) -> str:
        return self.strings[self.language].get(key, self.strings["en"].get(key, key))

locali = LocalizationManager()


class LastFMPlugin(BasePlugin):

    def __init__(self):
        super().__init__()
        self._temp_dir = None
        self.alert_manager = AlertManager()
        threading.Thread(target=self._streamer, daemon=True).start()

    def _streamer(self):
        log("[LastFM] Streamer started")
        while True:
            try:
                try:
                    update_interval = int(self.get_setting("update_interval", "30"))
                    if update_interval < 5:
                        update_interval = 5
                except:
                    update_interval = 30
                
                if self.get_setting("update_bio", False):
                    log("[LastFM] Update bio is enabled")
                    userFull = get_messages_controller().getUserFull(get_user_config().getClientUserId())
                    if not userFull:
                        log("[LastFM] Failed to get userFull")
                        time.sleep(update_interval)
                        continue

                    stream_place = self.get_setting("stream_place", 1 if get_user_config().isPremium() else 0)
                    max_len = 140 if get_user_config().isPremium() else 70

                    username = self.get_setting("lastfm_username", "")
                    if not username:
                        log("[LastFM] LastFM username is not set")
                        time.sleep(update_interval)
                        continue

                    log(f"[LastFM] Fetching track for user {username}")
                    current_track_url = f'http://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&nowplaying=true&user={username}&api_key={API_KEY}&format=json'
                    response = requests.get(current_track_url)
                    
                    if response.status_code == 200:
                        data = response.json()
                        log(f"[LastFM] Got response: {data}")
                        if 'recenttracks' in data and 'track' in data['recenttracks'] and data['recenttracks']['track']:
                            log(f"[LastFM] Found tracks in response: {len(data['recenttracks']['track'])} tracks")
                            nowplaying_track = None
                            for track in data['recenttracks']['track']:
                                if '@attr' in track and 'nowplaying' in track['@attr']:
                                    nowplaying_track = track
                                    log(f"[LastFM] Found now playing track: {track}")
                                    break

                            if nowplaying_track:
                                log(f"[LastFM] Processing now playing track")
                                track_info = {
                                    'name': nowplaying_track.get('name', 'Unknown Track'),
                                    'artist': nowplaying_track.get('artist', {}).get('#text', 'Unknown Artist'),
                                    'album_image': None
                                }

                                log(f"[LastFM] Track info: {track_info}")

                                images = nowplaying_track.get('image', [])
                                log(f"[LastFM] Available images: {images}")
                                for size in ['extralarge', 'large', 'medium', 'small']:
                                    for img in images:
                                        if img.get('size') == size:
                                            track_info['album_image'] = img.get('#text')
                                            if track_info['album_image'] and track_info['album_image'].strip():
                                                log(f"[LastFM] Selected image size {size}: {track_info['album_image']}")
                                                break
                                    if track_info['album_image']:
                                        break

                                log(f"[LastFM] Final track info: {track_info}")
                                
                                try:
                                    
                                    np_format = self.get_setting("track_display_format", DEFAULT_STREAM_STRING)
                                    bio_text = np_format.replace("{title}", track_info['name']).replace("{artist}", track_info['artist'])
                                    
                                    if stream_place == 0:
                                        if userFull.about != bio_text[:max_len]:
                                            try:
                                                req = TL_account.updateProfile()
                                                req.flags = 4
                                                req.about = bio_text[:max_len]
                                                send_request(req, ())
                                                log(f"[LastFM] Updated bio with: {bio_text[:max_len]}")
                                            except Exception as e:
                                                log(f"[LastFM] Error updating bio: {e}")
                                    else:
                                        if not get_user_config().isPremium():
                                            log("[LastFM] User is not premium, can't update business location")
                                            time.sleep(update_interval)
                                            continue
                                        try:
                                            req = TL_account.updateBusinessLocation()
                                            req.address = bio_text[:96]
                                            req.flags = 1
                                            send_request(req, ())
                                            log(f"[LastFM] Updated business location with: {bio_text[:96]}")
                                        except Exception as e:
                                            log(f"[LastFM] Error updating business location: {e}")
                                            
                                except Exception as e:
                                    log(f"[LastFM] Error in bio update: {e}")
                                    import traceback
                                    log(f"[LastFM] Traceback: {traceback.format_exc()}")

                            else:
                                log("[LastFM] No now playing track found")
                                default_bio = self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT)
                                if stream_place == 0:
                                    if userFull.about != default_bio[:max_len]:
                                        try:
                                            req = TL_account.updateProfile()
                                            req.flags = 4
                                            req.about = default_bio[:max_len]
                                            send_request(req, ())
                                            log("[LastFM] Set default bio")
                                        except Exception as e:
                                            log(f"[LastFM] Error setting default bio: {e}")
                                else:
                                    if not get_user_config().isPremium():
                                        log("[LastFM] User is not premium, can't update business location")
                                        time.sleep(update_interval)
                                        continue
                                    try:
                                        req = TL_account.updateBusinessLocation()
                                        req.address = default_bio[:96]
                                        req.flags = 1
                                        send_request(req, ())
                                        log("[LastFM] Set default bio in business location")
                                    except Exception as e:
                                        log(f"[LastFM] Error setting default bio in business location: {e}")
                        else:
                            log("[LastFM] No tracks found in response")
                    else:
                        log(f"[LastFM] Bad response from LastFM API: {response.status_code}")
                        default_bio = self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT)
                        if stream_place == 0:
                            if userFull.about != default_bio[:max_len]:
                                try:
                                    req = TL_account.updateProfile()
                                    req.flags = 4
                                    req.about = default_bio[:max_len]
                                    send_request(req, ())
                                    log("[LastFM] Set default bio after bad response")
                                except Exception as e:
                                    log(f"[LastFM] Error setting default bio after bad response: {e}")
                        else:
                            if not get_user_config().isPremium():
                                log("[LastFM] User is not premium, can't update business location")
                                time.sleep(update_interval)
                                continue
                            try:
                                req = TL_account.updateBusinessLocation()
                                req.address = default_bio[:96]
                                req.flags = 1
                                send_request(req, ())
                                log("[LastFM] Set default bio in business location after bad response")
                            except Exception as e:
                                log(f"[LastFM] Error setting default bio in business location after bad response: {e}")

                time.sleep(update_interval)
            except Exception as e:
                log(f"[LastFM] Streamer error: {e}")
                time.sleep(10)

    def _dismiss_dialog(self):
        global progress_dialog
        try:
            if progress_dialog is not None and progress_dialog.isShowing():
                progress_dialog.dismiss()
        except Exception:
            pass
        finally:
            progress_dialog = None

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self._temp_dir = self._get_temp_dir()
        if self._temp_dir:
            threading.Thread(target=self._download_fonts, daemon=True).start()
            log("LastFM plugin loaded successfully")
        else:
            log("Failed to initialize temp directory for LastFM")

    def on_plugin_unload(self):
        log("LastFM plugin unloaded")
        self.alert_manager.dismiss_dialog()

    def _download_fonts(self):
        try:
            for font_name, font_url in FONTS.items():
                font_path = File(self._temp_dir, f"{font_name}-Regular.ttf").getAbsolutePath()
                if not os.path.exists(font_path):
                    response = requests.get(font_url)
                    with open(font_path, 'wb') as f:
                        f.write(response.content)
                    log(f"Downloaded font: {font_name}")
        except Exception as e:
            log(f"Error downloading fonts: {e}")

    def _handle_show_faq_alert_click(self, view):
        title = locali.get_string("FONT_FAQ_TITLE")
        text = locali.get_string("FONT_FAQ_TEXT")
        close_button = locali.get_string("ALERT_CLOSE_BUTTON")
        self.alert_manager.show_info_alert(title, text, close_button)

    def create_settings(self):
        lang = Locale.getDefault().getLanguage()
        update_bio = self.get_setting("update_bio", False)

        if lang.startswith('ru'):
            user_header = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å LastFM"
            user_input_text = "–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"
            user_input_subtext = "–£–∫–∞–∂–∏—Ç–µ –≤–∞—à–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è LastFM."
            photo_header = "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è"
            photo_text = "–û—Ç–ø—Ä–∞–≤–ª—è—Ç—å –æ–±–ª–æ–∂–∫—É –∞–ª—å–±–æ–º–∞"
            photo_subtext = "–í–∫–ª—é—á–∏—Ç–µ, —á—Ç–æ–±—ã –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –æ–±–ª–æ–∂–∫—É –∞–ª—å–±–æ–º–∞ –≤–º–µ—Å—Ç–µ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ —Ç—Ä–µ–∫–µ."
            np_format_text = "–§–æ—Ä–º–∞—Ç .np"
            np_format_subtext = "–§–æ—Ä–º–∞—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ç—Ä–µ–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ .np. {title} ‚Äî –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞, {artist} ‚Äî –∞—Ä—Ç–∏—Å—Ç"
            font_header = "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —à—Ä–∏—Ñ—Ç–∞ –∫–∞—Ä—Ç–æ—á–∫–∏"
            font_text = "–®—Ä–∏—Ñ—Ç –∫–∞—Ä—Ç–æ—á–∫–∏"
            font_subtext = "–í—ã–±–µ—Ä–∏—Ç–µ —à—Ä–∏—Ñ—Ç –¥–ª—è –∫–∞—Ä—Ç–æ—á–∫–∏ .np"
            custom_font_text = "–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç"
            custom_font_subtext = "–°—Å—ã–ª–∫–∞ –Ω–∞ .ttf —Ñ–∞–π–ª –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–µ"
            stream_header = "–ü–æ—Ç–æ–∫ –≤ –ø—Ä–æ—Ñ–∏–ª—å"
            stream_text = "–°—Ç—Ä–∏–º —Ç—Ä–µ–∫–∞ –≤ –ø—Ä–æ—Ñ–∏–ª—å"
            stream_subtext = "–û–±–Ω–æ–≤–ª—è–µ—Ç –±–∏–æ/–≥–µ–æ–ª–æ–∫–∞—Ü–∏—é —Ç–µ–∫—É—â–∏–º —Ç—Ä–µ–∫–æ–º"
            stream_place_text = "–¢—Ä–∞–Ω—Å–ª–∏—Ä–æ–≤–∞—Ç—å –≤ ..."
            stream_place_item1 = "–ë–∏–æ"
            stream_place_item2 = "–ì–µ–æ–ª–æ–∫–∞—Ü–∏—é (–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)"
            stream_format_text = "–§–æ—Ä–º–∞—Ç"
            stream_format_subtext = "–§–æ—Ä–º–∞—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ç—Ä–µ–∫–∞. {title} ‚Äî –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞, {artist} ‚Äî –∞—Ä—Ç–∏—Å—Ç"
            stream_default_text = "–¢–µ–∫—Å—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é"
            stream_default_subtext = "–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è, –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è"
            update_interval_text = "–ò–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è"
            update_interval_subtext = "–ö–∞–∫ —á–∞—Å—Ç–æ –æ–±–Ω–æ–≤–ª—è—Ç—å —Ç–µ–∫—Å—Ç –≤ –ø—Ä–æ—Ñ–∏–ª–µ (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)"
        else:
            user_header = "LastFM User"
            user_input_text = "Username"
            user_input_subtext = "Set your LastFM username."
            photo_header = "Display Settings"
            photo_text = "Send album cover"
            photo_subtext = "Enable to send album cover along with track information."
            np_format_text = ".np Format"
            np_format_subtext = "Format for .np command display. {title} ‚Äî track name, {artist} ‚Äî artist"
            font_header = "Card Font Settings"
            font_text = "Card font"
            font_subtext = "Choose font for .np card"
            custom_font_text = "Custom font link"
            custom_font_subtext = "URL to .ttf file on the internet"
            stream_header = "Profile Streaming"
            stream_text = "Stream track to profile"
            stream_subtext = "Updates bio/location with currently playing track"
            stream_place_text = "Stream to..."
            stream_place_item1 = "Bio"
            stream_place_item2 = "Location (Recommended)"
            stream_format_text = "Format"
            stream_format_subtext = "Customize track display. {title} ‚Äî track name, {artist} ‚Äî artist"
            stream_default_text = "Default Text"
            stream_default_subtext = "Displayed when no track is playing"
            update_interval_text = "Update Interval"
            update_interval_subtext = "How often to update profile text (in seconds)"

        font_items = ["Noto Sans JP", "Times New Roman", "Impact", "–ö–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç" if lang.startswith('ru') else "Custom font"]

        settings = [
            Header(text=user_header),
            Input(
                key="lastfm_username",
                text=user_input_text,
                default="",
                subtext=user_input_subtext,
                icon="menu_username_change"
            ),
            Header(text=photo_header),
            Switch(
                key="send_album_cover",
                text=photo_text,
                default=True,
                subtext=photo_subtext,
                icon="msg_photos"
            ),
            Input(
                key="np_display_format",
                text=np_format_text,
                default=DEFAULT_STREAM_STRING,
                subtext=np_format_subtext,
                icon="msg_view_file"
            ),
            Divider(),
            Header(text=font_header),
            Selector(
                key="card_font_family",
                text=font_text,
                default=0,
                items=font_items,
                icon="msg_photo_text_regular"
            ),
            Input(
                key="custom_font_path",
                text=custom_font_text,
                subtext=custom_font_subtext,
                default="",
                icon="msg_photo_text_regular"
            ),
            Text(
                text="–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã" if lang.startswith('ru') else "How to use custom fonts",
                icon="msg_info",
                on_click=self._handle_show_faq_alert_click
            ),
            Divider(),
            Header(text=stream_header),
            Switch(
                key="update_bio",
                text=stream_text,
                default=False,
                subtext=stream_subtext,
                on_change=lambda new_value: self._show_stream_alert(new_value),
                icon="msg_online"
            ),
            Selector(
                key="stream_place",
                text=stream_place_text,
                default=1 if get_user_config().isPremium() else 0,
                items=[
                    stream_place_item1,
                    stream_place_item2,
                ],
                icon="menu_premium_location" if get_user_config().isPremium() else "msg_openprofile"
            ) if update_bio and get_user_config().isPremium() else None,
            Input(
                key="track_display_format",
                text=stream_format_text,
                default=DEFAULT_STREAM_STRING,
                subtext=stream_format_subtext,
                icon="msg_view_file"
            ) if update_bio else None,
            Input(
                key="default_stream_text",
                text=stream_default_text,
                default=DEFAULT_STREAM_TEXT,
                subtext=stream_default_subtext,
                icon="msg_photo_text_framed3"
            ) if update_bio else None,
            Input(
                key="update_interval",
                text=update_interval_text,
                default="30",
                subtext=update_interval_subtext,
                icon="menu_premium_clock"
            ) if update_bio else None,
        ]
        return [s for s in settings if s is not None]

    def _show_stream_alert(self, value):
        if value:
            lang = Locale.getDefault().getLanguage()
            if lang.startswith('ru'):
                title = "‚ö†Ô∏è‚ö†Ô∏è–í–ù–ò–ú–ê–ù–ò–ï‚ö†Ô∏è‚ö†Ô∏è"
                message = "–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ –∏–∑-–∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π Telegram –Ω–∞ —á–∞—Å—Ç—É—é —Å–º–µ–Ω—É –ø—Ä–æ—Ñ–∏–ª—è. –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–∞ —Å–≤–æ–π —Å—Ç—Ä–∞—Ö –∏ —Ä–∏—Å–∫."
            else:
                title = "‚ö†Ô∏è‚ö†Ô∏èWARNING‚ö†Ô∏è‚ö†Ô∏è"
                message = "This feature may work inconsistently due to Telegram's profile change limits. Your profile information may not update immediately. Use at your own risk."
            fragment = get_last_fragment()
            ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
            dialog = AlertDialog(ctx, 3)
            dialog.setTitle(title)
            dialog.setMessage(message)
            dialog.setButton("OK", None)
            dialog.show()

    def get_temp_dir(self):
        try:
            base_dir = ApplicationLoader.getFilesDirFixed()
            if not base_dir:
                return None
            temp_dir = File(base_dir, TEMP_DIR_NAME)
            if not temp_dir.exists() and not temp_dir.mkdirs():
                return None
            return temp_dir
        except Exception as e:
            log(f"Error getting temp directory: {e}")
            return None

    def download_album_image(self, image_url):
        if not image_url:
            return None
        temp_dir = self.get_temp_dir()
        if not temp_dir or not temp_dir.isDirectory():
            return None
        filename = f"album_{uuid.uuid4()}.jpg"
        temp_photo_path = File(temp_dir, filename).getAbsolutePath()
        try:
            head = requests.head(image_url, timeout=5)
            content_length = int(head.headers.get('content-length', 0))
            if content_length > 5 * 1024 * 1024:
                return None

            resp = requests.get(image_url, stream=True, timeout=10)
            resp.raise_for_status()
            with open(temp_photo_path, 'wb') as f:
                for chunk in resp.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
            return temp_photo_path
        except Exception as e:
            try:
                if os.path.exists(temp_photo_path):
                    os.remove(temp_photo_path)
            except Exception:
                pass
            return None

    def delete_temp_file_async(self, file_path, delay_seconds=5):
        def _delete():
            try:
                time.sleep(delay_seconds)
                if os.path.exists(file_path):
                    os.remove(file_path)
            except Exception as e:
                pass
        threading.Thread(target=_delete, daemon=True).start()

    def on_send_message_hook(self, account, params):
        log(f"[LastFM] on_send_message_hook called with message: {getattr(params, 'message', 'None')}")
        if not hasattr(params, 'message') or not isinstance(params.message, str):
            log("[LastFM] No valid message found, returning")
            return HookResult()

        message_text = params.message.strip()
        command_prefix_now = ".np"
        log(f"[LastFM] Message text: '{message_text}', looking for command: '{command_prefix_now}'")

        lastfm_username = self.get_setting("lastfm_username", "")
        log(f"[LastFM] LastFM username from settings: '{lastfm_username}'")

        if message_text == command_prefix_now:
            log("[LastFM] Command .np detected!")
            if not lastfm_username or lastfm_username == "":
                log("[LastFM] No LastFM username set")
                response_text = "‚ùå –ù–∏–∫ LastFM –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø–ª–∞–≥–∏–Ω–∞."
                params.message = response_text
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
            else:
                log(f"[LastFM] Starting search for user: {lastfm_username}")
                def search_and_reply(peer):
                    log(f"[LastFM] search_and_reply started for peer: {peer}")
                    try:
                        current_track_url = f'http://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&nowplaying=true&user={lastfm_username}&api_key={API_KEY}&format=json'
                        log(f"[LastFM] Requesting URL: {current_track_url}")
                        response = requests.get(current_track_url)
                        log(f"[LastFM] Response status: {response.status_code}")
                        
                        if response.status_code != 200:
                            log(f"[LastFM] Bad response status: {response.status_code}")
                            send_message({
                                "peer": peer,
                                "message": f"‚ùå –û—à–∏–±–∫–∞ API LastFM: HTTP {response.status_code}"
                            })
                            return
                            
                        try:
                            data = response.json()
                            log(f"[LastFM] Response data: {data}")
                        except Exception as e:
                            log(f"[LastFM] Error parsing JSON: {e}")
                            send_message({
                                "peer": peer,
                                "message": "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ—Ç–≤–µ—Ç–∞ –æ—Ç LastFM. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
                            })
                            return

                        if 'recenttracks' in data and 'track' in data['recenttracks'] and data['recenttracks']['track']:
                            log(f"[LastFM] Found tracks in response: {len(data['recenttracks']['track'])} tracks")
                            nowplaying_track = None
                            for track in data['recenttracks']['track']:
                                if '@attr' in track and 'nowplaying' in track['@attr']:
                                    nowplaying_track = track
                                    log(f"[LastFM] Found now playing track: {track}")
                                    break

                            if nowplaying_track:
                                log(f"[LastFM] Processing now playing track")
                                track_info = {
                                    'name': nowplaying_track.get('name', 'Unknown Track'),
                                    'artist': nowplaying_track.get('artist', {}).get('#text', 'Unknown Artist'),
                                    'album_image': None
                                }

                                log(f"[LastFM] Track info: {track_info}")

                                images = nowplaying_track.get('image', [])
                                log(f"[LastFM] Available images: {images}")
                                for size in ['extralarge', 'large', 'medium', 'small']:
                                    for img in images:
                                        if img.get('size') == size:
                                            track_info['album_image'] = img.get('#text')
                                            if track_info['album_image'] and track_info['album_image'].strip():
                                                log(f"[LastFM] Selected image size {size}: {track_info['album_image']}")
                                                break
                                    if track_info['album_image']:
                                        break

                                log(f"[LastFM] Final track info: {track_info}")
                                log(f"[LastFM] Send album cover setting: {self.get_setting('send_album_cover', True)}")
                                
                                try:
                                    if self.get_setting("send_album_cover", True):
                                        log("[LastFM] Creating card...")
                                        temp_photo_path = self._make_card(track_info)
                                        log(f"[LastFM] Card created at: {temp_photo_path}")
                                        
                                        if temp_photo_path:
                                            log("[LastFM] Getting send messages helper...")
                                            helper = get_send_messages_helper()
                                            log("[LastFM] Generating photo sizes...")
                                            generated_photo = helper.generatePhotoSizes(temp_photo_path, None)
                                            log(f"[LastFM] Generated photo: {generated_photo}")

                                            if generated_photo is not None:
                                                np_format = self.get_setting("np_display_format", DEFAULT_STREAM_STRING)
                                                caption = np_format.replace("{title}", track_info['name']).replace("{artist}", track_info['artist'])
                                                log(f"[LastFM] Sending photo with caption: {caption}")
                                                
                                                send_message({
                                                    "peer": peer,
                                                    "photo": generated_photo,
                                                    "path": temp_photo_path,
                                                    "caption": caption,
                                                    "message": None
                                                })
                                                log("[LastFM] Photo sent successfully")
                                                self.delete_temp_file_async(temp_photo_path)
                                                return HookResult(strategy=HookStrategy.CANCEL)
                                            else:
                                                log("[LastFM] Failed to generate photo sizes")
                                                self.delete_temp_file_async(temp_photo_path)
                                                send_message({
                                                    "peer": peer,
                                                    "message": "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ñ–æ—Ç–æ"
                                                })
                                                return HookResult(strategy=HookStrategy.CANCEL)
                                        else:
                                            log("[LastFM] Failed to create card")
                                            send_message({
                                                "peer": peer,
                                                "message": "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–∞—Ä—Ç–æ—á–∫–∏"
                                            })
                                            return HookResult(strategy=HookStrategy.CANCEL)
                                    else:
                                        log("[LastFM] Sending text message only...")
                                        np_format = self.get_setting("np_display_format", DEFAULT_STREAM_STRING)
                                        message = np_format.replace("{title}", track_info['name']).replace("{artist}", track_info['artist'])
                                        log(f"[LastFM] Sending text: {message}")
                                        
                                        send_message({
                                            "peer": peer,
                                            "message": message
                                        })
                                        log("[LastFM] Text message sent successfully")
                                        return HookResult(strategy=HookStrategy.CANCEL)
                                except Exception as e:
                                    log(f"[LastFM] Error in card creation/sending: {e}")
                                    import traceback
                                    log(f"[LastFM] Traceback: {traceback.format_exc()}")
                                    send_message({
                                        "peer": peer,
                                        "message": f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–∞—Ä—Ç–æ—á–∫–∏: {e}"
                                    })
                                    return HookResult(strategy=HookStrategy.CANCEL)

                            else:
                                log("[LastFM] No now playing track found")
                                send_message({
                                    "peer": peer,
                                    "message": "‚ñ∂Ô∏è –°–µ–π—á–∞—Å –Ω–∏—á–µ–≥–æ –Ω–µ –∏–≥—Ä–∞–µ—Ç."
                                })
                                return

                        else:
                            log("[LastFM] No tracks found in response")
                            send_message({
                                "peer": peer,
                                "message": "ü§∑‚Äç‚ôÇÔ∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç—Ä–µ–∫–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∏–∫ LastFM –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö."
                            })
                            return

                    except requests.exceptions.RequestException as e:
                        log(f"[LastFM] Request exception: {e}")
                        send_message({
                            "peer": peer,
                            "message": f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ LastFM API: {e}"
                        })
                        return
                    except Exception as e:
                        log(f"[LastFM] Unexpected exception: {e}")
                        import traceback
                        log(f"[LastFM] Traceback: {traceback.format_exc()}")
                        send_message({
                            "peer": peer,
                            "message": f"‚ùå –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {e}"
                        })
                        return

                try:
                    log("[LastFM] Showing '–ò—â–µ–º...' bulletin")
                    BulletinHelper.show_info("–ò—â–µ–º...")
                except Exception as e:
                    log(f"[LastFM] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –¥–∏–∞–ª–æ–≥–∞: {e}")

                log(f"[LastFM] Starting search thread for peer: {params.peer}")
                threading.Thread(target=lambda: search_and_reply(params.peer), daemon=True).start()

                params.message = "–ò—â–µ–º..."
                return HookResult(strategy=HookStrategy.CANCEL)

        log("[LastFM] Command not detected, returning")
        return HookResult()

    def _make_card(self, track_info):
        log(f"[LastFM] Starting _make_card with track_info: {track_info}")
        width, height = 1440, 600
        background_color = "#000000"
        title_text_color = "#FFFFFF"
        subtext_color = "#FFFFFF"
        default_cover_url = "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fplay-lh.googleusercontent.com%2FVFmAfWqcuV3aReZG8MMQdHRSdKWx85IW22f4RQ5xhR5U-o1_u03P7TVwsnTYa26Q1No&f=1&nofb=1&ipt=4449ba66d57828b42c006e2a6c19d76deae54a97f2485f28b3fbe695883dc7cc"

        log(f"[LastFM] Creating card with dimensions: {width}x{height}")
        
        album_image_url = track_info.get('album_image')
        log(f"[LastFM] Album image URL: {album_image_url}")
        if not album_image_url or not album_image_url.strip():
            album_image_url = default_cover_url
            log(f"[LastFM] Using default cover URL: {album_image_url}")

        original_image = None
        try:
            log(f"[LastFM] Downloading original image for background and thumbnail from: {album_image_url}")
            response = requests.get(album_image_url, timeout=10)
            response.raise_for_status()
            original_image = Image.open(io.BytesIO(response.content)).convert("RGBA")
        except Exception as e:
            log(f"[LastFM] Error downloading original cover image: {e}")
            # Fallback for original image if download fails
            original_image = Image.new('RGBA', (1, 1), (0, 0, 0, 0)) # Small transparent image to avoid errors

        full_background = Image.new('RGB', (width, height), background_color)
        if original_image:
            try:
                # Resize and blur for the full background
                blurred_background = original_image.resize((width, height))
                blurred_background = blurred_background.filter(ImageFilter.GaussianBlur(30)) # Apply blur
                
                # Apply dark overlay
                overlay = Image.new("RGBA", (width, height), (0, 0, 0, 150)) # Dark overlay
                full_background = Image.alpha_composite(blurred_background, overlay).convert("RGB")
                log(f"[LastFM] Full blurred background created")
            except Exception as e:
                log(f"[LastFM] Error processing background cover: {e}")

        card = full_background
        draw = ImageDraw.Draw(card)

        # Now, paste the unblurred thumbnail if an original image was successfully loaded
        if original_image:
            try:
                thumbnail = original_image.resize((450, 450))
                log(f"[LastFM] Album image resized to 450x450")
                mask = Image.new('L', thumbnail.size, 0)
                draw_mask = ImageDraw.Draw(mask)
                draw_mask.rounded_rectangle((0, 0, *thumbnail.size), 30, fill=255)
                thumbnail = thumbnail.copy()
                thumbnail.putalpha(mask)
                card.paste(thumbnail, (75, 75), thumbnail)
                log(f"[LastFM] Album image pasted to card")
            except Exception as e:
                log(f"[LastFM] Error processing album cover thumbnail: {e}")

        title = track_info.get('name', 'Unknown Track')
        artist = track_info.get('artist', 'Unknown Artist')
        log(f"[LastFM] Title: {title}, Artist: {artist}")
        
        font_index = self.get_setting("card_font_family", 0)
        log(f"[LastFM] Font index: {font_index}")
        title_font = None
        artist_font = None
        info_font = None
        plugins_font = None
        
        if font_index == 3:
            log("[LastFM] Using custom font")
            custom_font_url = self.get_setting("custom_font_path", "").strip()
            log(f"[LastFM] Custom font URL: {custom_font_url}")
            if custom_font_url and custom_font_url.startswith(('http://', 'https://')):
                try:
                    custom_font_file = File(self._temp_dir, "custom_font.ttf").getAbsolutePath()
                    custom_url_file = File(self._temp_dir, "custom_font_url.txt").getAbsolutePath()
                    log(f"[LastFM] Custom font file path: {custom_font_file}")
                    
                    should_download = True
                    if os.path.exists(custom_font_file) and os.path.exists(custom_url_file):
                        try:
                            with open(custom_url_file, 'r') as f:
                                saved_url = f.read().strip()
                            if saved_url == custom_font_url:
                                should_download = False
                                log(f"[LastFM] Custom font URL unchanged, using cached font")
                        except Exception as e:
                            log(f"[LastFM] Error reading saved URL: {e}")
                    
                    if should_download:
                        log(f"[LastFM] Downloading custom font from: {custom_font_url}")
                        response = requests.get(custom_font_url, verify=False)
                        with open(custom_font_file, 'wb') as f:
                            f.write(response.content)
                        with open(custom_url_file, 'w') as f:
                            f.write(custom_font_url)
                        log(f"[LastFM] Downloaded new custom font from: {custom_font_url}")
                    
                    if os.path.exists(custom_font_file):
                        title_font = ImageFont.truetype(custom_font_file, 50)
                        artist_font = ImageFont.truetype(custom_font_file, 35)
                        info_font = ImageFont.truetype(custom_font_file, 35)
                        plugins_font = ImageFont.truetype(custom_font_file, 30)
                        log(f"[LastFM] Using custom font: {custom_font_file}")
                    else:
                        raise Exception("Custom font file not found")
                except Exception as e:
                    log(f"[LastFM] Failed to load custom font: {e}")
                    font_index = 0
        
        if not title_font:
            log(f"[LastFM] Loading standard font with index: {font_index}")
            font_key = list(FONTS.keys())[font_index] if isinstance(font_index, int) and font_index < len(FONTS) else "NotoSansJP"
            font_file_name = f"{font_key}-Regular.ttf"
            log(f"[LastFM] Font file name: {font_file_name}")
            try:
                font_path = File(self._temp_dir, font_file_name).getAbsolutePath()
                log(f"[LastFM] Font path: {font_path}")
                if os.path.exists(font_path):
                    title_font = ImageFont.truetype(font_path, 50)
                    artist_font = ImageFont.truetype(font_path, 35)
                    info_font = ImageFont.truetype(font_path, 35)
                    plugins_font = ImageFont.truetype(font_path, 30)
                    log(f"[LastFM] Using downloaded font: {font_path}")
                else:
                    raise Exception("Downloaded font not found")
            except Exception as e:
                log(f"[LastFM] Failed to load downloaded font: {e}")
                try:
                    title_font = ImageFont.truetype("/system/fonts/Roboto-Bold.ttf", 50)
                    artist_font = ImageFont.truetype("/system/fonts/Roboto-Regular.ttf", 35)
                    info_font = ImageFont.truetype("/system/fonts/Roboto-Regular.ttf", 35)
                    plugins_font = ImageFont.truetype("/system/fonts/Roboto-Regular.ttf", 30)
                    log('[LastFM] Using system fonts')
                except:
                    log('[LastFM] Using default font')
                    title_font = ImageFont.load_default()
                    artist_font = ImageFont.load_default()
                    info_font = ImageFont.load_default()
                    plugins_font = ImageFont.load_default()
        
        log(f"[LastFM] Fonts loaded - title: {title_font}, artist: {artist_font}")
        
        max_width = width - 665
        title_lines = []
        current_line = []
        
        words = title.split()
        for word in words:
            test_line = ' '.join(current_line + [word])
            bbox = draw.textbbox((0, 0), test_line, font=title_font)
            if bbox[2] - bbox[0] <= max_width:
                current_line.append(word)
            else:
                if current_line:
                    title_lines.append(' '.join(current_line))
                current_line = [word]
        if current_line:
            title_lines.append(' '.join(current_line))
            
        if len(title_lines) > 2:
            title_lines = title_lines[:2]
            title_lines[1] = title_lines[1][:title_lines[1].rfind(' ')] + '...'
        
        log(f"[LastFM] Title lines: {title_lines}")
        
        y_position = 85
        for line in title_lines:
            draw.text((590, y_position), line, font=title_font, fill=title_text_color)
            y_position += 60
        
        artist_lines = []
        current_line = []
        
        words = artist.split()
        for word in words:
            test_line = ' '.join(current_line + [word])
            bbox = draw.textbbox((0, 0), test_line, font=artist_font)
            if bbox[2] - bbox[0] <= max_width:
                current_line.append(word)
            else:
                if current_line:
                    artist_lines.append(' '.join(current_line))
                current_line = [word]
        if current_line:
            artist_lines.append(' '.join(current_line))
            
        if len(artist_lines) > 1:
            artist_lines = [artist_lines[0][:artist_lines[0].rfind(' ')] + '...']
        
        log(f"[LastFM] Artist lines: {artist_lines}")
        
        draw.text((590, y_position + 10), artist_lines[0], font=artist_font, fill=subtext_color)

        draw.text((590, 415), "Now Playing", font=info_font, fill=subtext_color)

        draw.text((590, 470), "More Plugins in @KangelPlugins", font=plugins_font, fill=subtext_color)

        filename = f"now_lastfm.png"
        temp_photo_path = File(self._temp_dir, filename).getAbsolutePath()
        log(f"[LastFM] Saving card to: {temp_photo_path}")
        card.save(temp_photo_path)
        log(f"[LastFM] Card saved successfully")
        return temp_photo_path

    def _get_temp_dir(self):
        try:
            base_dir = ApplicationLoader.getFilesDirFixed()
            if not base_dir:
                return None
            temp_dir = File(base_dir, TEMP_DIR_NAME)
            if not temp_dir.exists() and not temp_dir.mkdirs():
                return None
            return temp_dir
        except Exception as e:
            log(f"Error getting temp directory: {e}")
            return None 