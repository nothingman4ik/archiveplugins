import requests
import json
import time
import threading
import traceback
import os
from datetime import datetime
from base_plugin import HookResult, HookStrategy, BasePlugin, MenuItemData, MenuItemType
from client_utils import send_message, run_on_queue, get_last_fragment, run_on_ui_thread, get_messages_controller
from markdown_utils import parse_markdown
from ui.settings import Header, Input, Switch, Text, Divider
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from java.util import Locale
from org.telegram.messenger import MessageObject
from org.telegram.ui.ActionBar import AlertDialog
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity

__id__ = "account_age_checker"
__name__ = "Account Age Checker"
__description__ = "Check the age of a Telegram account. Features cache, loading indicator, and more."
__author__ = "@mihailkotovski & @mew_help"
__min_version__ = "11.9.1"
__icon__ = "DateRegBot_by_MoiStikiBot/0"
__version__ = "3.0.0"
__copyright__ = "© 2025. All rights reserved. Copying, modification, or redistribution of this plugin code is strictly prohibited."

AUTOUPDATE_CHANNEL_ID = 2349438816
AUTOUPDATE_CHANNEL_USERNAME = "mishabotov"
AUTOUPDATE_MESSAGE_ID = 35

PREMIUM_EMOJI_MAP = {
    "📊": "[📊](5190806721286657692)",
    "👤": "[👤](5260399854500191689)",
    "📅": "[📅](5890937706803894250)",
    "🎯": "[💯](5206318837489743801)",
    "⏳": "[🕔](5255971360965930740)",
    "⚙️": "[⚙️](5253952855185829086)",
    "🟢": "[✅](5021905410089550576)",
    "🟡": "[⚡️](4997289591011544358)",
    "🟠": "[📺](5350513667144163474)",
    "🔴": "[❗️](4927486932113425461)",
    "😒": "[😒](5303360582706015886)",
    "🔗": "[🔗](5253490441826870592)"
}

def replace_with_premium_emoji(text: str) -> str:
    result = text
    for regular_emoji, premium_emoji in PREMIUM_EMOJI_MAP.items():
        result = result.replace(regular_emoji, premium_emoji)
    return result

def get_regular_emoji_for_bulletin(text: str) -> str:
    result = text
    for regular_emoji, premium_emoji in PREMIUM_EMOJI_MAP.items():
        result = result.replace(premium_emoji, regular_emoji)
    return result

def get_account_name_from_telegram(user_id: str) -> str:
    try:
        from client_utils import get_messages_controller
        from org.telegram.messenger import UserObject

        user = get_messages_controller().getUser(int(user_id))
        if user is None:
            return "Неизвестно"

        first_name = ""
        last_name = ""

        if hasattr(user, 'first_name') and user.first_name:
            first_name = user.first_name.strip()

        if hasattr(user, 'last_name') and user.last_name:
            last_name = user.last_name.strip()

        if first_name and last_name:
            full_name = f"{first_name} {last_name}"
        elif first_name:
            full_name = first_name
        elif last_name:
            full_name = last_name
        else:
            full_name = ""

        if full_name and full_name != "DELETED":
            return full_name

        if hasattr(user, 'username') and user.username:
            return f"@{user.username}"

        return "Неизвестно"

    except Exception as e:
        _log(f"Error getting account name from Telegram: {e}")
        return "Неизвестно"

def get_username_from_telegram(user_id: str) -> str:
    try:
        from client_utils import get_messages_controller

        user = get_messages_controller().getUser(int(user_id))
        if user is None:
            return ""

        if hasattr(user, 'username') and user.username:
            return user.username.strip()

        return ""

    except Exception as e:
        _log(f"Error getting username from Telegram: {e}")
        return ""

def _log(message: str):
    if AccountAgePlugin.is_debug_globally_enabled():
        from android_utils import log as extera_log
        extera_log(f"[{__name__}] {message}")

class CacheManager:
    def __init__(self, plugin_instance):
        self.plugin = plugin_instance
        self.cache_file = self._get_cache_file_instance()
        self.cache = self.cache_file.content

    def _get_cache_file_instance(self):
        try:
            from zwylib import JsonCacheFile
            _log("Using ZwyLib's JsonCacheFile for caching.")
            return JsonCacheFile(f"{__id__}_cache.json", {})
        except ImportError:
            _log("ZwyLib not found. Using local JsonCacheFile implementation.")
            class LocalJsonCacheFile:
                cache_dir_name = os.path.join(os.path.dirname(os.path.realpath(__file__)), "cache")
                def __init__(self, filename: str, default: dict):
                    self.filename = filename
                    self.path = os.path.join(self.cache_dir_name, filename)
                    self.content = default.copy()
                    self.default = default.copy()
                    os.makedirs(self.cache_dir_name, exist_ok=True)
                    self.read()
                def read(self):
                    try:
                        with open(self.path, 'r', encoding='utf-8') as f: self.content = json.load(f)
                    except: self.wipe()
                def write(self):
                    try:
                        with open(self.path, 'w', encoding='utf-8') as f: json.dump(self.content, f, ensure_ascii=False, indent=4)
                    except Exception as e: _log(f"Cache write error: {e}")
                def wipe(self):
                    self.content = self.default.copy()
                    self.write()
            return LocalJsonCacheFile(f"{__id__}_cache.json", {})

    def get(self, user_id: str, method: str):
        cache_duration = int(self.plugin.get_setting("cache_duration", "86400"))
        cache_key = f"{user_id}_{method}"

        if cache_key in self.cache:
            cached_data = self.cache[cache_key]
            if (time.time() - cached_data.get("timestamp", 0)) < cache_duration:
                _log(f"Cache hit for user_id: {user_id}, method: {method}")
                return cached_data.get("data")
        _log(f"Cache miss for user_id: {user_id}, method: {method}")
        return None

    def set(self, user_id: str, method: str, data: dict):
        cache_key = f"{user_id}_{method}"
        self.cache[cache_key] = {
            "timestamp": time.time(),
            "data": data
        }
        self.cache_file.write()
        _log(f"Saved to cache for user_id: {user_id}, method: {method}")

    def delete(self, user_id: str):
        user_id_str = str(user_id)
        keys_to_delete = [
            key for key in self.cache
            if key.startswith(f"{user_id_str}_")
        ]

        if not keys_to_delete:
            _log(f"No cache entries found to delete for user_id: {user_id_str}")
            return False

        for key in keys_to_delete:
            del self.cache[key]

        self.cache_file.write()
        _log(f"Deleted {len(keys_to_delete)} cache entries for user_id: {user_id_str}")
        return True

    def prune_expired(self):
        cache_duration = int(self.plugin.get_setting("cache_duration", "86400"))
        now = time.time()
        keys_to_delete = [
            key for key, value in self.cache.items()
            if (now - value.get("timestamp", 0)) >= cache_duration
        ]
        if not keys_to_delete: return
        for key in keys_to_delete: del self.cache[key]
        self.cache_file.write()
        _log(f"Pruned {len(keys_to_delete)} expired entries from cache.")

    def clear(self):
        self.cache_file.wipe()
        self.cache = self.cache_file.content
        _log("Cache cleared by user.")


class AgeCheckerAPI:
    DEFAULT_BASE_URL = "https://api.goy.guru/api/v1"
    def __init__(self, api_key, custom_url=None):
        self.api_key = api_key
        self.base_url = custom_url.strip().rstrip('/') if custom_url else self.DEFAULT_BASE_URL
        self.session = requests.Session()
        self.session.headers.update({"User-Agent": f"ExteraPlugin/{__id__}/{__version__}"})

    def _handle_request_exception(self, e, context):
        _log(f"Network error during {context}: {e}")
        return {"success": False, "error": f"Network error: {e}"}

    def _handle_api_error(self, response, context):
        error_message = f"API request failed for {context} with status code {response.status_code}: {response.text}"
        try: error_data = response.json(); error_message = error_data.get('detail', error_message)
        except: pass
        if response.status_code == 401: error_message = "Invalid API key."
        elif response.status_code == 402: error_message = "Insufficient balance."
        elif response.status_code == 404: error_message = "User not found."
        _log(error_message)
        return {"success": False, "error": error_message}

    def resolve_username(self, username):
        _log(f"Resolving username '{username}'...")
        endpoint = f"{self.base_url}/users/resolveUsername"
        params = {"token": self.api_key, "username": username.lstrip('@')}
        try:
            response = self.session.get(endpoint, params=params, timeout=20)
            if response.status_code == 200:
                data = response.json()
                if data.get('id'):
                    _log(f"Username '{username}' resolved to ID: {data['id']}")
                    return {"success": True, "data": data}
                return {"success": False, "error": "Could not resolve username."}
            return self._handle_api_error(response, f"resolve_username for '{username}'")
        except requests.exceptions.RequestException as e:
            return self._handle_request_exception(e, f"resolve_username for '{username}'")

    def get_info(self, user_id, method="fast"):
        _log(f"Requesting creation date for ID '{user_id}' with method '{method}'")
        endpoint = f"{self.base_url}/users/getCreationDateSmart" if method == "smart" else f"{self.base_url}/users/getCreationDateFast"
        params = {"token": self.api_key, "user_id": user_id}
        try:
            response = self.session.get(endpoint, params=params, timeout=20)
            if response.status_code == 200:
                data = response.json()
                if data.get('creation_date'):
                    _log(f"API success for '{user_id}': {data}")
                    return {"success": True, "data": data}
                _log(f"API error for '{user_id}': Creation date not found in response.")
                return {"success": False, "error": data.get("error", "Creation date not found")}
            return self._handle_api_error(response, f"get_info for '{user_id}'")
        except requests.exceptions.RequestException as e:
            return self._handle_request_exception(e, f"get_info for '{user_id}'")


class LocalizationManager:
    def __init__(self):
        self.language = Locale.getDefault().getLanguage()
        self.language = self.language if self.language in self._get_supported_languages() else "en"
    def get_string(self, string): return self.strings[self.language][string]
    def _get_supported_languages(self): return self.strings.keys()
    strings = {
        "ru": {
            "USAGE_EXAMPLE": "⚠️ *Использование:* `.age [имя пользователя/ID]`\n`.age smart [имя пользователя/ID]` для более точного анализа",
            "API_ERROR": "⛔ *Произошла ошибка при запросе к API:*\n\n`{0}`",
            "RESULT": """*📊 ИНФОРМАЦИЯ ОБ АККАУНТЕ*

*😒 Имя аккаунта:* `{7}`
*👤 ID:* `{0}`
*🔗 Юзернейм:* @{8}
*📅 Дата создания:* `{2}`
*🎯 Точность:* {5} {3}
*⏳ Возраст аккаунта:* `{4}`
*⚙️ Метод:* `{6}`""",
            "RESULT_NO_USERNAME": """*📊 ИНФОРМАЦИЯ ОБ АККАУНТЕ*

*😒 Имя аккаунта:* `{7}`
*👤 ID:* `{0}`
*🔗 Юзернейм:* @{8}
*📅 Дата создания:* `{2}`
*🎯 Точность:* {5} {3}
*⏳ Возраст аккаунта:* `{4}`
*⚙️ Метод:* `{6}`""",
            "CODE_ERROR": "⛔ *Произошла ошибка в коде плагина:*\n\n`{0}`",
            "API_KEY_TITLE": "Настройки API",
            "API_KEY_DESCRIPTION": "Введите ваш API ключ для доступа к API. Получите ключ в боте @dateregbot",
            "NO_API_KEY": "⚠️ *API ключ не настроен.* Получите API ключ в боте @dateregbot и укажите его в настройках плагина.",
            "CUSTOM_API_URL_TITLE": "URL API",
            "CUSTOM_API_URL_DESCRIPTION": "Укажите собственный URL API (оставьте пустым для использования по умолчанию)",
            "FAQ_COMMAND": "faq",
            "FAQ_CONTENT": """❓ ЧАСТО ЗАДАВАЕМЫЕ ВОПРОСЫ (FAQ)

1. Что делает этот плагин?
Плагин проверяет примерную дату создания аккаунта Telegram по юзернейму или ID.

2. Как использовать этот плагин?
Используйте команду .age [юзернейм/ID] или ответьте на сообщение командой .age
Для более точного анализа используйте: .age smart [юзернейм/ID]

3. Почему нужен API ключ?
API ключ необходим для доступа к сервису, который определяет дату создания аккаунта.

4. Где получить API ключ?
API ключ можно получить в боте @dateregbot

5. Насколько точны результаты?
Точность указывается в каждом результате и зависит от многих факторов.
🟢 - высокая точность (87-100%)
🟡 - средняя точность (70-86%)
🟠 - низкая точность (50-69%)
🔴 - очень низкая точность (<50%)

6. Что означает "точность" в результатах?
Это показатель надежности определения даты создания аккаунта.

7. Есть ли лимиты на использование?
Да, лимиты зависят от вашего API ключа и тарифа у @dateregbot.

8. Чем отличаются методы Fast и Smart?
Fast - быстрый, но менее точный метод
Smart - более точный, но более медленный метод""",
            "PROCESSING": "Пожалуйста, подождите, предыдущий запрос еще выполняется...",
            "LOADING_TITLE": "Проверка возраста аккаунта...",
            "CACHED_RESULT_HINT": "_(Результат из кэша)_",
            "SETTINGS_DEBUG_MODE": "Режим отладки",
            "SETTINGS_DEBUG_MODE_SUBTEXT": "Включает подробные логи в logcat для помощи в решении проблем.",
            "SETTINGS_CACHE_DURATION": "Время жизни кэша (в секундах)",
            "SETTINGS_CACHE_DURATION_SUBTEXT": "Как долго хранить результаты. 86400 = 24 часа.",
            "SETTINGS_CLEAR_CACHE": "Очистить кэш",
            "SETTINGS_CACHE_CLEARED": "Кэш успешно очищен.",
            "CACHE_DELETE_SUCCESS": "Кэш для ID `{0}` успешно очищен.",
            "CACHE_DELETE_NOT_FOUND": "Кэш для ID `{0}` не найден.",
            "CACHE_DELETE_USAGE": "Использование: .cache <ID>",
            "FAQ_TITLE": "❓ FAQ",
            "SETTINGS_MENU_BUTTON": "Кнопка настроек в меню",
            "SETTINGS_SHOW_BUTTON_DESC": "Добавляет кнопку открытия настроек плагина в меню",
            "SETTINGS_TITLE": "Настройки Account Age",
            "USE_PREMIUM_EMOJI_TITLE": "Премиум эмодзи",
            "USE_PREMIUM_EMOJI_SUBTEXT": "Заменять обычные эмодзи на анимированные премиум эмодзи в результатах.",
            "DONATE_TITLE": "Поддержать разработку",
            "DONATE_INFO": "Другая информация и реквизиты",
        },
        "en": {
            "USAGE_EXAMPLE": "⚠️ *Usage:* `.age [username/ID]`\n`.age smart [username/ID]` for more accurate analysis",
            "API_ERROR": "⛔ *An error occurred while querying the API:*\n\n`{0}`",
            "RESULT": """*📊 ACCOUNT INFORMATION*

*😒 Account Name:* `{7}`
*👤 ID:* `{0}`
*🔗 Username:* @{8}
*📅 Creation Date:* `{2}`
*🎯 Accuracy:* {5} {3}
*⏳ Account Age:* `{4}`
*⚙️ Method:* `{6}`""",
            "RESULT_NO_USERNAME": """*📊 ACCOUNT INFORMATION*

*😒 Account Name:* `{7}`
*🔗 Username:* @{8}
*👤 ID:* `{0}`
*📅 Creation Date:* `{2}`
*🎯 Accuracy:* {5} {3}
*⏳ Account Age:* `{4}`
*⚙️ Method:* `{6}`""",
            "CODE_ERROR": "⛔ *An error occurred in the plugin code:*\n\n`{0}`",
            "API_KEY_TITLE": "API Settings",
            "API_KEY_DESCRIPTION": "Enter your API key for API access. Get a key from @dateregbot",
            "NO_API_KEY": "⚠️ *API key not configured.* Get an API key from @dateregbot and set it in the plugin settings.",
            "CUSTOM_API_URL_TITLE": "API URL",
            "CUSTOM_API_URL_DESCRIPTION": "Specify custom API URL (leave empty to use default)",
            "FAQ_COMMAND": "faq",
            "FAQ_CONTENT": """❓ FREQUENTLY ASKED QUESTIONS (FAQ)

1. What does this plugin do?
This plugin checks the approximate creation date of a Telegram account by username or ID.

2. How do I use this plugin?
Use the command .age [username/ID] or reply to a message with .age
For more accurate analysis use: .age smart [username/ID]

3. Why do I need an API key?
The API key is required to access the service that determines account creation dates.

4. How do I get an API key?
You can obtain an API key from the bot @dateregbot

5. How accurate are the results?
Accuracy is indicated in each result and depends on various factors.
🟢 - high accuracy (87-100%)
🟡 - medium accuracy (70-86%)
🟠 - low accuracy (50-69%)
🔴 - very low accuracy (<50%)

6. What does "accuracy" in the results mean?
It's an indicator of how reliable the account creation date determination is.

7. Are there any usage limits?
Yes, limits depend on your API key and service plan from @dateregbot.

8. What's the difference between Fast and Smart methods?
Fast - quick but less accurate method
Smart - more accurate but slower method""",
            "PROCESSING": "Please wait, the previous request is still being processed...",
            "LOADING_TITLE": "Checking Account Age...",
            "CACHED_RESULT_HINT": "_(Result from cache)_",
            "SETTINGS_DEBUG_MODE": "Debug Mode",
            "SETTINGS_DEBUG_MODE_SUBTEXT": "Enables detailed logs in logcat to help with troubleshooting.",
            "SETTINGS_CACHE_DURATION": "Cache Lifetime (in seconds)",
            "SETTINGS_CACHE_DURATION_SUBTEXT": "How long to store results. 86400 = 24 hours.",
            "SETTINGS_CLEAR_CACHE": "Clear Cache",
            "SETTINGS_CACHE_CLEARED": "Cache cleared successfully.",
            "CACHE_DELETE_SUCCESS": "Cache for ID `{0}` cleared successfully.",
            "CACHE_DELETE_NOT_FOUND": "No cache found for ID `{0}`.",
            "CACHE_DELETE_USAGE": "Usage: .cache <ID>",
            "FAQ_TITLE": "❓ FAQ",
            "SETTINGS_MENU_BUTTON": "Settings button in menu",
            "SETTINGS_SHOW_BUTTON_DESC": "Adds plugin settings button to menu",
            "SETTINGS_TITLE": "Account Age Settings",
            "USE_PREMIUM_EMOJI_TITLE": "Premium emoji",
            "USE_PREMIUM_EMOJI_SUBTEXT": "Replace regular emoji with animated premium emoji in results.",
            "DONATE_TITLE": "Support development",
            "DONATE_INFO": "Other info and requisites",
        }
    }
locali = LocalizationManager()


class AccountAgePlugin(BasePlugin):
    _debug_enabled = False

    def __init__(self):
        super().__init__()
        self.is_processing = False
        self.api_client = None
        self.alert_dialog = None
        self.cache_manager = CacheManager(self)
        self._drawer_settings_item = None
        self._chat_settings_item = None

    @classmethod
    def is_debug_globally_enabled(cls):
        return cls._debug_enabled

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self.load_config()
        self.cache_manager.prune_expired()
        _log("Plugin loaded and cache pruned.")
        try:
            import zwylib
            zwylib.add_autoupdater_task(__id__, AUTOUPDATE_CHANNEL_ID, AUTOUPDATE_CHANNEL_USERNAME, AUTOUPDATE_MESSAGE_ID)
            _log("ZwyLib autoupdater task added.")
        except ImportError:
            _log("ZwyLib not found, autoupdater is disabled.")
        try:
            if self.get_setting("show_settings_buttons", True):
                self._add_settings_menu_items()
        except Exception as e:
            _log(f"Failed to add settings menu items on load: {e}")

    def on_plugin_unload(self):
        try:
            import zwylib
            zwylib.remove_autoupdater_task(__id__)
            _log("ZwyLib autoupdater task removed.")
        except ImportError: pass
        try:
            if self._drawer_settings_item: self.remove_menu_item(self._drawer_settings_item)
            if self._chat_settings_item: self.remove_menu_item(self._chat_settings_item)
        except Exception as e: _log(f"Error removing menu items on unload: {e}")
        _log("Plugin unloaded.")

    def load_config(self, _=None):
        AccountAgePlugin._debug_enabled = self.get_setting("debug_mode", False)
        api_key = self.get_setting("api_key", "").strip()
        custom_url = self.get_setting("custom_api_url", "").strip()
        if api_key: self.api_client = AgeCheckerAPI(api_key, custom_url); _log("API client configured.")
        else: self.api_client = None; _log("API key is not set. API client is disabled.")

    def create_settings(self):
        return [
            Header(locali.get_string("API_KEY_TITLE")),
            Input(key="api_key", text=locali.get_string("API_KEY_TITLE"), subtext=locali.get_string("API_KEY_DESCRIPTION"), default="", on_change=self.load_config, icon="msg_pin_code"),
            Input(key="custom_api_url", text=locali.get_string("CUSTOM_API_URL_TITLE"), subtext=locali.get_string("CUSTOM_API_URL_DESCRIPTION"), default="", on_change=self.load_config, icon="msg_link"),
            Divider(), Header("Cache & Debug"),
            Input(key="cache_duration", text=locali.get_string("SETTINGS_CACHE_DURATION"), subtext=locali.get_string("SETTINGS_CACHE_DURATION_SUBTEXT"), default="86400", icon="msg_stories_timer"),
            Text(text=locali.get_string("SETTINGS_CLEAR_CACHE"), icon="msg_delete", on_click=self._clear_cache),
            Switch(key="debug_mode", text=locali.get_string("SETTINGS_DEBUG_MODE"), subtext=locali.get_string("SETTINGS_DEBUG_MODE_SUBTEXT"), default=False, on_change=self.load_config, icon="msg_log"),
            Switch(key="show_settings_buttons", text=locali.get_string("SETTINGS_MENU_BUTTON"), icon="msg_reorder", default=True, subtext=locali.get_string("SETTINGS_SHOW_BUTTON_DESC"), on_change=self._on_show_settings_buttons_change),
            Switch(key="use_premium_emoji", text=locali.get_string("USE_PREMIUM_EMOJI_TITLE"), subtext=locali.get_string("USE_PREMIUM_EMOJI_SUBTEXT"), icon="menu_feature_reactions_remix", default=False),
            Divider(), Header(text=locali.get_string("DONATE_TITLE")),
            Text(text="CRYPTO [Crypto Bot]", icon="menu_cashtag", accent=True, on_click=lambda view: run_on_ui_thread(lambda: self._copy_to_clipboard("CRYPTO", "http://t.me/send?start=IVhqWW9Mz8MU"))),
            Text(text=locali.get_string("DONATE_INFO"), icon="menu_feature_reactions", accent=True, on_click=lambda view: run_on_ui_thread(lambda: get_messages_controller().openByUserName("mishabotov", get_last_fragment(), 1)))
        ]

    def _clear_cache(self, _=None):
        self.cache_manager.clear()
        message = locali.get_string("SETTINGS_CACHE_CLEARED")
        BulletinHelper.show_success(get_regular_emoji_for_bulletin(message))

    def _format_age(self, creation_date_str):
        if not creation_date_str: return "N/A"
        try: month, year = map(int, creation_date_str.split('.'))
        except: return "N/A"
        now = datetime.now()
        year_diff, month_diff = now.year - year, now.month - month
        if month_diff < 0: year_diff -= 1; month_diff += 12
        if locali.language == "ru":
            if year_diff > 0:
                y_str = f"{year_diff} год" if year_diff == 1 else (f"{year_diff} года" if 1 < year_diff < 5 else f"{year_diff} лет")
                if month_diff > 0:
                    m_str = f"{month_diff} месяц" if month_diff == 1 else (f"{month_diff} месяца" if 1 < month_diff < 5 else f"{month_diff} месяцев")
                    return f"{y_str} и {m_str}"
                return y_str
            else:
                return "менее месяца" if month_diff == 0 else (f"{month_diff} месяц" if month_diff == 1 else (f"{month_diff} месяца" if 1 < month_diff < 5 else f"{month_diff} месяцев"))
        else:
            y_str, m_str = f"{year_diff} year" + ("s" if year_diff != 1 else ""), f"{month_diff} month" + ("s" if month_diff != 1 else "")
            if year_diff > 0 and month_diff > 0: return f"{y_str} and {m_str}"
            elif year_diff > 0: return y_str
            elif month_diff > 0: return m_str
            else: return "less than a month"

    def _format_response_data(self, data, method):
        age_str = self._format_age(data.get('creation_date', ''))
        accuracy_percent = data.get('accuracy_percent', 0)
        accuracy_emoji = self.get_accuracy_emoji(accuracy_percent)
        display_username = data.get('username')
        accuracy_text = f"_{data.get('accuracy_text', 'Unknown')}_"

        account_name = get_account_name_from_telegram(str(data.get('user_id', '')))
        telegram_username = get_username_from_telegram(str(data.get('user_id', '')))

        if telegram_username:
            username_display = telegram_username
        elif display_username and display_username.lower() != "n/a":
            username_display = display_username
        else:
            username_display = "отсутствует" if locali.language == "ru" else "not available"

        if display_username and display_username.lower() != "n/a":
            result = locali.get_string("RESULT").format(
                data.get('user_id'), display_username, data.get('creation_date'),
                accuracy_text, age_str, accuracy_emoji, method.capitalize(), account_name, username_display
            )
        else:
            result = locali.get_string("RESULT_NO_USERNAME").format(
                data.get('user_id'), "", data.get('creation_date'),
                accuracy_text, age_str, accuracy_emoji, method.capitalize(), account_name, username_display
            )

        use_premium_emoji = self.get_setting("use_premium_emoji", False)
        if use_premium_emoji:
            result = replace_with_premium_emoji(result)

        return result

    def _process_age_request(self, params, initial_target, method):
        try:
            canonical_id = None
            if isinstance(initial_target, str) and not initial_target.isdigit():
                resolve_result = self.api_client.resolve_username(initial_target)
                if resolve_result["success"]:
                    canonical_id = str(resolve_result["data"]["id"])
                else:
                    error_msg = locali.get_string("API_ERROR").format(resolve_result["error"])
                    run_on_ui_thread(lambda: self._reply_with_formatted_text(params, error_msg))
                    return
            else:
                canonical_id = str(initial_target)

            cached_data = self.cache_manager.get(canonical_id, method)
            if cached_data:
                message = self._format_response_data(cached_data, method)
                cached_message = f"{locali.get_string('CACHED_RESULT_HINT')}\n{message}"
                run_on_ui_thread(lambda: self._reply_with_formatted_text(params, cached_message))
            else:
                result = self.api_client.get_info(canonical_id, method)
                if not result["success"]:
                    message = locali.get_string("API_ERROR").format(result["error"])
                else:
                    raw_data = result["data"]
                    message = self._format_response_data(raw_data, method)
                    self.cache_manager.set(canonical_id, method, raw_data)
                run_on_ui_thread(lambda: self._reply_with_formatted_text(params, message))

        except Exception as e:
            _log(f"Error in processing thread! {traceback.format_exc()}")
            error_message = locali.get_string("CODE_ERROR").format(str(e))
            run_on_ui_thread(lambda: self._reply_with_formatted_text(params, error_message))
        finally:
            self.is_processing = False
            self._dismiss_loading_dialog()

    def on_send_message_hook(self, account, params) -> HookResult:
        if not hasattr(params, "message") or not isinstance(params.message, str):
            return HookResult()

        message_text = params.message.strip()
        peer_id = getattr(params, "peer", None)
        if not peer_id: return HookResult()

        if message_text.startswith(".cache "):
            parts = message_text.split(" ", 1)
            if len(parts) < 2:
                message = locali.get_string("CACHE_DELETE_USAGE")
                BulletinHelper.show_error(get_regular_emoji_for_bulletin(message))
                return HookResult(strategy=HookStrategy.CANCEL)

            target_id = parts[1].strip()
            if self.cache_manager.delete(target_id):
                message = locali.get_string("CACHE_DELETE_SUCCESS").format(target_id)
                BulletinHelper.show_success(get_regular_emoji_for_bulletin(message))
            else:
                message = locali.get_string("CACHE_DELETE_NOT_FOUND").format(target_id)
                BulletinHelper.show_info(get_regular_emoji_for_bulletin(message))

            return HookResult(strategy=HookStrategy.CANCEL)

        if not message_text.startswith(".age"):
            return HookResult()

        if self.is_processing:
            message = locali.get_string("PROCESSING")
            BulletinHelper.show_info(get_regular_emoji_for_bulletin(message))
            return HookResult(strategy=HookStrategy.CANCEL)

        try:
            parts = message_text.split(" ", 2)
            if len(parts) > 1 and parts[1].strip().lower() == locali.get_string("FAQ_COMMAND"):
                self._show_info_alert(locali.get_string("FAQ_TITLE"), locali.get_string("FAQ_CONTENT"))
                return HookResult(strategy=HookStrategy.CANCEL)

            if not self.api_client:
                self._reply_with_formatted_text(params, locali.get_string("NO_API_KEY"))
                return HookResult(strategy=HookStrategy.CANCEL)

            use_smart = len(parts) > 1 and parts[1].lower() == "smart"
            target = parts[2].strip() if use_smart and len(parts) > 2 else (parts[1].strip() if len(parts) > 1 and not use_smart else None)

            if not target:
                target = self._get_user_id_from_reply(params)

            if not target:
                self._reply_with_formatted_text(params, locali.get_string("USAGE_EXAMPLE"))
                return HookResult(strategy=HookStrategy.CANCEL)

            method = "smart" if use_smart else "fast"

            self.is_processing = True
            self._show_loading_dialog()
            run_on_queue(lambda: self._process_age_request(params, target, method))

            return HookResult(strategy=HookStrategy.CANCEL)

        except Exception as e:
            self.is_processing = False
            self._dismiss_loading_dialog()
            _log(f"Error in hook! {traceback.format_exc()}")
            error_message = locali.get_string("CODE_ERROR").format(str(e))
            self._reply_with_formatted_text(params, error_message)
            return HookResult(strategy=HookStrategy.CANCEL)

    def _copy_to_clipboard(self, label, text):
        from org.telegram.messenger import AndroidUtilities
        if AndroidUtilities.addToClipboard(text):
            message = f"Copied {label} to clipboard"
            BulletinHelper.show_info(get_regular_emoji_for_bulletin(message))

    def _open_plugin_settings(self, java_plugin):
        try: get_last_fragment().presentFragment(PluginSettingsActivity(java_plugin))
        except Exception as e: _log(f"Error opening plugin settings: {e}")

    def _add_settings_menu_items(self):
        try:
            if not self._drawer_settings_item: self._drawer_settings_item = self.add_menu_item(MenuItemData(menu_type=MenuItemType.DRAWER_MENU, text=locali.get_string("SETTINGS_TITLE"), icon="msg_settings_14", priority=5, on_click=lambda ctx: run_on_ui_thread(lambda: self._open_plugin_settings(PluginsController.getInstance().plugins.get(self.id)))))
            if not self._chat_settings_item: self._chat_settings_item = self.add_menu_item(MenuItemData(menu_type=MenuItemType.CHAT_ACTION_MENU, text=locali.get_string("SETTINGS_TITLE"), icon="msg_settings_14", priority=5, on_click=lambda ctx: run_on_ui_thread(lambda: self._open_plugin_settings(PluginsController.getInstance().plugins.get(self.id)))))
        except Exception as e: _log(f"Failed to add settings menu items: {e}")

    def _on_show_settings_buttons_change(self, enabled: bool):
        def _toggle():
            try:
                if enabled: self._add_settings_menu_items()
                else:
                    if self._drawer_settings_item: self.remove_menu_item(self._drawer_settings_item); self._drawer_settings_item = None
                    if self._chat_settings_item: self.remove_menu_item(self._chat_settings_item); self._chat_settings_item = None
            except Exception as e: _log(f"Failed toggling settings buttons: {e}")
        run_on_ui_thread(_toggle)

    def get_accuracy_emoji(self, accuracy_percent):
        if not isinstance(accuracy_percent, (int, float)): return "❓"
        if accuracy_percent >= 87: return "🟢"
        elif accuracy_percent >= 70: return "🟡"
        elif accuracy_percent >= 50: return "🟠"
        else: return "🔴"

    def _get_user_id_from_reply(self, params):
        if hasattr(params, "replyToMsg") and params.replyToMsg:
            msg_owner = params.replyToMsg.messageOwner
            if msg_owner and hasattr(msg_owner, "from_id") and msg_owner.from_id and hasattr(msg_owner.from_id, "user_id"):
                return str(msg_owner.from_id.user_id)
        return None

    def _reply_with_formatted_text(self, params, markdown_text):
        try:
            parsed = parse_markdown(markdown_text)
            message_payload = {
                "peer": params.peer,
                "message": parsed.text,
                "entities": [e.to_tlrpc_object() for e in parsed.entities],
                "replyToMsg": getattr(params, "replyToMsg", None),
                "replyToTopMsg": getattr(params, "replyToTopMsg", None)
            }
            send_message(message_payload)
        except Exception as e:
            _log(f"Markdown parse/send error: {e}")
            plain_text = markdown_text.replace("*", "").replace("`", "").replace("_", "")
            message_payload = {
                "peer": params.peer,
                "message": plain_text,
                "replyToMsg": getattr(params, "replyToMsg", None),
                "replyToTopMsg": getattr(params, "replyToTopMsg", None)
            }
            send_message(message_payload)

    def _show_info_alert(self, title, message):
        fragment = get_last_fragment()
        if not fragment: return
        builder = AlertDialogBuilder(fragment.getParentActivity())
        builder.set_title(title)
        builder.set_message(message)
        builder.set_positive_button("Close", None)
        run_on_ui_thread(builder.show)

    def _show_loading_dialog(self):
        fragment = get_last_fragment()
        if not fragment or self.alert_dialog: return
        run_on_ui_thread(lambda: self.__show_loading_dialog_on_ui(fragment.getParentActivity()))

    def __show_loading_dialog_on_ui(self, context):
        self.alert_dialog = AlertDialog(context, 3)
        self.alert_dialog.setCanCancel(False)
        self.alert_dialog.show()
        self.alert_dialog.setTitle(locali.get_string("LOADING_TITLE"))

    def _dismiss_loading_dialog(self):
        def dismiss_action():
            if self.alert_dialog:
                try:
                    self.alert_dialog.dismiss()
                except Exception as e:
                    _log(f"Error dismissing dialog: {e}")
                finally:
                    self.alert_dialog = None
        run_on_ui_thread(dismiss_action)