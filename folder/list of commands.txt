__id__ = "list of commands"
__name__ = "Настройка команд"
__author__ = "@bandaliyev"
__version__ = "1.0.0"
__description__ = """Показывается все доступные команды при вводе точки """

__icon__ = "sPluginIDE/35"
__min_version__ = "11.12.0"

import os
import ast
import re
from typing import Any

import plugins_manager
from base_plugin import BasePlugin, MethodHook, HookResult, HookStrategy
from hook_utils import find_class, jarray
from android_utils import run_on_ui_thread
from ui.bulletin import BulletinHelper
from ui.settings import Header, Switch, Input, Divider
from java.util import ArrayList, Arrays

# сгенерировано в Plugin IDE

class CommandSuggestionsHook(MethodHook):
    """
    Этот хук перехватывает ввод текста в чате для поиска упоминаний
    и вместо этого подставляет настроенный список команд из плагинов.
    """
    def __init__(self, plugin_instance):
        self.plugin = plugin_instance
        self.pi_command_harvester = PluginCommandHarvester(plugins_manager.PluginsManager._plugins_dir)
        self._command_cache = {}

    def _sanitize_key(self, command: str) -> str:
        """Создает безопасный ключ для настроек из имени команды."""
        return command.replace('.', '_dot_')

    def before_hooked_method(self, param):
        try:
            if not param.args or not hasattr(param.args[0], 'length') or param.args[0].length() == 0:
                return

            text = str(param.args[0].toString())
            if not text.startswith("."):
                return
                
            string_class = find_class("java.lang.String").getClass()
            mentions_adapter = param.thisObject

            field_commands = mentions_adapter.getClass().getDeclaredField("searchResultCommands")
            field_help = mentions_adapter.getClass().getDeclaredField("searchResultCommandsHelp")
            field_delegate = mentions_adapter.getClass().getDeclaredField("delegate")
            
            for field in [field_commands, field_help, field_delegate]:
                field.setAccessible(True)
            
            field_commands.set(mentions_adapter, ArrayList())
            field_help.set(mentions_adapter, ArrayList())

            def draw_suggestions():
                # 1. Получаем все возможные команды (из кэша или сканированием)
                if not self._command_cache:
                    p_map = self.pi_command_harvester.get_command_map()
                    cmds, cmds_help = [], []
                    
                    for plugin_name, commands in p_map.items():
                        for cmd in commands:
                            if cmd.startswith("."):
                                cmds.append(cmd)
                                cmds_help.append(f"Из плагина: {plugin_name}")
                    
                    custom_commands_str = self.plugin.get_setting("custom_commands", "")
                    if custom_commands_str:
                        for pair in [p.strip() for p in custom_commands_str.split(',') if p.strip()]:
                            parts = pair.split(':', 1)
                            cmd = parts[0].strip()
                            desc = parts[1].strip() if len(parts) > 1 else "Пользовательская команда"
                            if cmd.startswith('.') and cmd not in cmds:
                                cmds.append(cmd)
                                cmds_help.append(desc)
                    
                    self._command_cache = {"cmds": cmds, "cmds_help": cmds_help}

                all_cmds = self._command_cache["cmds"]
                all_cmds_help = self._command_cache["cmds_help"]

                # 2. Фильтруем команды на основе переключателей в настройках
                enabled_cmds, enabled_cmds_help = [], []
                for i, cmd in enumerate(all_cmds):
                    # Проверяем состояние переключателя для каждой команды
                    key = f"cmd_enabled_{self._sanitize_key(cmd)}"
                    if self.plugin.get_setting(key, True): # По умолчанию все включено
                        enabled_cmds.append(cmd)
                        enabled_cmds_help.append(all_cmds_help[i])

                # 3. Фильтруем по вводу пользователя
                final_filtered_cmds, final_filtered_help = [], []
                for i, cmd in enumerate(enabled_cmds):
                    if cmd.lower().startswith(text.lower()):
                        final_filtered_cmds.append(cmd)
                        final_filtered_help.append(enabled_cmds_help[i])
                
                # 4. Отображаем результат
                new_result_commands = ArrayList(Arrays.asList(jarray(string_class)(final_filtered_cmds)))
                new_result_help = ArrayList(Arrays.asList(jarray(string_class)(final_filtered_help)))
                
                field_commands.set(mentions_adapter, new_result_commands)
                field_help.set(mentions_adapter, new_result_help)
                
                mentions_adapter.notifyDataSetChanged()
                delegate = field_delegate.get(mentions_adapter)
                if delegate:
                    delegate.needChangePanelVisibility(bool(final_filtered_cmds))
            
            run_on_ui_thread(draw_suggestions)

        except Exception as e:
            self.plugin.log(f"Ошибка в хуке CommandSuggestions: {e}")

class CommandHelperPlugin(BasePlugin):
    """
    Основной класс плагина, который управляет хуком и настройками.
    """
    def __init__(self):
        super().__init__()
        self.edit_hook_handler = None
        self.unhook_object = None
        # Инициализируем парсер один раз для использования в настройках
        self.pi_command_harvester = PluginCommandHarvester(plugins_manager.PluginsManager._plugins_dir)

    def _sanitize_key(self, command: str) -> str:
        """Создает безопасный ключ для настроек из имени команды."""
        return command.replace('.', '_dot_')

    def create_settings(self):
        settings_list = [Header(text="Управление подсказками команд")]

        # Получаем все команды для отображения в настройках
        all_commands = []
        plugin_commands_map = self.pi_command_harvester.get_command_map()
        for plugin_name, commands in sorted(plugin_commands_map.items()):
            for cmd in commands:
                all_commands.append((cmd, f"Из плагина: {plugin_name}"))

        settings_list.append(Header(text="Команды из плагинов"))
        if not plugin_commands_map:
             settings_list.append(Divider(text="Команд из других плагинов не найдено."))
        else:
            for cmd, subtext in all_commands:
                key = f"cmd_enabled_{self._sanitize_key(cmd)}"
                settings_list.append(Switch(
                    key=key,
                    text=cmd,
                    subtext=subtext,
                    default=True # По умолчанию все команды включены
                ))
        
        settings_list.extend([
            Divider(),
            Header(text="Пользовательские команды"),
            Input(
                key="custom_commands",
                text="Добавить свои команды",
                subtext="Формат: .команда:Описание, .другая:Еще описание",
                icon="msg_add_file"
            ),
            Divider(text="Чтобы применить изменения, используйте команду .preload")
        ])
        
        return settings_list

    def on_plugin_load(self) -> None:
        try:
            char_sequence_class = find_class("java.lang.CharSequence")
            boolean_type = find_class("java.lang.Boolean").TYPE
            int_type = find_class("java.lang.Integer").TYPE
            array_list_class = find_class("java.util.ArrayList")

            mentions_adapter_class = find_class("org.telegram.ui.Adapters.MentionsAdapter").getClass()
            method_to_hook = mentions_adapter_class.getDeclaredMethod("searchUsernameOrHashtag", char_sequence_class, int_type, array_list_class, boolean_type, boolean_type)
            
            self.edit_hook_handler = CommandSuggestionsHook(self) 
            self.unhook_object = self.hook_method(method_to_hook, self.edit_hook_handler, priority=10)
            
            self.add_on_send_message_hook()
            self.log("Плагин 'Помощник по командам' успешно загружен!")

        except Exception as e:
            self.log(f"Не удалось загрузить плагин 'Помощник по командам': {e}")
            BulletinHelper.show_error("Ошибка загрузки Помощника по командам")

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        if not hasattr(params, 'message') or not isinstance(params.message, str):
            return HookResult()
            
        text = params.message.strip().lower()
        
        if text == ".preload":
            self.log(f"Перезагрузка кэша команд для плагина {self.id}")
            if self.edit_hook_handler:
                self.edit_hook_handler._command_cache = {}
                self.log("Кэш команд успешно очищен.")
            BulletinHelper.show_success(f"Команды плагинов перезагружены!")
            return HookResult(strategy=HookStrategy.CANCEL)
            
        return HookResult(strategy=HookStrategy.DEFAULT)

    def on_plugin_unload(self):
        if self.unhook_object:
            self.unhook_object.unhook()
            self.unhook_object = None
            self.log("Хук 'Помощника по командам' успешно удален.")

class PluginCommandHarvester:
    """
    Этот класс "собирает" все команды, сканируя файлы других плагинов.
    Он использует безопасный парсинг AST, не исполняя код плагинов.
    """
    
    class _CommandVisitor(ast.NodeVisitor):
        """Внутренний посетитель AST для поиска команд."""
        # (Ф∀Ф)
        VALID_COMMAND_RE = re.compile(r"^[\.\/][a-zA-Z0-9_-]+$")

        def __init__(self):
            self.commands = set()
            self.plugin_name = None
        
        def visit_ClassDef(self, node: ast.ClassDef):
            for base in node.bases:
                if isinstance(base, ast.Name) and base.id == 'BasePlugin':
                    self.plugin_name = node.name
                    break
            self.generic_visit(node)

        def _add_command_if_valid(self, value: str):
            if isinstance(value, str):
                command = value.strip().split(" ")[0]
                if self.VALID_COMMAND_RE.match(command):
                    self.commands.add(command)
        
        def visit_Compare(self, node: ast.Compare):
            if isinstance(node.ops[0], ast.Eq):
                for item in [node.left] + node.comparators:
                    if isinstance(item, ast.Constant):
                        self._add_command_if_valid(item.value)
            self.generic_visit(node)

        def visit_Call(self, node: ast.Call):
            if isinstance(node.func, ast.Attribute) and node.func.attr == 'startswith':
                if node.args and isinstance(node.args[0], ast.Constant):
                    self._add_command_if_valid(node.args[0].value)
            self.generic_visit(node)

    def __init__(self, plugins_directory: str):
        if not os.path.isdir(plugins_directory):
            raise FileNotFoundError(f"Директория с плагинами не найдена: {plugins_directory}")
        self.plugins_directory = plugins_directory

    def _extract_info_from_file(self, file_path: str):
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                content = f.read()
            tree = ast.parse(content, filename=file_path)
            visitor = self._CommandVisitor()
            visitor.visit(tree)
            if visitor.plugin_name and visitor.commands:
                return visitor.plugin_name, sorted(list(visitor.commands))
        except Exception:
            pass
        return None

    def get_command_map(self):
        """Сканирует все плагины и возвращает словарь {'ИмяПлагина': [команды]}."""
        command_map = {}
        for filename in os.listdir(self.plugins_directory):
            if filename.endswith(('.py', '.plugin')):
                file_path = os.path.join(self.plugins_directory, filename)
                info = self._extract_info_from_file(file_path)
                if info:
                    plugin_name, commands = info
                    command_map[plugin_name] = commands
        return dict(sorted(command_map.items())) if command_map else {}
