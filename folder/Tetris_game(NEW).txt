__id__ = "tetris_game"
__name__ = "Tetris Game"
__description__ = """üá∑üá∫[RU]\n–ò–≥—Ä–∞ —Ç–µ—Ç—Ä–∏—Å, —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫: @SaturnFake, –∫–∞–Ω–∞–ª —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞: @DevPluginsEUG\n\nüá¨üáß[EN]\nTetris Game, developer: @SaturnFake, developer channel: @DevPluginsEUG"""
__author__ = "@SaturnFake"
__icon__ = "Plugins_Test/5"
__min_version__ = "11.12.1"
__version__ = "1.2.1"

from base_plugin import BasePlugin, HookResult, HookStrategy, MenuItemData, MenuItemType, AppEvent
from android_utils import run_on_ui_thread, log
from client_utils import get_last_fragment
from ui.alert import AlertDialogBuilder
from ui.settings import Header, Divider, Text
from android.widget import LinearLayout, TextView, Button, FrameLayout
from android.view import View, ViewGroup
import random
from android.view import Gravity
from org.telegram.messenger import LocaleController, AndroidUtilities
from android.graphics.drawable import GradientDrawable, StateListDrawable
from android.graphics import Typeface, Color
from java import dynamic_proxy
import time

SHAPES = [
    [[1, 1, 1, 1]],  
    [[1, 1, 1], [0, 1, 0]],
    [[1, 1, 1], [1, 0, 0]],  
    [[1, 1, 1], [0, 0, 1]], 
    [[1, 1], [1, 1]], 
    [[0, 1, 1], [1, 1, 0]], 
    [[1, 1, 0], [0, 1, 1]] 
]

COLORS = [
    Color.rgb(0, 240, 255),     
    Color.rgb(200, 0, 255),     
    Color.rgb(0, 100, 255),     
    Color.rgb(255, 165, 0),     
    Color.rgb(255, 230, 0),     
    Color.rgb(50, 230, 50),     
    Color.rgb(255, 50, 50)      
]

def get_locale():
    try:
        lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
        return lang
    except Exception:
        return "en"
       
def t(key, **kwargs):
    lang = get_locale() 
    ru = {
        "pause": "‚áÜ Stop",
        "resume": "‚ñ∂ Play",
        "reset": "‚Ü∫ –°–±—Ä–æ—Å",
        "close": "‚û≤ –ó–∞–∫—Ä—ã—Ç—å",
        "left": "‚áê",
        "right": "‚áí",
        "rotate": "‚Ü∫",
        "drop": "‚áò‚áô",
        "score": "üèÜ –°—á–µ—Ç: {score}",
        "level": "üìà –£—Ä–æ–≤–µ–Ω—å: {level}",
        "lines": "üìä –õ–∏–Ω–∏–∏: {lines}",
        "next": "‚áí –°–ª–µ–¥—É—é—â–∞—è:",
        "game_over": "üí• –ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê!",
        "dialog_title": "üéÆ –¢–µ—Ç—Ä–∏—Å",
        "menu_title": "üéÆ –¢–µ—Ç—Ä–∏—Å",
        "command_help": "üöÄ–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É '.tetris' –∏–ª–∏ 3dot menu -> Tetris game",
        "high_score": "üèÜ –†–µ–∫–æ—Ä–¥: {score}",
        "game_over_title": "–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏ üò≠",
        "game_over_message": "–í–∞—à —Å—á–µ—Ç: {score}\n–†–µ–∫–æ—Ä–¥: {high_score}",
        "new_record": "üéâ –ù–æ–≤—ã–π —Ä–µ–∫–æ—Ä–¥!",
        "restart": "üîÑ –ó–∞–Ω–æ–≤–æ",
        "exit": "üö™ –í—ã–π—Ç–∏",
        "settings_title": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¢–µ—Ç—Ä–∏—Å–∞",
        "reset_high_score": "–°–±—Ä–æ—Å–∏—Ç—å —Ä–µ–∫–æ—Ä–¥",
        "reset_confirm": "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–±—Ä–æ—Å–∏—Ç—å —Ä–µ–∫–æ—Ä–¥?",
        "reset_success": "–†–µ–∫–æ—Ä–¥ —É—Å–ø–µ—à–Ω–æ —Å–±—Ä–æ—à–µ–Ω!",
        "version_info": "–í–µ—Ä—Å–∏—è: {version}",
        "whats_new": "–ß—Ç–æ –Ω–æ–≤–æ–≥–æ?",
        "changelog_title": "–ò—Å—Ç–æ—Ä–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π",
        "changelog_text": "–í–µ—Ä—Å–∏—è 1.2.1:\n- –î–æ–±–∞–≤–ª–µ–Ω–∞ —Å–∏—Å—Ç–µ–º–∞ –ø–æ–∫–∞–∑–∞ —Å–ª–µ–¥—É—é—â–µ–π —Ñ–∏–≥—É—Ä—ã\n- –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∫–æ—Ä–¥–∞\n- –î–æ–±–∞–≤–ª–µ–Ω—ã –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–ª–∞–≥–∏–Ω–∞\n- –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å"
    }
    en = {
        "pause": "‚áÜ Stop",
        "resume": "‚ñ∂ Play",
        "reset": "‚Ü∫ Reset",
        "close": "‚û≤ Close",
        "left": "‚áê",
        "right": "‚áí",
        "rotate": "‚Ü∫",
        "drop": "‚áò‚áô",
        "score": "üèÜ Score: {score}",
        "level": "üìà Level: {level}",
        "lines": "üìä Lines: {lines}",
        "next": "‚û°Ô∏è Next:",
        "game_over": "üí• GAME OVER!",
        "dialog_title": "üéÆ Tetris",
        "menu_title": "üéÆ Tetris",
        "command_help": "üöÄUse cmd '.tetris' or 3dot menu -> Tetris game",
        "high_score": "üèÜ High Score: {score}",
        "game_over_title": "Game Over üò≠",
        "game_over_message": "Your score: {score}\nHigh score: {high_score}",
        "new_record": "üéâ New record!",
        "restart": "üîÑ Restart",
        "exit": "üö™ Exit",
        "settings_title": "Tetris Settings",
        "reset_high_score": "Reset High Score",
        "reset_confirm": "Are you sure you want to reset high score?",
        "reset_success": "High score reset successfully!",
        "version_info": "Version: {version}",
        "whats_new": "What's New?",
        "changelog_title": "Changelog",
        "changelog_text": "Version 1.1.1:\n- Added next piece preview\n- Fixed high score saving\n- Added plugin settings\n- Performance optimizations"
    }
    d = ru if lang.startswith("ru") else en
    val = d.get(key, key)
    if kwargs:
        return val.format(**kwargs)
    return val

def create_button(context, text, bg_color, text_color=Color.WHITE, text_size=12):
    button = Button(context)
    button.setText(text)
    button.setTextColor(text_color)
    button.setTypeface(None, Typeface.BOLD)
    button.setTextSize(text_size)
    
    state_list = StateListDrawable()
    
    normal_drawable = GradientDrawable()
    normal_drawable.setColor(bg_color)
    normal_drawable.setCornerRadius(AndroidUtilities.dp(6))
    
    pressed_color = Color.argb(255,
                               min(255, Color.red(bg_color) + 30),
                               min(255, Color.green(bg_color) + 30),
                               min(255, Color.blue(bg_color) + 30))
    pressed_drawable = GradientDrawable()
    pressed_drawable.setColor(pressed_color)
    pressed_drawable.setCornerRadius(AndroidUtilities.dp(6))
    
    state_list.addState([], normal_drawable)
    state_list.addState([1], pressed_drawable)
    
    button.setBackground(state_list)
    button.setPadding(
        AndroidUtilities.dp(12),
        AndroidUtilities.dp(8),
        AndroidUtilities.dp(12), 
        AndroidUtilities.dp(8)
    )
    params = LinearLayout.LayoutParams(
        ViewGroup.LayoutParams.WRAP_CONTENT,
        ViewGroup.LayoutParams.WRAP_CONTENT
    )
    params.setMargins(
        AndroidUtilities.dp(4),
        AndroidUtilities.dp(4),
        AndroidUtilities.dp(4),
        AndroidUtilities.dp(4)
    )
    button.setLayoutParams(params)
    return button

class ButtonClickListener(dynamic_proxy(View.OnClickListener)):
    def __init__(self, plugin, action):
        super(ButtonClickListener, self).__init__()
        self.plugin = plugin
        self.action = action
        
    def onClick(self, v):
        if self.action == "left":
            self.plugin.game.move(-1, 0)
        elif self.action == "right":
            self.plugin.game.move(1, 0)
        elif self.action == "rotate":
            self.plugin.game.rotate_piece()
        elif self.action == "drop":
            self.plugin.game.drop()
        elif self.action == "pause":
            self.plugin.toggle_pause()
        elif self.action == "reset":
            self.plugin.reset_game()
        elif self.action == "close":
            self.plugin.close_game()
            
        self.plugin.update_view()

class TetrisGame:
    def __init__(self, plugin):
        self.plugin = plugin
        self.width = 10
        self.height = 16
        self.reset()
        
    def reset(self):
        self.high_score = self.plugin.get_setting("tetris_high_score", 0)
        
        self.board = [[0 for _ in range(self.width)] for _ in range(self.height)]
        self.score = 0
        self.level = 1
        self.lines_cleared = 0
        self.game_over = False
        self.paused = False
        self.next_piece = self.create_piece()
        self.new_piece()
        
    def create_piece(self):
        shape_idx = random.randint(0, len(SHAPES) - 1)
        return {
            'shape': SHAPES[shape_idx],
            'color': COLORS[shape_idx],
            'x': self.width // 2 - 1,
            'y': 0
        }
        
    def new_piece(self):
        self.current_piece = self.next_piece
        self.next_piece = self.create_piece()
        if self.check_collision():
            self.game_over = True
            
    def rotate_piece(self):
        old_shape = self.current_piece['shape']
        new_shape = [list(row) for row in zip(*old_shape[::-1])]
        self.current_piece['shape'] = new_shape
        if self.check_collision():
            self.current_piece['shape'] = old_shape
            
    def check_collision(self):
        shape = self.current_piece['shape']
        for y in range(len(shape)):
            for x in range(len(shape[0])):
                if shape[y][x] == 0:
                    continue
                pos_x = self.current_piece['x'] + x
                pos_y = self.current_piece['y'] + y
                if (pos_x < 0 or pos_x >= self.width or 
                    pos_y >= self.height or 
                    (pos_y >= 0 and self.board[pos_y][pos_x] != 0)):
                    return True
        return False
        
    def move(self, dx, dy):
        if self.game_over or self.paused:
            return False
        self.current_piece['x'] += dx
        self.current_piece['y'] += dy
        if self.check_collision():
            self.current_piece['x'] -= dx
            self.current_piece['y'] -= dy
            if dy > 0:
                self.lock_piece()
                self.clear_lines()
                self.new_piece()
                return True
        return False
        
    def drop(self):
        while not self.move(0, 1):
            pass
            
    def lock_piece(self):
        shape = self.current_piece['shape']
        for y in range(len(shape)):
            for x in range(len(shape[0])):
                if shape[y][x] == 0:
                    continue
                pos_x = self.current_piece['x'] + x
                pos_y = self.current_piece['y'] + y
                if 0 <= pos_y < self.height and 0 <= pos_x < self.width:
                    self.board[pos_y][pos_x] = self.current_piece['color']
        
    def clear_lines(self):
        lines_to_clear = []
        for y in range(self.height):
            if all(self.board[y]):
                lines_to_clear.append(y)
                
        for line in lines_to_clear:
            del self.board[line]
            self.board.insert(0, [0 for _ in range(self.width)])
            
        if lines_to_clear:
            self.lines_cleared += len(lines_to_clear)
            self.score += {1: 100, 2: 300, 3: 500, 4: 800}[min(4, len(lines_to_clear))] * self.level
            self.level = self.lines_cleared // 10 + 1

class TetrisPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.game = None
        self.dialog = None
        self.activity = None
        self.game_loop_running = False
        self.cell_size = AndroidUtilities.dp(18)
        self.last_move_time = 0
        self.game_over_alert = None
        self.cell_views = []
        self.game_over_handled = False
        self.new_record = False
        self.app_in_foreground = True
        self.next_piece_preview = None

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self.add_menu_item(MenuItemData(
            menu_type=MenuItemType.CHAT_ACTION_MENU,
            text=t("menu_title"),
            icon="msg_media",
            on_click=self.show_game_dialog_from_menu
        ))
        
    def on_plugin_unload(self):
        self.stop_game_loop()
        
    def on_app_event(self, event_type: AppEvent):
        if event_type == AppEvent.PAUSE:
            self.app_in_foreground = False
            self.stop_game_loop()
            self.close_game(silent=True)
        elif event_type == AppEvent.RESUME:
            self.app_in_foreground = True
        
    def create_settings(self):
        return [
            Header(text=t("settings_title")),
            Text(
                text=t("version_info", version=__version__),
                icon="msg_info"
            ),
            Text(
                text=t("whats_new"),
                icon="msg_recent",
                on_click=self.show_changelog
            ),
            Text(
                text=t("reset_high_score"),
                icon="msg_delete",
                red=True,
                on_click=self.reset_high_score
            ),
            Divider(text=t("command_help"))
        ]
        
    def show_changelog(self, view):
        builder = AlertDialogBuilder(self.activity)
        builder.set_title(t("changelog_title"))
        builder.set_message(t("changelog_text"))
        builder.set_positive_button("OK", None)
        builder.show()
        
    def reset_high_score(self, view):
        builder = AlertDialogBuilder(self.activity)
        builder.set_title(t("reset_high_score"))
        builder.set_message(t("reset_confirm"))
        
        def on_confirm(dialog, which):
            self.set_setting("tetris_high_score", 0)
            builder = AlertDialogBuilder(self.activity)
            builder.set_title(t("reset_success"))
            builder.set_positive_button("OK", None)
            builder.show()
            
        builder.set_positive_button(t("reset"), on_confirm)
        builder.set_negative_button(t("close"), None)
        builder.show()
        
    def on_send_message_hook(self, account: int, params) -> HookResult:
        if isinstance(params.message, str) and params.message.startswith(".tetris"):
            try:
                self.start_game()
                return HookResult(strategy=HookStrategy.CANCEL)
            except Exception as e:
                log(f"Tetris error: {str(e)}")
                params.message = f"üö´ –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –∏–≥—Ä—ã: {str(e)}"
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
        

    def show_game_dialog_from_menu(self, context: dict):
        self.start_game()
        
    def start_game(self):
        self.game = TetrisGame(self)
        self.game_over_handled = False
        self.new_record = False
        current_fragment = get_last_fragment()
        if not current_fragment:
            return

        self.activity = current_fragment.getParentActivity()
        if not self.activity:
            return

        run_on_ui_thread(self.create_game_dialog)
        
    def create_game_dialog(self):
        builder = AlertDialogBuilder(self.activity)
        builder.set_title(t("dialog_title"))
        
        main_container = LinearLayout(self.activity)
        main_container.setOrientation(LinearLayout.VERTICAL)
        padding = AndroidUtilities.dp(10)
        main_container.setPadding(padding, padding, padding, padding)
        background = GradientDrawable()
        background.setColor(Color.rgb(30, 35, 40))
        background.setCornerRadius(AndroidUtilities.dp(10))
        main_container.setBackground(background)
        
        header = LinearLayout(self.activity)
        header.setOrientation(LinearLayout.HORIZONTAL)
        header.setGravity(Gravity.CENTER_VERTICAL)
        header.setLayoutParams(LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT
        ))
        
        stats = LinearLayout(self.activity)
        stats.setOrientation(LinearLayout.VERTICAL)
        stats.setLayoutParams(LinearLayout.LayoutParams(
            0, ViewGroup.LayoutParams.WRAP_CONTENT, 1
        ))
        self.score_view = TextView(self.activity)
        self.score_view.setTextSize(14)
        self.score_view.setTypeface(None, Typeface.BOLD)
        self.score_view.setTextColor(Color.rgb(255, 215, 0))
        stats.addView(self.score_view)
        self.level_view = TextView(self.activity)
        self.level_view.setTextSize(12)
        self.level_view.setTextColor(Color.rgb(200, 200, 255))
        stats.addView(self.level_view)
        self.lines_view = TextView(self.activity)
        self.lines_view.setTextSize(12)
        self.lines_view.setTextColor(Color.rgb(200, 200, 255))
        stats.addView(self.lines_view)
        self.high_score_view = TextView(self.activity)
        self.high_score_view.setTextSize(12)
        self.high_score_view.setTextColor(Color.rgb(180, 230, 180))
        stats.addView(self.high_score_view)
        header.addView(stats)
        
        next_area = LinearLayout(self.activity)
        next_area.setOrientation(LinearLayout.VERTICAL)
        next_area.setGravity(Gravity.CENTER)
        next_text = TextView(self.activity)
        next_text.setText(t("next"))
        next_text.setTextColor(Color.WHITE)
        next_text.setTextSize(12)
        next_text.setTypeface(None, Typeface.BOLD)
        next_area.addView(next_text)
        self.next_piece_preview = FrameLayout(self.activity)
        self.next_piece_preview.setMinimumWidth(AndroidUtilities.dp(70))
        self.next_piece_preview.setMinimumHeight(AndroidUtilities.dp(50))
        next_area.addView(self.next_piece_preview)
        header.addView(next_area)
        
        main_container.addView(header)
        
        divider = View(self.activity)
        divider.setLayoutParams(LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT, 
            AndroidUtilities.dp(1)
        ))
        divider.setBackgroundColor(Color.argb(50, 255, 255, 255))
        main_container.addView(divider)
        
        board_container = FrameLayout(self.activity)
        board_container.setBackgroundColor(Color.argb(50, 0, 0, 0))
        board_container.setPadding(
            AndroidUtilities.dp(4),
            AndroidUtilities.dp(4),
            AndroidUtilities.dp(4), 
            AndroidUtilities.dp(4)
        )
        self.board_grid = LinearLayout(self.activity)
        self.board_grid.setOrientation(LinearLayout.VERTICAL)
        layout_params = FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.WRAP_CONTENT,
            ViewGroup.LayoutParams.WRAP_CONTENT
        )
        layout_params.gravity = Gravity.CENTER_HORIZONTAL
        self.board_grid.setLayoutParams(layout_params)
        board_container.addView(self.board_grid)
        
        self.cell_views = []
        for y in range(self.game.height):
            row = LinearLayout(self.activity)
            row.setOrientation(LinearLayout.HORIZONTAL)
            for x in range(self.game.width):
                cell = View(self.activity)
                cell.setLayoutParams(LinearLayout.LayoutParams(
                    self.cell_size, self.cell_size
                ))
                margin = AndroidUtilities.dp(1)
                cell.getLayoutParams().setMargins(margin, margin, margin, margin)
                cell.setBackgroundColor(Color.TRANSPARENT)
                row.addView(cell)
                self.cell_views.append(cell)
            self.board_grid.addView(row)
        
        main_container.addView(board_container)
        
        controls_container = LinearLayout(self.activity)
        controls_container.setOrientation(LinearLayout.VERTICAL)
        controls_container.setGravity(Gravity.CENTER)
        controls_container.setPadding(0, AndroidUtilities.dp(10), 0, 0)
        
        top_row = LinearLayout(self.activity)
        top_row.setOrientation(LinearLayout.HORIZONTAL)
        top_row.setGravity(Gravity.CENTER)
        
        left_button = create_button(self.activity, t("left"), Color.rgb(60, 100, 150))
        left_button.setOnClickListener(ButtonClickListener(self, "left"))
        top_row.addView(left_button)
        
        rotate_button = create_button(self.activity, t("rotate"), Color.rgb(100, 60, 150))
        rotate_button.setOnClickListener(ButtonClickListener(self, "rotate"))
        top_row.addView(rotate_button)
        
        right_button = create_button(self.activity, t("right"), Color.rgb(60, 100, 150))
        right_button.setOnClickListener(ButtonClickListener(self, "right"))
        top_row.addView(right_button)
        
        controls_container.addView(top_row)
        
        middle_row = LinearLayout(self.activity)
        middle_row.setOrientation(LinearLayout.HORIZONTAL)
        middle_row.setGravity(Gravity.CENTER)
        
        drop_button = create_button(self.activity, t("drop"), Color.rgb(50, 130, 80))
        drop_button.setOnClickListener(ButtonClickListener(self, "drop"))
        middle_row.addView(drop_button)
        
        controls_container.addView(middle_row)
        
        bottom_row = LinearLayout(self.activity)
        bottom_row.setOrientation(LinearLayout.HORIZONTAL)
        bottom_row.setGravity(Gravity.CENTER)
        
        self.pause_button = create_button(self.activity, t("pause"), Color.rgb(70, 100, 150))
        self.pause_button.setOnClickListener(ButtonClickListener(self, "pause"))
        bottom_row.addView(self.pause_button)
        
        reset_button = create_button(self.activity, t("reset"), Color.rgb(180, 100, 50))
        reset_button.setOnClickListener(ButtonClickListener(self, "reset"))
        bottom_row.addView(reset_button)
        
        close_button = create_button(self.activity, t("close"), Color.rgb(180, 60, 60))
        close_button.setOnClickListener(ButtonClickListener(self, "close"))
        bottom_row.addView(close_button)
        
        controls_container.addView(bottom_row)
        main_container.addView(controls_container)
        
        builder.set_view(main_container)
        builder.set_cancelable(False)
        self.dialog = builder.create()
        self.dialog.show()
        
        self.start_game_loop()
        self.update_view()
        self.update_next_piece_preview()
        
    def start_game_loop(self):
        if self.game_loop_running or not self.app_in_foreground:
            return
            
        self.game_loop_running = True
        self.last_move_time = time.time() * 1000
        
        def game_loop():
            if not self.game_loop_running or not self.app_in_foreground:
                return
                
            try:
                current_time = time.time() * 1000
                speed = max(100, 500 // self.game.level)
                
                if current_time - self.last_move_time > speed:
                    self.game.move(0, 1)
                    self.last_move_time = current_time
                    self.update_view()
                    
                run_on_ui_thread(game_loop, max(10, speed // 5))
            except Exception as e:
                log(f"Game loop error: {str(e)}")
                self.game_loop_running = False
                
        run_on_ui_thread(game_loop)
        
    def stop_game_loop(self):
        self.game_loop_running = False
        
    def toggle_pause(self):
        self.game.paused = not self.game.paused
        self.pause_button.setText(t("resume") if self.game.paused else t("pause"))
        self.update_view()
        
    def reset_game(self):
        self.game = TetrisGame(self)
        self.game_over_handled = False
        self.new_record = False
        self.pause_button.setText(t("pause"))
        self.update_view()
        self.update_next_piece_preview()
        self.start_game_loop()

        if self.game_over_alert is not None:
            try:
                self.game_over_alert.dismiss()
            except:
                pass
            self.game_over_alert = None
        
    def close_game(self, silent=False):
        self.stop_game_loop()
        
        if self.game.score > self.game.high_score:
            self.game.high_score = self.game.score
            self.set_setting("tetris_high_score", self.game.high_score)
            self.new_record = True
            
        if self.dialog:
            self.dialog.dismiss()
            self.dialog = None
            
        if not silent and self.game_over_alert is not None:
            try:
                self.game_over_alert.dismiss()
            except:
                pass
            self.game_over_alert = None
            
    def show_game_over_alert(self):
        if not self.app_in_foreground:
            self.game_over_handled = True
            return
            
        self.stop_game_loop()
        
        if self.game_over_handled:
            return
            
        self.game_over_handled = True
        
        if self.game.score > self.game.high_score:
            self.game.high_score = self.game.score
            self.set_setting("tetris_high_score", self.game.high_score)
            self.new_record = True
        
        builder = AlertDialogBuilder(self.activity)
        builder.set_title(t("game_over_title"))
        
        message = t("game_over_message",
                   score=self.game.score,
                   high_score=self.game.high_score)
        
        if self.new_record:
            message = t("new_record") + "\n\n" + message
        
        builder.set_message(message)
        
        def on_restart(dialog, which):
            self.reset_game()
            
        def on_exit(dialog, which):
            self.close_game()
            
        builder.set_positive_button(t("restart"), on_restart)
        builder.set_negative_button(t("exit"), on_exit)
        builder.set_cancelable(False)
        self.game_over_alert = builder.create()
        self.game_over_alert.show()
        
    def update_next_piece_preview(self):
        if not self.next_piece_preview:
            return
            
        self.next_piece_preview.removeAllViews()
        
        if not self.game or not self.game.next_piece:
            return
            
        shape = self.game.next_piece['shape']
        color = self.game.next_piece['color']
        cell_size = AndroidUtilities.dp(12)
        
        preview_container = LinearLayout(self.activity)
        preview_container.setOrientation(LinearLayout.VERTICAL)
        preview_container.setGravity(Gravity.CENTER)
        
        for y in range(len(shape)):
            row = LinearLayout(self.activity)
            row.setOrientation(LinearLayout.HORIZONTAL)
            row.setGravity(Gravity.CENTER)
            
            for x in range(len(shape[0])):
                cell = View(self.activity)
                cell.setLayoutParams(LinearLayout.LayoutParams(cell_size, cell_size))
                
                if shape[y][x] != 0:
                    background = GradientDrawable()
                    background.setColor(color)
                    background.setCornerRadius(AndroidUtilities.dp(2))
                    cell.setBackground(background)
                else:
                    cell.setBackgroundColor(Color.TRANSPARENT)
                
                row.addView(cell)
            
            preview_container.addView(row)
        
        self.next_piece_preview.addView(preview_container)
        
    def update_view(self):
        if not self.app_in_foreground:
            return
            
        self.score_view.setText(t("score", score=self.game.score))
        self.level_view.setText(t("level", level=self.game.level))
        self.lines_view.setText(t("lines", lines=self.game.lines_cleared))
        self.high_score_view.setText(t("high_score", score=self.game.high_score))
        
        for cell in self.cell_views:
            background = GradientDrawable()
            background.setColor(Color.argb(30, 255, 255, 255))
            background.setCornerRadius(AndroidUtilities.dp(3))
            cell.setBackground(background)
        
        for y in range(self.game.height):
            for x in range(self.game.width):
                idx = y * self.game.width + x
                cell = self.cell_views[idx]
                color = self.game.board[y][x]
                
                if color != 0:
                    background = GradientDrawable()
                    background.setColor(color)
                    background.setCornerRadius(AndroidUtilities.dp(4))
                    cell.setBackground(background)
        
        if not self.game.game_over:
            shape = self.game.current_piece['shape']
            color = self.game.current_piece['color']
            for y in range(len(shape)):
                for x in range(len(shape[0])):
                    if shape[y][x] != 0:
                        pos_x = self.game.current_piece['x'] + x
                        pos_y = self.game.current_piece['y'] + y
                        
                        if 0 <= pos_y < self.game.height and 0 <= pos_x < self.game.width:
                            idx = pos_y * self.game.width + pos_x
                            cell = self.cell_views[idx]
                            
                            background = GradientDrawable()
                            background.setColor(color)
                            background.setCornerRadius(AndroidUtilities.dp(4))
                            cell.setBackground(background)
        
        self.update_next_piece_preview()
        
        if self.game.game_over and not self.game_over_handled:
            self.show_game_over_alert()